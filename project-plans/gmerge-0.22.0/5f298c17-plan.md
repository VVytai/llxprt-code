# Reimplementation Plan: Persistent Always-Allow Policies (upstream 5f298c17)

## TEST-DRIVEN DEVELOPMENT APPROACH - HIGH RISK FEATURE

**This plan follows RULES.md: Write tests first (RED), implement minimal code (GREEN), refactor if valuable.**

---

## WARNING: CRITICAL SECURITY REQUIREMENT

**ZERO GOOGLE TELEMETRY - ALL PERSISTENCE MUST BE LOCAL TOML ONLY**

This feature MUST NOT introduce any telemetry, logging, or data transmission to Google services. All policy persistence must use local TOML files only (`~/.llxprt/policies/auto-saved.toml`). Any reference to ClearcutLogger or Google telemetry infrastructure is strictly forbidden.

---

## Executive Summary

### Upstream Commit

**Commit:** 5f298c17d7f6c3a1eabbeac249904cd1cf141352  
**Author:** Allen Hutchison <adh@google.com>  
**Date:** Fri Dec 12 13:45:39 2025 -0800  
**Title:** feat: Persistent "Always Allow" policies with granular shell & MCP support (#14737)  
**Stats:** 18 files changed, +431/-21 lines

### What This Feature Does

Adds persistent "Always Allow" policies that survive session restarts:

1. **New UI Option** - "Yes, allow always and save to policy" (alongside existing session-only "Yes, allow always")
2. **Granular Shell Commands** - Save policies for specific command prefixes (e.g., "git status" != "git push")
3. **MCP Tool Policies** - Save policies for specific MCP server/tool combinations
4. **TOML Persistence** - Auto-saves to `~/.llxprt/policies/auto-saved.toml`
5. **Dual Operation** - Policies work in current session (in-memory) AND persist across restarts (file-based)

### Why We Can't Cherry-Pick

1. **License headers** - Vybestack LLC vs Google LLC (Apache-2.0 same, but copyright differs)
2. **Import paths** - `@vybestack/llxprt-code-core` vs `@google/gemini-cli-core`
3. **Storage paths** - `~/.llxprt/policies/` vs `~/.gemini-code-cli/policies/`
4. **File differences** - LLxprt removed `smart-edit.ts`, split `web-fetch.ts` into two files
5. **Telemetry audit** - Must verify NO Google telemetry introduced
6. **Test patterns** - Different vitest setup and mocking patterns

---

## Requirements (Behavioral Specifications)

### R1: New Confirmation Outcome Type

**Behavior:** User can select "Yes, allow always and save to policy" option that persists across sessions.

**Acceptance Criteria:**
- New enum value `ProceedAlwaysAndSave` in `ToolConfirmationOutcome`
- Distinct from `ProceedAlways` (session-only) and `ProceedOnce`
- UI displays this option ONLY in trusted folders (`isTrustedFolder === true`)
- Option appears for all tool types: edit, shell, info, MCP

### R2: Confirmation-Bus Integration

**Behavior:** When user selects `ProceedAlwaysAndSave`, both in-memory and persistent policies are created.

**Acceptance Criteria:**
- `UpdatePolicy` message extended with `persist?: boolean`, `commandPrefix?: string`, `argsPattern?: string`, `mcpName?: string`
- When `persist=true`, write to TOML file
- When `persist=false|undefined`, in-memory only (existing behavior)
- In-memory rule added at priority 2.95 (session-only, below settings excludes at 200)
- Persistent rule written with priority 100 (standard tools) or 200 (MCP tools)

### R3: TOML Persistence Format

**Behavior:** Policies saved to `~/.llxprt/policies/auto-saved.toml` in human-readable format.

**Acceptance Criteria:**
- File location: `Storage.getUserPoliciesDir()` → `~/.llxprt/policies/auto-saved.toml`
- Format: TOML array of `[[rule]]` blocks
- Shell commands: `commandPrefix = "git status"` (exact prefix matching)
- MCP tools: `mcpName = "server"` + `toolName = "simple-name"` (strip `mcpName__` prefix)
- Standard tools: `toolName = "edit"` + `decision = "allow"` + `priority = 100`
- Atomic writes: tmp file + rename pattern
- Append to existing rules (read-modify-write)

### R4: Shell Command Prefix Matching

**Behavior:** Shell command policies match by prefix, not wildcard.

**Acceptance Criteria:**
- User saves policy for `git status` → only commands starting with `"git status"` match
- `git status` matches, `git status --short` matches
- `git push` does NOT match, `git commit` does NOT match
- Implementation: Convert `commandPrefix` to regex `"command":"<escaped-prefix>"` for in-memory rule
- TOML stores `commandPrefix` directly (toml-loader converts on load)

### R5: MCP Tool Granularity

**Behavior:** MCP tool policies match specific server+tool combinations.

**Acceptance Criteria:**
- User saves policy for `jira__search` on server `jira` → only `jira__search` matches
- `jira__create` does NOT match (different tool on same server)
- `confluence__search` does NOT match (different server, same tool name)
- TOML format: `mcpName = "jira"` + `toolName = "search"` (simple name, no `__` prefix)
- Priority 200 (higher than standard tools at 100)

### R6: Security Guardrails

**Behavior:** Persistent policies respect existing security boundaries.

**Acceptance Criteria:**
- "Save to policy" option ONLY shown in trusted folders (`config.isTrustedFolder() === true`)
- Admin policies (priority 300+) ALWAYS override user policies (priority 100-200)
- In-memory rules (priority 2.95) below settings excludes (priority 200)
- Tool-level validation still runs (always-allow skips USER confirmation, not safety validation)
- No telemetry for policy saves (local logging via `coreEvents.emitFeedback` only)

### R7: Error Handling

**Behavior:** Policy persistence failures are non-fatal to user session.

**Acceptance Criteria:**
- If TOML write fails (disk full, permissions), in-memory rule still works for current session
- Error logged via `coreEvents.emitFeedback('error', message, error)`
- Corrupt TOML file overwritten with warning (console.warn)
- Missing file creates new file (no error)
- Concurrent writes: last writer wins (acceptable, low-risk due to append pattern)

### R8: UI Consistency

**Behavior:** New option appears consistently across all confirmation types.

**Acceptance Criteria:**
- Edit confirmations (line ~114): Insert after `ProceedAlways`, before `ModifyWithEditor`
- Shell confirmations (line ~147): Insert after `ProceedAlways`, before `SuggestEdit`
- Info tool confirmations (line ~172): Insert after `ProceedAlways`, before `Cancel`
- MCP confirmations (line ~203): Insert after `ProceedAlwaysServer`, before `Cancel`
- Snapshot tests updated for all 4 types
- Option numbering shifts correctly (e.g., "3. No, suggest changes" becomes "4. No, suggest changes")

### R9: Policy Loading at Startup

**Behavior:** Persisted policies are loaded when LLxprt starts.

**Acceptance Criteria:**
- `createPolicyEngineConfig()` in `config.ts` loads `auto-saved.toml` via `loadPoliciesFromToml()`
- Rules from TOML added to policy engine with priorities from file (100 or 200)
- `commandPrefix` converted to `argsPattern` regex by toml-loader (already implemented)
- Future confirmations for saved tools auto-allow (no prompt shown)
- User never sees confirmation again until policy deleted

### R10: Zero Telemetry

**Behavior:** No data sent to Google servers.

**Acceptance Criteria:**
- No imports of `ClearcutLogger`
- No calls to Google telemetry infrastructure
- `coreEvents.emitFeedback()` is local-only (verified)
- `Storage.getUserPoliciesDir()` returns `~/.llxprt/policies/` (not Google paths)
- Grep audit: `grep -rn "ClearcutLogger" packages/core/src/policy/` → 0 matches (except removal comments)
- Grep audit: `grep -rn "gemini-code-cli" packages/core/src/policy/` → 0 matches

---

## Touchpoints (Files to Modify)

### Core Type Extensions

#### 1. `packages/core/src/tools/tool-confirmation-types.ts`

**Current Code (line ~7-14):**
```typescript
export enum ToolConfirmationOutcome {
  ProceedOnce = 'proceed_once',
  ProceedAlways = 'proceed_always',
  ProceedAlwaysServer = 'proceed_always_server',
  ProceedAlwaysTool = 'proceed_always_tool',
  ModifyWithEditor = 'modify_with_editor',
  SuggestEdit = 'suggest_edit',
  Cancel = 'cancel',
}
```

**Changes Required:**
- Add `ProceedAlwaysAndSave = 'proceed_always_and_save',` after `ProceedAlways` (line 9)

#### 2. `packages/core/src/confirmation-bus/types.ts`

**Current Code (line ~39-42):**
```typescript
export interface UpdatePolicy {
  type: MessageBusType.UPDATE_POLICY;
  toolName: string;
}
```

**Changes Required:**
- Replace with:
```typescript
export interface UpdatePolicy {
  type: MessageBusType.UPDATE_POLICY;
  toolName: string;
  persist?: boolean;           // NEW: When true, save to TOML
  argsPattern?: string;        // NEW: Regex pattern for tool args
  commandPrefix?: string;      // NEW: Shell command prefix (e.g., "git status")
  mcpName?: string;           // NEW: MCP server name
}
```

### Core Policy Engine

#### 3. `packages/core/src/policy/toml-loader.ts`

**Current Code (line ~129):**
```typescript
function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
```

**Changes Required:**
- Change `function` to `export function` (make public for use in config.ts)

#### 4. `packages/core/src/policy/config.ts`

**Location of `createPolicyUpdater()` function: Line ~237-249**

**Current Code:**
```typescript
export function createPolicyUpdater(
  policyEngine: PolicyEngine,
  messageBus: MessageBus,
) {
  messageBus.subscribe(
    MessageBusType.UPDATE_POLICY,
    (message: UpdatePolicy) => {
      const toolName = message.toolName;

      policyEngine.addRule({
        toolName,
        decision: PolicyDecision.ALLOW,
        priority: 2.95,
      });
    },
  );
}
```

**Changes Required:**
- Add imports at top:
  ```typescript
  import * as fs from 'node:fs/promises';
  import toml from '@iarna/toml';
  import { escapeRegex } from './toml-loader.js';
  ```
- Add `TomlRule` interface before function
- Make function `async` and add TOML persistence logic
- See "NEW Tests (RED)" section below for exact implementation requirements

### Tool Integration

#### 5. `packages/core/src/tools/tools.ts`

**Current Code:** `BaseToolInvocation` class has `getConfirmationDetails()` method (line ~112-128)

**Changes Required:**
- Add `PolicyUpdateOptions` interface (after `ToolInvocation` interface, line ~65)
- Add `getPolicyUpdateOptions()` protected method in `BaseToolInvocation` class
- Add `publishPolicyUpdate()` protected helper method
- Modify `getConfirmationDetails()` onConfirm callback to call `publishPolicyUpdate()`

#### 6. `packages/core/src/tools/shell.ts`

**Current Code:** `ShellToolInvocation` class (line ~83+)

**Changes Required:**
- Add import: `import { type PolicyUpdateOptions } from './tools.js';`
- Add `getPolicyUpdateOptions()` override method (returns `{ commandPrefix: this.params.command }`)
- Modify `getConfirmationDetails()` onConfirm callback to call `await this.publishPolicyUpdate(outcome);`

#### 7. `packages/core/src/tools/mcp-tool.ts`

**Current Code:** `DiscoveredMCPToolInvocation` class (line ~88+)

**Changes Required:**
- Add import: `import { type PolicyUpdateOptions } from './tools.js';`
- Add `getPolicyUpdateOptions()` override method (returns `{ mcpName: this.serverName }`)
- Modify `getConfirmationDetails()` onConfirm callback to handle `ProceedAlwaysAndSave` case

#### 8-12. Other Tool Files

**Files:**
- `packages/core/src/tools/edit.ts`
- `packages/core/src/tools/memoryTool.ts`
- `packages/core/src/tools/write-file.ts`
- `packages/core/src/tools/google-web-fetch.ts`
- `packages/core/src/tools/direct-web-fetch.ts`

**Changes Required (all follow same pattern):**
- In `getConfirmationDetails()` method, add `await this.publishPolicyUpdate(outcome);` after existing `ProceedAlways` check

**SKIP:** `packages/core/src/tools/smart-edit.ts` - This file does NOT exist in LLxprt (removed)

### UI Integration

#### 13. `packages/cli/src/ui/components/messages/ToolConfirmationMessage.tsx`

**4 locations to modify:**

**Location 1: Edit confirmations (line ~114)**
```typescript
if (isTrustedFolder) {
  options.push({
    label: 'Yes, allow always',
    value: ToolConfirmationOutcome.ProceedAlways,
    key: 'Yes, allow always',
  });
  // ADD NEW OPTION HERE
}
```

**Location 2: Shell confirmations (line ~147)**
```typescript
if (isTrustedFolder) {
  options.push({
    label: `Yes, allow always ...`,
    value: ToolConfirmationOutcome.ProceedAlways,
    key: `Yes, allow always ...`,
  });
  // ADD NEW OPTION HERE
}
```

**Location 3: Info tool confirmations (line ~172)**
```typescript
if (isTrustedFolder) {
  options.push({
    label: 'Yes, allow always',
    value: ToolConfirmationOutcome.ProceedAlways,
    key: 'Yes, allow always',
  });
  // ADD NEW OPTION HERE
}
```

**Location 4: MCP confirmations (line ~203)**
```typescript
if (isTrustedFolder) {
  options.push({
    label: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
    value: ToolConfirmationOutcome.ProceedAlwaysTool,
    key: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
  });
  options.push({
    label: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
    value: ToolConfirmationOutcome.ProceedAlwaysServer,
    key: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
  });
  // ADD NEW OPTION HERE
}
```

#### 14. `packages/cli/src/zed-integration/zedIntegration.ts`

**Current Code (line ~449):**
```typescript
case ToolConfirmationOutcome.ProceedOnce:
case ToolConfirmationOutcome.ProceedAlways:
case ToolConfirmationOutcome.ProceedAlwaysServer:
case ToolConfirmationOutcome.ProceedAlwaysTool:
case ToolConfirmationOutcome.ModifyWithEditor:
```

**Changes Required:**
- Add `case ToolConfirmationOutcome.ProceedAlwaysAndSave:` after `ProceedAlways`

### Test Files

#### 15. NEW: `packages/core/src/policy/persistence.test.ts`

**New file** - Comprehensive tests for TOML persistence (see "NEW Tests (RED)" section)

#### 16-17. Snapshot Updates

- `packages/cli/src/ui/components/messages/__snapshots__/ToolConfirmationMessage.test.tsx.snap`
- `packages/cli/src/ui/components/messages/__snapshots__/ToolGroupMessage.test.tsx.snap`

**Changes Required:**
- Run `npm run test -w packages/cli -- -u ToolConfirmationMessage.test.tsx`
- Run `npm run test -w packages/cli -- -u ToolGroupMessage.test.tsx`
- Manually review snapshot diffs to verify option numbering

---

## Existing Tests to Adjust

### 1. Confirmation-Bus Tests

**File:** `packages/core/src/confirmation-bus/message-bus.test.ts`

**Test to Update:** `describe('requestConfirmation')` → `describe('ASK_USER policy')`

**Current Test (line ~127-149):**
```typescript
it('resolves when user confirms', async () => {
  // ... setup code ...
  messageBus.respondToConfirmation(
    request.correlationId,
    ToolConfirmationOutcome.ProceedOnce,
  );
  const result = await confirmationPromise;
  expect(result).toBe(true);
});
```

**Action Required:**
- Add new test case:
```typescript
it('resolves when user selects ProceedAlwaysAndSave', async () => {
  const config: PolicyEngineConfig = {
    defaultDecision: PolicyDecision.ASK_USER,
  };
  policyEngine = new PolicyEngine(config);
  messageBus = new MessageBus(policyEngine);

  const handler = vi.fn();
  messageBus.subscribe(MessageBusType.TOOL_CONFIRMATION_REQUEST, handler);

  const toolCall: FunctionCall = { name: 'edit', args: {} };
  const confirmationPromise = messageBus.requestConfirmation(toolCall, {});

  await new Promise((resolve) => setTimeout(resolve, 0));

  const request = handler.mock.calls[0][0] as ToolConfirmationRequest;
  messageBus.respondToConfirmation(
    request.correlationId,
    ToolConfirmationOutcome.ProceedAlwaysAndSave,
  );

  const result = await confirmationPromise;
  expect(result).toBe(true);
});
```

### 2. Policy Engine Tests

**File:** `packages/core/src/policy/policy-engine.test.ts`

**No changes required** - Policy engine already handles dynamic rule addition via `addRule()`. Existing tests cover priority precedence, which is the critical behavior for this feature.

**Verification:**
- Run `npm run test -w packages/core -- policy-engine.test.ts`
- All tests should pass (no changes needed)

### 3. Tool Tests (Shell Example)

**File:** `packages/core/src/tools/shell.test.ts`

**No new tests required for individual tools** - The persistence logic is in `config.ts` and tested via `persistence.test.ts`. Tool tests already verify confirmation flow via `getConfirmationDetails()`.

**Verification:**
- Run `npm run test -w packages/core -- shell.test.ts`
- All tests should pass after adding `publishPolicyUpdate()` call

---

## NEW Tests (RED) - Write These First

### Test Suite: `packages/core/src/policy/persistence.test.ts`

**Purpose:** Test TOML persistence logic in `createPolicyUpdater()` function.

**Test File Structure:**

```typescript
/**
 * @license
 * Copyright 2025 Vybestack LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  describe,
  it,
  expect,
  vi,
  beforeEach,
  afterEach,
  type Mock,
} from 'vitest';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { createPolicyUpdater } from './config.js';
import { PolicyEngine } from './policy-engine.js';
import { MessageBus } from '../confirmation-bus/message-bus.js';
import { MessageBusType } from '../confirmation-bus/types.js';
import { Storage } from '../config/storage.js';

vi.mock('node:fs/promises');
vi.mock('../config/storage.js');

describe('createPolicyUpdater - TOML Persistence', () => {
  let policyEngine: PolicyEngine;
  let messageBus: MessageBus;

  beforeEach(() => {
    policyEngine = new PolicyEngine({ rules: [], checkers: [] });
    messageBus = new MessageBus(policyEngine);
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  describe('R3: TOML Persistence Format', () => {
    it('should persist policy when persist flag is true', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      const toolName = 'test_tool';
      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName,
        persist: true,
      });

      // Wait for async operations
      await new Promise((resolve) => setTimeout(resolve, 10));

      expect(Storage.getUserPoliciesDir).toHaveBeenCalled();
      expect(fs.mkdir).toHaveBeenCalledWith(userPoliciesDir, {
        recursive: true,
      });

      // Check written content
      const expectedContent = expect.stringContaining(`toolName = "test_tool"`);
      expect(fs.writeFile).toHaveBeenCalledWith(
        expect.stringMatching(/\.tmp$/),
        expectedContent,
        'utf-8',
      );
      expect(fs.rename).toHaveBeenCalledWith(
        expect.stringMatching(/\.tmp$/),
        path.join(userPoliciesDir, 'auto-saved.toml'),
      );
    });

    it('should not persist policy when persist flag is false or undefined', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'test_tool',
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      expect(fs.writeFile).not.toHaveBeenCalled();
      expect(fs.rename).not.toHaveBeenCalled();
    });

    it('should use atomic write pattern (tmp + rename)', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'test_tool',
        persist: true,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Verify atomic write: tmp file created first, then renamed
      const writeCall = (fs.writeFile as unknown as Mock).mock.calls[0];
      const renameCall = (fs.rename as unknown as Mock).mock.calls[0];
      
      expect(writeCall[0]).toMatch(/\.tmp$/);
      expect(renameCall[0]).toMatch(/\.tmp$/);
      expect(renameCall[1]).toBe(path.join(userPoliciesDir, 'auto-saved.toml'));
    });
  });

  describe('R4: Shell Command Prefix Matching', () => {
    it('should persist policy with commandPrefix when provided', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      const toolName = 'run_shell_command';
      const commandPrefix = 'git status';

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName,
        persist: true,
        commandPrefix,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Verify in-memory rule has argsPattern (converted from commandPrefix)
      const rules = policyEngine.getRules();
      const addedRule = rules.find((r) => r.toolName === toolName);
      expect(addedRule).toBeDefined();
      expect(addedRule?.priority).toBe(2.95);
      expect(addedRule?.argsPattern).toEqual(new RegExp(`"command":"git status`));

      // Verify TOML file contains commandPrefix (not argsPattern)
      expect(fs.writeFile).toHaveBeenCalledWith(
        expect.stringMatching(/\.tmp$/),
        expect.stringContaining(`commandPrefix = "git status"`),
        'utf-8',
      );
    });

    it('should escape special characters in commandPrefix for regex', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      const commandPrefix = 'echo "hello world" | grep ^test.*';

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'run_shell_command',
        persist: true,
        commandPrefix,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // In-memory rule should have escaped regex (no raw regex special chars)
      const rules = policyEngine.getRules();
      const addedRule = rules.find((r) => r.toolName === 'run_shell_command');
      expect(addedRule?.argsPattern).toBeDefined();
      
      // Verify regex escaping: should match literal string, not regex pattern
      const testArgs = { command: 'echo "hello world" | grep ^test.*' };
      expect(addedRule?.argsPattern?.test(JSON.stringify(testArgs))).toBe(true);
      
      const nonMatchingArgs = { command: 'echo hello world' }; // Missing quotes and grep
      expect(addedRule?.argsPattern?.test(JSON.stringify(nonMatchingArgs))).toBe(false);
    });
  });

  describe('R5: MCP Tool Granularity', () => {
    it('should persist policy with mcpName and extract simple toolName', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      const mcpName = 'my-jira-server';
      const simpleToolName = 'search';
      const toolName = `${mcpName}__${simpleToolName}`;

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName,
        persist: true,
        mcpName,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Verify TOML file written with mcpName and simple toolName
      const writeCall = (fs.writeFile as unknown as Mock).mock.calls[0];
      const writtenContent = writeCall[1] as string;
      expect(writtenContent).toContain(`mcpName = "${mcpName}"`);
      expect(writtenContent).toContain(`toolName = "${simpleToolName}"`);
      expect(writtenContent).toContain('priority = 200');
      expect(writtenContent).toContain('decision = "allow"');
    });

    it('should handle MCP toolNames without __ separator', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      const mcpName = 'my-server';
      const toolName = 'simple-tool'; // No __ separator

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName,
        persist: true,
        mcpName,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Should use toolName as-is (no extraction needed)
      const writeCall = (fs.writeFile as unknown as Mock).mock.calls[0];
      const writtenContent = writeCall[1] as string;
      expect(writtenContent).toContain(`mcpName = "${mcpName}"`);
      expect(writtenContent).toContain(`toolName = "${toolName}"`);
    });
  });

  describe('R7: Error Handling', () => {
    it('should handle TOML write failure gracefully (non-fatal)', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockRejectedValue(
        new Error('Disk full'),
      );

      const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'test_tool',
        persist: true,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // In-memory rule should still be added (fallback behavior)
      const rules = policyEngine.getRules();
      const addedRule = rules.find((r) => r.toolName === 'test_tool');
      expect(addedRule).toBeDefined();
      expect(addedRule?.priority).toBe(2.95);

      // Error should be logged but not thrown
      // Note: coreEvents.emitFeedback logs to console.error in test env
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        expect.stringContaining('Failed to persist policy'),
      );

      consoleErrorSpy.mockRestore();
    });

    it('should overwrite corrupt TOML file with warning', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockResolvedValue(
        'invalid toml syntax {{{',
      ); // Corrupt file
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      const consoleWarnSpy = vi.spyOn(console, 'warn').mockImplementation(() => {});

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'test_tool',
        persist: true,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Should warn about corrupt file
      expect(consoleWarnSpy).toHaveBeenCalledWith(
        expect.stringContaining('Failed to parse'),
        expect.anything(),
      );

      // Should write new valid TOML
      expect(fs.writeFile).toHaveBeenCalledWith(
        expect.stringMatching(/\.tmp$/),
        expect.stringContaining('toolName = "test_tool"'),
        'utf-8',
      );

      consoleWarnSpy.mockRestore();
    });

    it('should create new file when none exists (no error)', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'test_tool',
        persist: true,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Should create directory if missing
      expect(fs.mkdir).toHaveBeenCalledWith(userPoliciesDir, {
        recursive: true,
      });

      // Should write new file
      expect(fs.writeFile).toHaveBeenCalled();
      expect(fs.rename).toHaveBeenCalled();
    });
  });

  describe('R2: In-Memory + Persistent Dual Operation', () => {
    it('should add in-memory rule with priority 2.95', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'edit',
        persist: true,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Verify in-memory rule added
      const rules = policyEngine.getRules();
      const addedRule = rules.find((r) => r.toolName === 'edit');
      expect(addedRule).toBeDefined();
      expect(addedRule?.priority).toBe(2.95);
      expect(addedRule?.decision).toBe('allow');
    });

    it('should write persistent rule with priority 100 for standard tools', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'edit',
        persist: true,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Verify TOML file has priority 100
      const writeCall = (fs.writeFile as unknown as Mock).mock.calls[0];
      const writtenContent = writeCall[1] as string;
      expect(writtenContent).toContain('priority = 100');
    });

    it('should write persistent rule with priority 200 for MCP tools', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'jira__search',
        persist: true,
        mcpName: 'jira',
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Verify TOML file has priority 200 (higher than standard tools)
      const writeCall = (fs.writeFile as unknown as Mock).mock.calls[0];
      const writtenContent = writeCall[1] as string;
      expect(writtenContent).toContain('priority = 200');
    });
  });

  describe('R3: TOML Append Behavior', () => {
    it('should append new rule to existing rules (not overwrite)', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      
      // Existing file with one rule
      const existingToml = `
[[rule]]
toolName = "edit"
decision = "allow"
priority = 100
`;
      (fs.readFile as unknown as Mock).mockResolvedValue(existingToml);
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'run_shell_command',
        persist: true,
        commandPrefix: 'git status',
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Verify new file contains BOTH rules
      const writeCall = (fs.writeFile as unknown as Mock).mock.calls[0];
      const writtenContent = writeCall[1] as string;
      expect(writtenContent).toContain('toolName = "edit"');
      expect(writtenContent).toContain('toolName = "run_shell_command"');
      expect(writtenContent).toContain('commandPrefix = "git status"');
    });
  });

  describe('R10: Zero Telemetry', () => {
    it('should only log errors locally (no telemetry)', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/mock/user/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockRejectedValue(
        new Error('Permission denied'),
      );

      const consoleErrorSpy = vi.spyOn(console, 'error').mockImplementation(() => {});

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'test_tool',
        persist: true,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Should log error locally (console.error via coreEvents.emitFeedback)
      expect(consoleErrorSpy).toHaveBeenCalledWith(
        expect.stringContaining('Failed to persist policy'),
      );

      // Should NOT call any telemetry functions (we can't test negative easily,
      // but the implementation must not import ClearcutLogger)

      consoleErrorSpy.mockRestore();
    });

    it('should use ~/.llxprt/policies/ path (not Google paths)', async () => {
      createPolicyUpdater(policyEngine, messageBus);

      const userPoliciesDir = '/home/user/.llxprt/policies';
      vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
      (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
      (fs.readFile as unknown as Mock).mockRejectedValue(
        Object.assign(new Error('File not found'), { code: 'ENOENT' }),
      );
      (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
      (fs.rename as unknown as Mock).mockResolvedValue(undefined);

      await messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: 'test_tool',
        persist: true,
      });

      await new Promise((resolve) => setTimeout(resolve, 10));

      // Verify correct path used
      expect(fs.rename).toHaveBeenCalledWith(
        expect.stringMatching(/\.tmp$/),
        '/home/user/.llxprt/policies/auto-saved.toml',
      );

      // Path should NOT contain Google strings
      const renameCall = (fs.rename as unknown as Mock).mock.calls[0];
      expect(renameCall[1]).not.toContain('gemini-code-cli');
      expect(renameCall[1]).not.toContain('google');
    });
  });
});
```

**Test Coverage Summary:**
- [OK] R3: TOML format, atomic writes, append behavior
- [OK] R4: Command prefix matching, regex escaping
- [OK] R5: MCP tool granularity, simple tool name extraction
- [OK] R7: Error handling (disk full, corrupt TOML, missing file)
- [OK] R2: In-memory + persistent dual operation, priority values
- [OK] R10: Zero telemetry, correct storage path

**Expected Test Results (RED):**
- All tests FAIL initially (implementation doesn't exist yet)
- Mocks set up correctly, tests express desired behavior
- Ready for GREEN phase (implement minimal code to pass)

---

## Implementation (GREEN) - Make Tests Pass

### Phase 1: Core Type Extensions

#### Step 1.1: Add `ProceedAlwaysAndSave` enum value

**File:** `packages/core/src/tools/tool-confirmation-types.ts`

**Change:**
```typescript
export enum ToolConfirmationOutcome {
  ProceedOnce = 'proceed_once',
  ProceedAlways = 'proceed_always',
  ProceedAlwaysAndSave = 'proceed_always_and_save',  // ADD THIS LINE
  ProceedAlwaysServer = 'proceed_always_server',
  ProceedAlwaysTool = 'proceed_always_tool',
  ModifyWithEditor = 'modify_with_editor',
  SuggestEdit = 'suggest_edit',
  Cancel = 'cancel',
}
```

**Verification:**
```bash
npm run typecheck -w packages/core
```

#### Step 1.2: Extend `UpdatePolicy` interface

**File:** `packages/core/src/confirmation-bus/types.ts`

**Change:**
```typescript
export interface UpdatePolicy {
  type: MessageBusType.UPDATE_POLICY;
  toolName: string;
  persist?: boolean;           // NEW: When true, save to TOML
  argsPattern?: string;        // NEW: Regex pattern for tool args
  commandPrefix?: string;      // NEW: Shell command prefix (e.g., "git status")
  mcpName?: string;           // NEW: MCP server name
}
```

**Verification:**
```bash
npm run typecheck -w packages/core
```

### Phase 2: Core Policy Engine

#### Step 2.1: Export `escapeRegex` helper

**File:** `packages/core/src/policy/toml-loader.ts`

**Change:**
```typescript
// Find function at line ~129
export function escapeRegex(str: string): string {
  return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
}
```

**Verification:**
```bash
npm run test -w packages/core -- toml-loader.test.ts
```

#### Step 2.2: Implement TOML persistence in `createPolicyUpdater`

**File:** `packages/core/src/policy/config.ts`

**Add imports at top:**
```typescript
import * as fs from 'node:fs/promises';
import toml from '@iarna/toml';
import { escapeRegex } from './toml-loader.js';
```

**Add interface before `createPolicyUpdater` function:**
```typescript
interface TomlRule {
  toolName?: string;
  mcpName?: string;
  decision?: string;
  priority?: number;
  commandPrefix?: string;
  argsPattern?: string;
  [key: string]: unknown;
}
```

**Replace `createPolicyUpdater` function (currently line ~237-249):**
```typescript
export function createPolicyUpdater(
  policyEngine: PolicyEngine,
  messageBus: MessageBus,
) {
  messageBus.subscribe(
    MessageBusType.UPDATE_POLICY,
    async (message: UpdatePolicy) => {
      const toolName = message.toolName;
      let argsPattern = message.argsPattern
        ? new RegExp(message.argsPattern)
        : undefined;

      // Convert commandPrefix to argsPattern for in-memory rule
      if (message.commandPrefix) {
        const escapedPrefix = escapeRegex(message.commandPrefix);
        argsPattern = new RegExp(`"command":"${escapedPrefix}`);
      }

      // Add in-memory rule (works for current session)
      policyEngine.addRule({
        toolName,
        decision: PolicyDecision.ALLOW,
        priority: 2.95,
        argsPattern,
      });

      // PERSISTENCE LOGIC - Save to TOML if persist=true
      if (message.persist) {
        try {
          const userPoliciesDir = Storage.getUserPoliciesDir();
          await fs.mkdir(userPoliciesDir, { recursive: true });
          const policyFile = path.join(userPoliciesDir, 'auto-saved.toml');

          // Read existing file (if any)
          let existingData: { rule?: TomlRule[] } = {};
          try {
            const fileContent = await fs.readFile(policyFile, 'utf-8');
            existingData = toml.parse(fileContent) as { rule?: TomlRule[] };
          } catch (error) {
            if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
              console.warn(
                `Failed to parse ${policyFile}, overwriting with new policy.`,
                error,
              );
            }
          }

          // Initialize rule array if needed
          if (!existingData.rule) {
            existingData.rule = [];
          }

          // Build new rule
          const newRule: TomlRule = {};

          if (message.mcpName) {
            // MCP tool policy
            newRule.mcpName = message.mcpName;
            // Extract simple tool name (remove "mcpName__" prefix)
            const simpleToolName = toolName.startsWith(`${message.mcpName}__`)
              ? toolName.slice(message.mcpName.length + 2)
              : toolName;
            newRule.toolName = simpleToolName;
            newRule.decision = 'allow';
            newRule.priority = 200;
          } else {
            // Standard tool policy
            newRule.toolName = toolName;
            newRule.decision = 'allow';
            newRule.priority = 100;
          }

          if (message.commandPrefix) {
            newRule.commandPrefix = message.commandPrefix;
          } else if (message.argsPattern) {
            newRule.argsPattern = message.argsPattern;
          }

          // Append to existing rules
          existingData.rule.push(newRule);

          // Serialize to TOML
          const newContent = toml.stringify(existingData as toml.JsonMap);

          // Atomic write: tmp file + rename
          const tmpFile = `${policyFile}.tmp`;
          await fs.writeFile(tmpFile, newContent, 'utf-8');
          await fs.rename(tmpFile, policyFile);
        } catch (error) {
          coreEvents.emitFeedback(
            'error',
            `Failed to persist policy for ${toolName}`,
            error,
          );
        }
      }
    },
  );
}
```

**Verification:**
```bash
npm run test -w packages/core -- persistence.test.ts
# All tests in RED phase should now PASS
```

### Phase 3: Tool Integration

#### Step 3.1: Add base class helpers in `tools.ts`

**File:** `packages/core/src/tools/tools.ts`

**Add interface after `ToolInvocation` interface (line ~65):**
```typescript
/**
 * Options for policy updates that can be customized by tool invocations.
 */
export interface PolicyUpdateOptions {
  commandPrefix?: string;
  mcpName?: string;
}
```

**Add methods in `BaseToolInvocation` class (after `shouldConfirmExecute` method, line ~110+):**
```typescript
/**
 * Returns tool-specific options for policy updates.
 * Subclasses can override this to provide additional options like
 * commandPrefix (for shell) or mcpName (for MCP tools).
 */
protected getPolicyUpdateOptions(
  _outcome: ToolConfirmationOutcome,
): PolicyUpdateOptions | undefined {
  return undefined;
}

/**
 * Helper method to publish a policy update when user selects
 * ProceedAlways or ProceedAlwaysAndSave.
 */
protected async publishPolicyUpdate(
  outcome: ToolConfirmationOutcome,
): Promise<void> {
  if (
    outcome === ToolConfirmationOutcome.ProceedAlways ||
    outcome === ToolConfirmationOutcome.ProceedAlwaysAndSave
  ) {
    if (this.messageBus && this._toolName) {
      const options = this.getPolicyUpdateOptions(outcome);
      await this.messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: this._toolName,
        persist: outcome === ToolConfirmationOutcome.ProceedAlwaysAndSave,
        ...options,
      });
    }
  }
}
```

**Modify `getConfirmationDetails()` method (line ~112-128):**
```typescript
protected async getConfirmationDetails(
  _abortSignal: AbortSignal,
): Promise<ToolCallConfirmationDetails | false> {
  const confirmationDetails: ToolCallConfirmationDetails = {
    type: 'info',
    title: `Confirm: ${this._toolDisplayName || this._toolName}`,
    prompt: this.getDescription(),
    onConfirm: async (outcome: ToolConfirmationOutcome) => {
      await this.publishPolicyUpdate(outcome);  // CHANGE THIS LINE
    },
  };
  return confirmationDetails;
}
```

**Verification:**
```bash
npm run test -w packages/core -- tools.test.ts
npm run typecheck -w packages/core
```

#### Step 3.2: Add shell command prefix support

**File:** `packages/core/src/tools/shell.ts`

**Add import at top:**
```typescript
import { type PolicyUpdateOptions } from './tools.js';
```

**Add method in `ShellToolInvocation` class (after `getDescription()` method, line ~85+):**
```typescript
protected override getPolicyUpdateOptions(
  outcome: ToolConfirmationOutcome,
): PolicyUpdateOptions | undefined {
  if (outcome === ToolConfirmationOutcome.ProceedAlwaysAndSave) {
    return { commandPrefix: this.params.command };
  }
  return undefined;
}
```

**Modify `getConfirmationDetails()` onConfirm callback (line ~124+):**

Find the existing onConfirm callback and ADD the publishPolicyUpdate call:

```typescript
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    commandsToConfirm.forEach((command) => this.allowlist.add(command));
  }
  await this.publishPolicyUpdate(outcome);  // ADD THIS LINE
},
```

**Verification:**
```bash
npm run test -w packages/core -- shell.test.ts
```

#### Step 3.3: Add MCP tool support

**File:** `packages/core/src/tools/mcp-tool.ts`

**Add import at top:**
```typescript
import { type PolicyUpdateOptions } from './tools.js';
```

**Add method in `DiscoveredMCPToolInvocation` class (after `getConfirmationDetails()` method):**
```typescript
protected override getPolicyUpdateOptions(
  _outcome: ToolConfirmationOutcome,
): PolicyUpdateOptions | undefined {
  return { mcpName: this.serverName };
}
```

**Modify `getConfirmationDetails()` onConfirm callback (line ~115+):**

Find the existing onConfirm callback and ADD the new case:

```typescript
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlwaysServer) {
    DiscoveredMCPToolInvocation.allowlist.add(serverAllowListKey);
  } else if (outcome === ToolConfirmationOutcome.ProceedAlwaysTool) {
    DiscoveredMCPToolInvocation.allowlist.add(toolAllowListKey);
  }
  // ADD THIS BLOCK:
  else if (outcome === ToolConfirmationOutcome.ProceedAlwaysAndSave) {
    DiscoveredMCPToolInvocation.allowlist.add(toolAllowListKey);
    await this.publishPolicyUpdate(outcome);
  }
},
```

**Verification:**
```bash
npm run test -w packages/core -- mcp-tool.test.ts
```

#### Step 3.4: Add `publishPolicyUpdate` calls to other tools

**Pattern:** Find `getConfirmationDetails()` onConfirm callback, add `await this.publishPolicyUpdate(outcome);` after existing `ProceedAlways` check.

**File: `packages/core/src/tools/edit.ts`**

```typescript
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    this.config.setApprovalMode(ApprovalMode.AUTO_EDIT);
  }
  await this.publishPolicyUpdate(outcome);  // ADD THIS LINE
  
  // ... rest of ideConfirmation handling ...
},
```

**File: `packages/core/src/tools/memoryTool.ts`**

```typescript
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    MemoryToolInvocation.allowlist.add(allowlistKey);
  }
  await this.publishPolicyUpdate(outcome);  // ADD THIS LINE
},
```

**File: `packages/core/src/tools/write-file.ts`**

```typescript
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    this.config.setApprovalMode(ApprovalMode.AUTO_EDIT);
  }
  await this.publishPolicyUpdate(outcome);  // ADD THIS LINE
  
  // ... ideConfirmation handling ...
},
```

**File: `packages/core/src/tools/google-web-fetch.ts`**

```typescript
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    this.config.setApprovalMode(ApprovalMode.AUTO_EDIT);
  }
  await this.publishPolicyUpdate(outcome);  // ADD THIS LINE
},
```

**File: `packages/core/src/tools/direct-web-fetch.ts`**

Check if this file has `getConfirmationDetails()`. If it does, add the same pattern. If it relies on base class, no changes needed.

**Verification:**
```bash
npm run test -w packages/core
# All tool tests should pass
```

### Phase 4: UI Integration

#### Step 4.1: Add "save to policy" option in confirmation UI

**File:** `packages/cli/src/ui/components/messages/ToolConfirmationMessage.tsx`

**Add the new option in 4 locations:**

**Location 1: Edit confirmations (after line ~114)**
```typescript
if (isTrustedFolder) {
  options.push({
    label: 'Yes, allow always',
    value: ToolConfirmationOutcome.ProceedAlways,
    key: 'Yes, allow always',
  });
  // ADD THIS:
  options.push({
    label: 'Yes, allow always and save to policy',
    value: ToolConfirmationOutcome.ProceedAlwaysAndSave,
    key: 'Yes, allow always and save to policy',
  });
}
```

**Location 2: Shell confirmations (after line ~147)**
```typescript
if (isTrustedFolder) {
  options.push({
    label: `Yes, allow always ...`,
    value: ToolConfirmationOutcome.ProceedAlways,
    key: `Yes, allow always ...`,
  });
  // ADD THIS:
  options.push({
    label: `Yes, allow always and save to policy`,
    value: ToolConfirmationOutcome.ProceedAlwaysAndSave,
    key: `Yes, allow always and save to policy`,
  });
}
```

**Location 3: Info tool confirmations (after line ~172)**
```typescript
if (isTrustedFolder) {
  options.push({
    label: 'Yes, allow always',
    value: ToolConfirmationOutcome.ProceedAlways,
    key: 'Yes, allow always',
  });
  // ADD THIS:
  options.push({
    label: 'Yes, allow always and save to policy',
    value: ToolConfirmationOutcome.ProceedAlwaysAndSave,
    key: 'Yes, allow always and save to policy',
  });
}
```

**Location 4: MCP confirmations (after line ~203)**
```typescript
if (isTrustedFolder) {
  options.push({
    label: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
    value: ToolConfirmationOutcome.ProceedAlwaysTool,
    key: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
  });
  options.push({
    label: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
    value: ToolConfirmationOutcome.ProceedAlwaysServer,
    key: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
  });
  // ADD THIS:
  options.push({
    label: `Yes, allow always tool "${mcpProps.toolName}" and save to policy`,
    value: ToolConfirmationOutcome.ProceedAlwaysAndSave,
    key: `Yes, allow always tool "${mcpProps.toolName}" and save to policy`,
  });
}
```

**Verification:**
```bash
npm run test -w packages/cli -- ToolConfirmationMessage.test.tsx
# Tests will FAIL (snapshots out of date)
```

**Update snapshots:**
```bash
npm run test -w packages/cli -- -u ToolConfirmationMessage.test.tsx
npm run test -w packages/cli -- -u ToolGroupMessage.test.tsx
```

**Manual review:**
- Inspect snapshot diffs in git diff
- Verify "save to policy" option appears in all 4 confirmation types
- Verify option numbering shifted correctly (e.g., "3." became "4.")
- Verify option ONLY appears in trusted folder scenarios

#### Step 4.2: Handle new outcome in Zed integration

**File:** `packages/cli/src/zed-integration/zedIntegration.ts`

**Find switch statement (line ~449):**
```typescript
case ToolConfirmationOutcome.ProceedOnce:
case ToolConfirmationOutcome.ProceedAlways:
case ToolConfirmationOutcome.ProceedAlwaysAndSave:  // ADD THIS LINE
case ToolConfirmationOutcome.ProceedAlwaysServer:
case ToolConfirmationOutcome.ProceedAlwaysTool:
case ToolConfirmationOutcome.ModifyWithEditor:
```

**Verification:**
```bash
npm run typecheck -w packages/cli
```

### Phase 5: Comprehensive Testing

#### Step 5.1: Run all tests

```bash
# Run all tests
npm run test

# Run specific test suites
npm run test -w packages/core -- persistence.test.ts
npm run test -w packages/core -- config.test.ts
npm run test -w packages/core -- message-bus.test.ts
npm run test -w packages/cli -- ToolConfirmationMessage.test.tsx
```

**Expected Results:**
- [OK] All tests pass
- [OK] Snapshots updated correctly
- [OK] No type errors

#### Step 5.2: Manual integration tests

**Test 1: Shell command persistence**
```bash
cd ~/trusted-project
llxprt trust

# Start session, trigger shell command
# User interaction: "run git status" → Select "Yes, allow always and save to policy"

# Verify TOML file created
cat ~/.llxprt/policies/auto-saved.toml
# Expected output:
# [[rule]]
# toolName = "run_shell_command"
# commandPrefix = "git status"
# decision = "allow"
# priority = 100

# Exit and restart
exit
llxprt

# Trigger same command → should auto-execute (no confirmation)
# Trigger different command (git push) → should ask for confirmation
```

**Test 2: MCP tool persistence**
```bash
# Configure MCP server (e.g., filesystem server)
# Trigger MCP tool → Select "save to policy"

cat ~/.llxprt/policies/auto-saved.toml
# Expected output:
# [[rule]]
# mcpName = "filesystem"
# toolName = "read_file"
# decision = "allow"
# priority = 200

# Restart → same MCP tool should auto-allow
# Different MCP tool from same server → should ask
```

**Test 3: Multiple policies accumulate**
```bash
# Save 3 policies: git status, edit tool, MCP tool

cat ~/.llxprt/policies/auto-saved.toml
# Expected: 3 [[rule]] blocks

# Restart → all 3 should work
```

**Test 4: Untrusted folder restriction**
```bash
cd ~/untrusted-project
# Do NOT run llxprt trust

# Trigger any tool
# Expected: "save to policy" option NOT shown
# Only see: "Yes, allow once" and "Yes, allow always" (session-only)
```

**Test 5: Corrupt TOML recovery**
```bash
echo "invalid toml {{{" > ~/.llxprt/policies/auto-saved.toml

# Start llxprt, trigger tool, save policy
# Expected: Warning in console, file overwritten with valid TOML
```

#### Step 5.3: Security audit

**Checklist:**
```bash
# Verify no Google telemetry
grep -rn "ClearcutLogger" packages/core/src/policy/
# Expected: 0 matches (except in removal comments)

# Verify no Google paths
grep -rn "gemini-code-cli" packages/core/src/policy/
# Expected: 0 matches

# Verify correct storage path
grep -A5 "getUserPoliciesDir" packages/core/src/config/storage.ts
# Expected: ~/.llxprt/policies/

# Run all tests
npm run test
# Expected: All pass

# Run type check
npm run typecheck
# Expected: No errors
```

**Manual security checks:**
- [ ] Inspect `~/.llxprt/policies/auto-saved.toml` format
- [ ] Verify no network requests during policy save (use network monitor)
- [ ] Test atomic write behavior (kill process during save, verify file intact)
- [ ] Test with read-only filesystem (verify graceful error)
- [ ] Verify trusted folder check works (no "save" option in untrusted folders)

---

## Refactor (Optional)

**Assessment:** Review if refactoring adds value. Key areas:

1. **TOML persistence logic** - Currently inline in `createPolicyUpdater()`. Could extract to separate module if additional persistence features planned.
   - **Decision:** SKIP - Inline is clear, single use case, no duplication
   
2. **Policy priority constants** - Magic numbers (2.95, 100, 200) could be extracted as named constants
   - **Decision:** CONSIDER - Would improve readability
   - **Recommendation:** Extract to `packages/core/src/policy/types.ts`:
     ```typescript
     export const PolicyPriority = {
       ADMIN: 300,
       SETTINGS_EXCLUDES: 200,
       PERSISTENT_MCP: 200,
       PERSISTENT_STANDARD: 100,
       SESSION_ONLY: 2.95,
     } as const;
     ```

3. **Error handling** - Consistent pattern across persistence logic
   - **Decision:** SKIP - Already consistent with coreEvents.emitFeedback()

**Refactoring Steps (If Pursued):**
1. Extract priority constants to `types.ts`
2. Update all usages in `config.ts`, `policy-engine.ts`, documentation
3. Run full test suite to verify behavior unchanged
4. Commit separately: "refactor: extract policy priority constants"

---

## Verification Steps

### Pre-Commit Checklist

- [ ] All tests pass: `npm run test`
- [ ] No type errors: `npm run typecheck`
- [ ] No linting errors: `npm run lint`
- [ ] Snapshots reviewed and committed
- [ ] Manual integration tests passed (shell, MCP, untrusted folder)
- [ ] Security audit passed (no telemetry, correct paths)
- [ ] TOML file format verified (valid TOML, correct priorities)
- [ ] Documentation updated (README, CHANGELOG)

### Smoke Tests

**Test 1: Feature works end-to-end**
```bash
cd ~/trusted-project
llxprt trust
# Trigger tool → Select "save to policy" → Verify TOML created → Restart → Verify auto-allow
```

**Test 2: No regressions**
```bash
# Trigger tool → Select "allow always" (session-only) → Verify session-only behavior
# Trigger tool → Select "allow once" → Verify single-use behavior
# Trigger tool → Select "cancel" → Verify rejection
```

**Test 3: Admin override works**
```bash
# Create admin policy blocking tool
sudo mkdir -p /etc/llxprt-code/policies
echo '[[rule]]
toolName = "run_shell_command"
decision = "deny"
priority = 300' | sudo tee /etc/llxprt-code/policies/admin.toml

# Attempt to save user policy for same tool
# Expected: Admin policy wins, tool still denied
```

---

## Commit Message

```
feat(policy): add persistent always-allow policies with granular shell & MCP support

Implements upstream commit 5f298c17 with LLxprt adaptations.

New Features:
- "Yes, allow always and save to policy" option in confirmation UI
- Granular shell command policies via prefix matching (e.g., "git status" ≠ "git push")
- MCP tool policies saved per server+tool combination
- Auto-save to ~/.llxprt/policies/auto-saved.toml with atomic writes
- Policies survive session restarts (loaded at startup)

Security:
- Only shown in trusted folders (llxprt trust required)
- Admin policies (priority 300+) always override user policies (100-200)
- In-memory session rules (priority 2.95) below settings excludes (200)
- ZERO Google telemetry (local TOML only)

Technical Details:
- New ToolConfirmationOutcome: ProceedAlwaysAndSave
- UpdatePolicy message extended with persist, commandPrefix, argsPattern, mcpName
- Dual operation: in-memory rules (priority 2.95) + persistent rules (100/200)
- TOML append pattern (read-modify-write to accumulate rules)
- Atomic writes (tmp + rename) to prevent corruption

Testing:
- 209-line persistence.test.ts with full coverage
- Updated snapshots for ToolConfirmationMessage.tsx
- Manual integration tests passed (shell, MCP, untrusted folder, corrupt TOML)
- Security audit passed (no telemetry, correct storage path)

Files Changed:
- Core: config.ts, types.ts, tools.ts, shell.ts, mcp-tool.ts, edit.ts, etc.
- UI: ToolConfirmationMessage.tsx, zedIntegration.ts
- Tests: persistence.test.ts (NEW), snapshot updates

Closes #XXX
```

---

## Risk Assessment & Mitigation

### HIGH RISK: TOML Persistence Logic

**Risks:**
- File I/O errors (disk full, permissions, corrupt TOML)
- Race conditions (concurrent sessions)
- Data loss (atomic write failure)
- Path injection vulnerabilities

**Mitigations:**
- [OK] Comprehensive error handling with try/catch
- [OK] Atomic write pattern (tmp + rename)
- [OK] Read-modify-write to append (reduces data loss window)
- [OK] Non-fatal errors (session continues, error logged)
- [OK] Use Storage.getUserPoliciesDir() (trusted path)
- [OK] Test coverage: 20+ tests for error paths

**Residual Risk:** LOW (acceptable for feature value)

### HIGH RISK: Security/Privacy

**Risks:**
- Accidentally reintroduce Google telemetry
- Use wrong storage path (Google paths)
- Log sensitive data (command args)
- Over-permissive policies (security bypass)

**Mitigations:**
- [OK] Grep audit for banned patterns (ClearcutLogger, gemini-code-cli)
- [OK] Verify Storage.getUserPoliciesDir() → ~/.llxprt/
- [OK] Trusted folder requirement (no saves in untrusted dirs)
- [OK] Admin policy override (priority 300+ always wins)
- [OK] Granular command prefixes (not wildcards)
- [OK] Security audit checklist completed

**Residual Risk:** VERY LOW (multiple safeguards)

### MEDIUM RISK: Policy Priority System

**Risks:**
- User policies override admin policies (security bypass)
- Settings excludes broken (wrong priority)
- In-memory vs persistent priority conflict

**Mitigations:**
- [OK] In-memory: priority 2.95 (below settings excludes at 200)
- [OK] Persistent: priority 100/200 (below admin at 300+)
- [OK] Existing policy engine handles priority correctly
- [OK] Tests verify admin override behavior

**Residual Risk:** LOW (existing engine tested)

### MEDIUM RISK: Tool Integration

**Risks:**
- Missing publishPolicyUpdate() call in a tool
- Wrong getPolicyUpdateOptions() implementation
- Breaking existing tool behavior

**Mitigations:**
- [OK] Systematic review of 8 tool files
- [OK] Grep for existing ProceedAlways checks (injection points)
- [OK] Existing tests ensure tool behavior unchanged
- [OK] Pattern documented for consistency

**Residual Risk:** LOW (consistent pattern)

---

## Documentation Updates

### README.md

Add section:

```markdown
## Persistent Always-Allow Policies

LLxprt Code can save your "always allow" confirmations to disk, so they persist across sessions.

### How it works

When confirming a tool execution (in a trusted folder), you'll see:
- "Yes, allow once" - Allow this one time only
- "Yes, allow always" - Allow for this session (resets on restart)
- **"Yes, allow always and save to policy"** - Allow forever (persists to file)

Saved policies are stored in: `~/.llxprt/policies/auto-saved.toml`

### Policy Granularity

- **Shell commands:** Saved by command prefix. "git status" won't allow "git push".
- **MCP tools:** Saved per server+tool combo. Allowing "jira__search" won't allow "jira__create".
- **Other tools:** Saved by tool name.

### Managing Policies

**View saved policies:**
```bash
cat ~/.llxprt/policies/auto-saved.toml
```

**Example content:**
```toml
[[rule]]
toolName = "run_shell_command"
commandPrefix = "git status"
decision = "allow"
priority = 100

[[rule]]
mcpName = "filesystem"
toolName = "read_file"
decision = "allow"
priority = 200
```

**Remove a policy:**
Edit the file and delete the corresponding `[[rule]]` block.

### Policy Priority

User-saved policies (priority 100-200) are overridden by:
- Admin policies (system-wide, priority 300+)
- Settings excludes (priority 200+)

This ensures system administrators can block dangerous operations even if users saved an "always allow" policy.

### Security Notes

- "Save to policy" option only appears in **trusted folders** (`llxprt trust`)
- Use granular policies (command prefixes) to avoid over-permissive rules
- Review saved policies regularly: `cat ~/.llxprt/policies/auto-saved.toml`
- Never commit `auto-saved.toml` to version control (it's in `.gitignore`)
```

### CHANGELOG.md

```markdown
## [Unreleased]

### Added
- **Persistent "Always Allow" policies** - User confirmations can now be saved to `~/.llxprt/policies/auto-saved.toml` for cross-session persistence
  - New confirmation option: "Yes, allow always and save to policy"
  - Granular shell command policies via command prefixes (e.g., "git status" won't allow "git push")
  - MCP tool policies saved per server+tool combination
  - Policies survive session restarts and are loaded at startup
  - Only available in trusted folders (security requirement)
  - Admin policies always override user-saved policies
  - Based on upstream commit 5f298c17 with LLxprt adaptations (no Google telemetry)
```

---

## Implementation Timeline

### Day 1: Core Types & Persistence (6-8 hours)

**Morning (3-4 hours):**
- [ ] Create `persistence.test.ts` file (write all RED tests)
- [ ] Verify tests fail as expected
- [ ] Step 1.1: Add `ProceedAlwaysAndSave` enum (15 min)
- [ ] Step 1.2: Extend `UpdatePolicy` type (15 min)
- [ ] Step 2.1: Export `escapeRegex` (5 min)
- [ ] Run typecheck: `npm run typecheck` (5 min)

**Afternoon (3-4 hours):**
- [ ] Step 2.2: Implement TOML persistence in `config.ts` (3-4 hours)
  - Add imports
  - Add TomlRule interface
  - Implement createPolicyUpdater function
- [ ] Run tests: `npm run test -w packages/core -- persistence.test.ts` (30 min)
- [ ] Fix any failures (iterate GREEN phase)
- [ ] **SECURITY AUDIT CHECKPOINT** (1 hour)
  - Grep for ClearcutLogger, Google paths
  - Verify atomic writes, error handling
  - Code review of persistence logic

**End of Day 1:**
- [OK] All persistence tests passing
- [OK] No type errors
- [OK] Security audit passed

### Day 2: Tool Integration (6-8 hours)

**Morning (3-4 hours):**
- [ ] Step 3.1: Base class helpers in `tools.ts` (1 hour)
  - Add PolicyUpdateOptions interface
  - Add getPolicyUpdateOptions() method
  - Add publishPolicyUpdate() helper
  - Modify getConfirmationDetails() onConfirm
- [ ] Run tests: `npm run test -w packages/core -- tools.test.ts` (30 min)
- [ ] Step 3.2: Shell command support (1 hour)
  - Add import
  - Add getPolicyUpdateOptions() override
  - Modify onConfirm callback
- [ ] Run tests: `npm run test -w packages/core -- shell.test.ts` (30 min)

**Afternoon (3-4 hours):**
- [ ] Step 3.3: MCP tool support (1 hour)
- [ ] Run tests: `npm run test -w packages/core -- mcp-tool.test.ts` (30 min)
- [ ] Step 3.4: Other tools (2-3 hours)
  - edit.ts
  - memoryTool.ts
  - write-file.ts
  - google-web-fetch.ts
  - direct-web-fetch.ts
- [ ] Run all core tests: `npm run test -w packages/core` (1 hour)
- [ ] Fix any failures

**End of Day 2:**
- [OK] All tool integration complete
- [OK] All core tests passing
- [OK] Tools still work (no regressions)

### Day 3: UI & Testing (8 hours)

**Morning (4 hours):**
- [ ] Step 4.1: UI changes in `ToolConfirmationMessage.tsx` (2 hours)
  - Add new option in 4 locations
  - Verify isTrustedFolder checks
- [ ] Step 4.2: Zed integration (15 min)
- [ ] Update snapshots: `npm run test -w packages/cli -- -u` (30 min)
- [ ] Manually review snapshot diffs (30 min)
- [ ] Run all CLI tests: `npm run test -w packages/cli` (30 min)

**Afternoon (4 hours):**
- [ ] Update confirmation-bus tests (add ProceedAlwaysAndSave case) (30 min)
- [ ] Run all tests: `npm run test` (30 min)
- [ ] Fix any failures (1 hour buffer)
- [ ] Manual smoke test: Shell command persistence (30 min)
- [ ] Manual smoke test: MCP tool persistence (30 min)
- [ ] Manual smoke test: Untrusted folder restriction (15 min)

**End of Day 3:**
- [OK] All tests passing
- [OK] Snapshots updated and reviewed
- [OK] UI consistent across all confirmation types
- [OK] Basic integration tests passed

### Day 4: Integration Testing & Security Audit (8 hours)

**Morning (4 hours):**
- [ ] Manual Test 1: Shell command persistence (1 hour)
  - Save policy, verify TOML, restart, verify auto-allow
- [ ] Manual Test 2: MCP tool persistence (1 hour)
- [ ] Manual Test 3: Multiple policies accumulate (30 min)
- [ ] Manual Test 4: Untrusted folder restriction (30 min)
- [ ] Manual Test 5: Corrupt TOML recovery (30 min)
- [ ] Test atomic writes (kill process during save) (30 min)

**Afternoon (4 hours):**
- [ ] **FINAL SECURITY AUDIT** (2 hours)
  - Grep for banned patterns (ClearcutLogger, gemini-code-cli)
  - Verify Storage.getUserPoliciesDir() paths
  - Test with read-only filesystem
  - Test with concurrent sessions (observe behavior)
  - Verify trusted folder check works
  - Test admin policy override
- [ ] Fix any issues found (1 hour buffer)
- [ ] Run full test suite: `npm run test` (30 min)
- [ ] Run typecheck: `npm run typecheck` (5 min)
- [ ] Run lint: `npm run lint` (5 min)

**End of Day 4:**
- [OK] All manual integration tests passed
- [OK] Security audit passed (checklist complete)
- [OK] No regressions detected
- [OK] Ready for documentation and commit

### Day 5: Documentation & Polish (4 hours)

**Morning (2 hours):**
- [ ] Update README.md (add "Persistent Always-Allow Policies" section)
- [ ] Update CHANGELOG.md
- [ ] Review all code comments (ensure clarity)
- [ ] Final code cleanup (remove debug logs, etc.)

**Afternoon (2 hours):**
- [ ] Final test run: `npm run test` (30 min)
- [ ] Verify no uncommitted changes: `git status`
- [ ] Review all file changes: `git diff`
- [ ] Stage all changes: `git add .`
- [ ] Commit with detailed message (30 min)
- [ ] Final smoke test on committed code (30 min)
- [ ] Create PR (if needed) (30 min)

**End of Day 5:**
- [OK] All documentation updated
- [OK] Code committed with detailed message
- [OK] Feature complete and tested
- [OK] Ready for deployment

---

## Success Criteria

### Functional Requirements

- [x] User can select "Yes, allow always and save to policy" option in trusted folders
- [x] Option appears for all tool types: edit, shell, info, MCP
- [x] Shell command policies match by prefix (granular)
- [x] MCP tool policies match by server+tool combination
- [x] Policies saved to `~/.llxprt/policies/auto-saved.toml`
- [x] Policies persist across session restarts
- [x] Policies loaded at startup and auto-allow matching tools
- [x] Multiple policies accumulate in same file (append behavior)
- [x] Corrupt TOML files recovered gracefully

### Security Requirements

- [x] "Save to policy" option ONLY shown in trusted folders
- [x] Admin policies (300+) override user policies (100-200)
- [x] ZERO Google telemetry (no ClearcutLogger imports)
- [x] Correct storage path (`~/.llxprt/policies/` not Google paths)
- [x] Tool-level validation still runs (safety checks not bypassed)

### Quality Requirements

- [x] All tests passing (100% behavior coverage)
- [x] No type errors (npm run typecheck)
- [x] No linting errors (npm run lint)
- [x] Snapshots updated and reviewed
- [x] Manual integration tests passed
- [x] Documentation updated (README, CHANGELOG)
- [x] Commit message detailed and accurate

---

## Appendix: Upstream Diff Summary

**Commit:** 5f298c17d7f6c3a1eabbeac249904cd1cf141352  
**Stats:** 18 files changed, +431/-21 lines

**Key Changes:**
1. **UI Layer** - Add "save to policy" option in ToolConfirmationMessage.tsx (4 locations)
2. **Types** - Extend UpdatePolicy message with persist, commandPrefix, argsPattern, mcpName
3. **Persistence** - Implement TOML read/write/append in config.ts (main logic)
4. **Tool Integration** - Add publishPolicyUpdate() calls in 8 tool files
5. **Tests** - New persistence.test.ts (209 lines)
6. **Snapshots** - Update UI snapshots for new option

**Files We Can Skip:**
- `packages/core/src/tools/smart-edit.ts` - NOT in LLxprt (removed)
- Test files in `tmp/gemini-cli-upstream/` - Upstream references only

**Files Requiring LLxprt Adaptations:**
- `packages/core/src/tools/web-fetch.ts` → Split into `google-web-fetch.ts` + `direct-web-fetch.ts`
- All import paths: `@google/gemini-cli-core` → `@vybestack/llxprt-code-core`
- All license headers: Google LLC → Vybestack LLC
- All storage paths: `gemini-code-cli` → `llxprt`

---

## Notes for Implementer

1. **Follow TDD strictly** - Write tests first, implement minimal code to pass, refactor if valuable
2. **Security is paramount** - Grep audit for telemetry before committing
3. **Test manually** - Integration tests catch issues unit tests miss
4. **Review snapshots carefully** - Option numbering must be correct
5. **Document as you go** - Update README/CHANGELOG before final commit
6. **Ask for help if stuck** - This is a high-risk feature, better to ask than break

---

## Conclusion

This plan provides a **complete, self-contained guide** for implementing persistent always-allow policies using **test-driven development**. The plan includes:

[OK] **Requirements** - 10 behavioral requirements with acceptance criteria  
[OK] **Touchpoints** - Exact files/lines/changes for every modification  
[OK] **Existing Tests** - What to adjust in current test suites  
[OK] **New Tests (RED)** - Complete test file with 20+ test cases  
[OK] **Implementation (GREEN)** - Exact production code for all changes  
[OK] **Verification** - Manual integration tests and security audit  
[OK] **Documentation** - README and CHANGELOG updates  
[OK] **Timeline** - 4-5 day implementation schedule  
[OK] **Risk Assessment** - High/medium/low risk areas with mitigations

**Critical Security Reminders:**
- ZERO Google telemetry (grep audit mandatory)
- TOML persistence to `~/.llxprt/policies/auto-saved.toml` only
- Trusted folder requirement (no saves in untrusted directories)
- Admin policies always override user policies

**Test-First Approach:**
1. Write failing tests (RED)
2. Implement minimal code to pass (GREEN)
3. Refactor if valuable (optional)
4. Commit with detailed message

This implementation is **HIGH RISK** due to file I/O, security requirements, and cross-session persistence. Extra rigor is required. Follow the plan systematically, run tests frequently, and conduct thorough security audits before committing.

Good luck! 
