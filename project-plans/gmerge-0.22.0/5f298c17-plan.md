# Reimplementation Plan: Persistent Always-Allow Policies (upstream 5f298c17) - HIGH RISK

## WARNING: CRITICAL SECURITY REQUIREMENT

**ZERO GOOGLE TELEMETRY - ALL PERSISTENCE MUST BE LOCAL TOML ONLY**

This feature MUST NOT introduce any telemetry, logging, or data transmission to Google services. All policy persistence must use local TOML files only. Any reference to ClearcutLogger or Google telemetry infrastructure is strictly forbidden.

## Upstream Commit Summary

**Commit:** 5f298c17d7f6c3a1eabbeac249904cd1cf141352  
**Author:** Allen Hutchison <adh@google.com>  
**Date:** Fri Dec 12 13:45:39 2025 -0800  
**Title:** feat: Persistent "Always Allow" policies with granular shell & MCP support (#14737)

### What Upstream Does

The upstream commit implements persistent "Always Allow" policies that survive session restarts. Key features:

1. **New `ProceedAlwaysAndSave` outcome** - Extends confirmation flow with a persistent option
2. **Granular shell command support** - Can save policies for specific command prefixes (e.g., `git status`)
3. **MCP tool support** - Can save policies for specific MCP server/tool combinations
4. **TOML persistence** - Auto-saves policies to `~/.gemini-code-cli/policies/auto-saved.toml`
5. **In-memory + persistent dual operation** - Policies work in current session AND persist across restarts

### Files Changed (18 files, +431/-21 lines)

#### UI Layer Changes:
- `packages/cli/src/ui/components/messages/ToolConfirmationMessage.tsx` - Adds "Yes, allow always and save to policy" option
- Snapshot updates for tests

#### Core Policy Engine:
- `packages/core/src/confirmation-bus/types.ts` - Extends `UpdatePolicy` message with `persist`, `argsPattern`, `commandPrefix`, `mcpName`
- `packages/core/src/policy/config.ts` - Main persistence logic (TOML read/write)
- `packages/core/src/policy/toml-loader.ts` - Exports `escapeRegex()` helper
- `packages/core/src/policy/persistence.test.ts` - NEW: Comprehensive tests (209 lines)

#### Tool Integration:
- `packages/core/src/tools/tools.ts` - Base class adds `publishPolicyUpdate()`, `getPolicyUpdateOptions()`
- `packages/core/src/tools/shell.ts` - Overrides `getPolicyUpdateOptions()` for command prefixes
- `packages/core/src/tools/mcp-tool.ts` - Overrides for MCP server names
- `packages/core/src/tools/edit.ts` - Calls `publishPolicyUpdate()`
- `packages/core/src/tools/smart-edit.ts` - Calls `publishPolicyUpdate()` (NOT IN LLXPRT - SKIP)
- `packages/core/src/tools/memoryTool.ts` - Calls `publishPolicyUpdate()`
- `packages/core/src/tools/web-fetch.ts` - Calls `publishPolicyUpdate()` (LLXPRT: google-web-fetch.ts + direct-web-fetch.ts)
- `packages/core/src/tools/write-file.ts` - Calls `publishPolicyUpdate()`

#### Zed Integration:
- `packages/cli/src/zed-integration/zedIntegration.ts` - Handles new outcome in switch statement

## Why We Can't Cherry-Pick

1. **Import path differences** - LLxprt uses `@vybestack/llxprt-code-core` vs `@google/gemini-cli-core`
2. **License headers** - Vybestack LLC vs Google LLC
3. **File locations** - Storage paths use `~/.llxprt/` vs `~/.gemini-code-cli/`
4. **Test infrastructure** - Different vitest setup and mock patterns
5. **Telemetry verification** - Must audit to ensure NO Google telemetry introduced
6. **Tool name differences** - LLxprt has `google-web-fetch.ts` and `direct-web-fetch.ts` instead of `web-fetch.ts`
7. **Removed files** - LLxprt removed `smart-edit.ts` (skip that file entirely)

## Critical Gaps Addressed in This Revision

### Gap 1: Confirmation-Bus Integration Details

**Problem:** Original plan didn't explain HOW persistent policies change future confirmation prompts.

**Solution:**

When a user selects "Yes, allow always and save to policy" (`ProceedAlwaysAndSave`), the system:

1. **Immediate Effect (In-Memory):**
   - `createPolicyUpdater()` adds a rule to `policyEngine` with priority 2.95
   - This rule is an in-memory regex pattern matching the tool args
   - For shell commands with `commandPrefix`, converts prefix to regex: `"command":"<escaped-prefix>"`
   - For MCP tools with `mcpName`, the rule matches the full tool name `mcpName__toolName`

2. **Persistent Effect (TOML File):**
   - Writes to `~/.llxprt/policies/auto-saved.toml`
   - Rule structure in TOML:
     ```toml
     [[rule]]
     toolName = "run_shell_command"
     commandPrefix = "git status"
     decision = "allow"
     priority = 100
     ```
   - Next session: `toml-loader.ts` reads this file at startup
   - Converts `commandPrefix` to `argsPattern` regex during load
   - Adds rule to `policyEngine` with priority from TOML (100 or 200)

3. **Future Confirmation Flow:**
   - Every tool invocation calls `getMessageBusDecision()` → `policyEngine.evaluatePolicy()`
   - Policy engine checks rules in priority order (higher priority wins)
   - If persistent rule matches (e.g., command starts with "git status"):
     - Returns `PolicyDecision.ALLOW`
     - Tool's `shouldConfirmExecute()` returns `false` (no confirmation needed)
     - User never sees the prompt again
   - If no rule matches:
     - Returns `PolicyDecision.ASK_USER`
     - Tool shows confirmation UI as normal

**Priority Hierarchy (highest to lowest):**
- 300+: Admin policies (system-wide `settings.json` excludes)
- 200: Settings excludes
- 200: Persisted MCP policies (in `auto-saved.toml`)
- 100: Persisted tool policies (in `auto-saved.toml`)
- 2.95: In-memory "always allow" (session-only, via `ProceedAlways`)
- 0: Default policies

### Gap 2: Security Guardrails Against Dangerous Operations

**Problem:** No safeguards prevent users from always-allowing destructive commands.

**Solution:**

**Existing Safeguards (Already in LLxprt):**

1. **Trusted Folder Requirement:**
   - `ToolConfirmationMessage.tsx` only shows "always allow" options when `config.isTrustedFolder()` returns `true`
   - User must explicitly trust the workspace via `llxprt trust` command
   - Prevents accidental always-allow in untrusted directories

2. **Policy Priority System:**
   - Admin policies (priority 300+) ALWAYS override user policies
   - System administrators can block dangerous tools via `/etc/llxprt-code/policies/`
   - User's `auto-saved.toml` (priority 100/200) cannot bypass admin blocks

3. **Tool-Level Validation:**
   - Each tool's `execute()` method still performs safety checks
   - Example: `shell.ts` validates command syntax, checks for dangerous patterns
   - Always-allow only skips USER confirmation, not safety validation

**NEW Safeguard - Command Prefix Granularity:**

4. **Granular Shell Command Matching:**
   - When user clicks "Yes, allow always and save to policy" for `git status`
   - System saves `commandPrefix = "git status"` (exact prefix)
   - Future commands must START with this exact prefix to match
   - `git status` matches, `git push` does NOT match
   - This prevents broad wildcarding (unlike session-only `ProceedAlways` which allows all shell commands)

**Recommended Additional Safeguards (Implementation Notes):**

5. **User Warning for Destructive Patterns (FUTURE ENHANCEMENT):**
   - Could add a secondary confirmation for dangerous command prefixes:
     ```typescript
     const DANGEROUS_PATTERNS = [/rm\s+-rf/, /sudo/, /chmod\s+777/, /dd\s+if=/];
     if (DANGEROUS_PATTERNS.some(p => p.test(commandPrefix))) {
       // Show warning: "This command could be destructive. Are you sure?"
     }
     ```
   - Not in upstream, not in this implementation
   - Could be added in follow-up PR if testing reveals abuse

6. **Policy Review UI (FUTURE ENHANCEMENT):**
   - Could add `llxprt policy list` command to show all saved policies
   - Could add `llxprt policy remove <id>` to delete specific rules
   - Not in upstream, but would improve user control
   - Could be added in follow-up PR

**Documentation Requirements:**

- README must warn users: "Always-allow policies persist across sessions. Review saved policies regularly."
- Example: `cat ~/.llxprt/policies/auto-saved.toml` to inspect saved rules
- Document priority system: admin policies override user policies

### Gap 3: Atomic TOML Write Handling

**Problem:** No protection against concurrent writes from multiple LLxprt sessions.

**Solution:**

**Implemented Atomic Write Pattern:**

```typescript
// In config.ts createPolicyUpdater()
const tmpFile = `${policyFile}.tmp`;
await fs.writeFile(tmpFile, newContent, 'utf-8');
await fs.rename(tmpFile, policyFile);
```

**Why This Works:**
- `fs.rename()` is atomic on POSIX systems (macOS, Linux)
- On Windows, it's atomic within the same volume
- If process crashes during `writeFile()`, temp file is left behind, original is intact
- If process crashes before `rename()`, original is intact
- Only risk: concurrent writes from two sessions simultaneously

**Concurrent Write Scenarios:**

**Scenario A: Two sessions save policies for different tools at same time**
- Session 1: Saves policy for `run_shell_command` with `git status`
- Session 2: Saves policy for `edit` tool
- Race condition: Both read same file, both add their rule, one overwrites the other
- **Result:** Last writer wins, one rule is lost

**Scenario B: Two sessions save same tool/command simultaneously**
- Session 1 & 2: Both save `run_shell_command` with `git status`
- **Result:** Duplicate rules in file (harmless but wasteful)

**Mitigation Strategies:**

1. **File Locking (NOT IMPLEMENTED - cross-platform complexity):**
   - Could use `fs.open()` with exclusive flags
   - Node.js doesn't have portable file locking
   - Would require platform-specific code (lockfile library)
   - Upstream doesn't implement this either

2. **Read-Modify-Write with Retry (IMPLEMENTED in upstream, adopted here):**
   ```typescript
   // Read existing file
   let existingData: { rule?: TomlRule[] } = {};
   try {
     const fileContent = await fs.readFile(policyFile, 'utf-8');
     existingData = toml.parse(fileContent) as { rule?: TomlRule[] };
   } catch (error) {
     if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
       console.warn(`Failed to parse ${policyFile}, overwriting...`);
     }
   }
   
   // Append new rule to existing rules
   existingData.rule = existingData.rule || [];
   existingData.rule.push(newRule);
   ```
   - This APPENDS to existing rules rather than overwriting
   - Reduces window of data loss (only new additions at risk)
   - If concurrent writes occur, worst case is duplicate rules

3. **User Guidance (DOCUMENTATION):**
   - Recommend running only one LLxprt session per workspace at a time
   - Document that concurrent policy saves may result in duplicates
   - Duplicates are harmless (policy engine deduplicates during evaluation)

**Error Handling:**

```typescript
try {
  // ... TOML write logic ...
} catch (error) {
  coreEvents.emitFeedback(
    'error',
    `Failed to persist policy for ${toolName}`,
    error,
  );
}
```

- Non-fatal: If TOML write fails, in-memory rule still works for current session
- User sees error message but session continues
- Common failure modes:
  - Disk full → error logged, session continues
  - Permission denied → error logged, session continues
  - Corrupt TOML → overwrites with new policy (logged warning)

**Testing Requirements:**

- Unit test: Corrupt TOML file (invalid syntax) → should overwrite gracefully
- Unit test: Missing file → should create new file
- Unit test: Existing rules → should append without duplication
- Manual test: Simulate disk full (verify error handling)
- Manual test: Two sessions save simultaneously (observe behavior)

### Gap 4: UI Component Differences

**Problem:** Original plan didn't specify exact UI differences between LLxprt and upstream.

**Solution:**

**LLxprt Tool Confirmation UI Structure:**

LLxprt's `ToolConfirmationMessage.tsx` has **4 distinct confirmation types**, each needing the new option:

**Type 1: Edit Confirmations (line ~205-219)**
```typescript
if (confirmationDetails.type === 'edit') {
  question = `Apply this change?`;
  options.push({ label: 'Yes, allow once', value: ProceedOnce });
  
  if (isTrustedFolder) {
    options.push({ label: 'Yes, allow always', value: ProceedAlways });
    // NEW:
    options.push({ 
      label: 'Yes, allow always and save to policy', 
      value: ProceedAlwaysAndSave 
    });
  }
  
  if (!config.getIdeMode() || !isDiffingEnabled) {
    options.push({ 
      label: 'Modify with external editor', 
      value: ModifyWithEditor 
    });
  }
  options.push({ label: 'No, suggest changes (esc)', value: Cancel });
}
```

**Key Differences from Upstream:**
- LLxprt has `ModifyWithEditor` option (upstream might not)
- LLxprt checks `config.getIdeMode()` for IDE-specific behavior
- Insert position: After `ProceedAlways`, before `ModifyWithEditor`

**Type 2: Shell Execution Confirmations (line ~283-298)**
```typescript
else if (confirmationDetails.type === 'exec') {
  question = `Allow execution of: '${executionProps.rootCommand}'?`;
  options.push({ label: 'Yes, allow once', value: ProceedOnce });
  
  if (isTrustedFolder) {
    options.push({ 
      label: `Yes, allow always ...`, 
      value: ProceedAlways 
    });
    // NEW:
    options.push({ 
      label: `Yes, allow always and save to policy`, 
      value: ProceedAlwaysAndSave 
    });
  }
  
  options.push({ label: 'No, suggest changes', value: SuggestEdit });
  options.push({ label: 'No, cancel (esc)', value: Cancel });
}
```

**Key Differences from Upstream:**
- LLxprt has `SuggestEdit` option for shell commands (allows user to modify command)
- When user selects `SuggestEdit`, UI switches to text input mode
- Insert position: After `ProceedAlways`, before `SuggestEdit`

**Type 3: Info Tool Confirmations (line ~346-360)**
```typescript
else if (confirmationDetails.type === 'info') {
  question = `Do you want to proceed?`;
  options.push({ label: 'Yes, allow once', value: ProceedOnce });
  
  if (isTrustedFolder) {
    options.push({ label: 'Yes, allow always', value: ProceedAlways });
    // NEW:
    options.push({ 
      label: 'Yes, allow always and save to policy', 
      value: ProceedAlwaysAndSave 
    });
  }
  
  options.push({ label: 'No, suggest changes (esc)', value: Cancel });
}
```

**Used by:** `google-web-fetch.ts`, `direct-web-fetch.ts`

**Key Differences from Upstream:**
- LLxprt has TWO web fetch tools (google-web-fetch uses Gemini API, direct-web-fetch uses raw HTTP)
- Both use `type: 'info'` confirmations
- Insert position: After `ProceedAlways`, before `Cancel`

**Type 4: MCP Tool Confirmations (line ~367-389)**
```typescript
else { // MCP tool
  question = `Allow execution of MCP tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"?`;
  options.push({ label: 'Yes, allow once', value: ProceedOnce });
  
  if (isTrustedFolder) {
    options.push({
      label: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
      value: ProceedAlwaysTool,
    });
    options.push({
      label: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
      value: ProceedAlwaysServer,
    });
    // NEW:
    options.push({
      label: `Yes, allow always tool "${mcpProps.toolName}" and save to policy`,
      value: ProceedAlwaysAndSave,
    });
  }
  
  options.push({ label: 'No, suggest changes (esc)', value: Cancel });
}
```

**Key Differences from Upstream:**
- LLxprt has same MCP options as upstream
- **Important:** `ProceedAlwaysAndSave` applies to SPECIFIC TOOL only (like `ProceedAlwaysTool`)
- `ProceedAlwaysServer` remains session-only (doesn't save to TOML)
- Insert position: After `ProceedAlwaysServer`, before `Cancel`

**UI Behavior Matrix:**

| Confirmation Type | Trusted Folder Required? | Session-Only Options | Persistent Options (NEW) | Other Options |
|---|---|---|---|---|
| Edit | Yes | `ProceedAlways` | `ProceedAlwaysAndSave` | `ModifyWithEditor`, `SuggestEdit`, `Cancel` |
| Shell Exec | Yes | `ProceedAlways` | `ProceedAlwaysAndSave` | `SuggestEdit`, `Cancel` |
| Info (web fetch) | Yes | `ProceedAlways` | `ProceedAlwaysAndSave` | `Cancel` |
| MCP Tool | Yes | `ProceedAlways`, `ProceedAlwaysTool`, `ProceedAlwaysServer` | `ProceedAlwaysAndSave` | `Cancel` |

**Snapshot Test Updates Required:**

LLxprt has extensive snapshot tests in:
- `ToolConfirmationMessage.test.tsx.snap`
- `ToolGroupMessage.test.tsx.snap`

Expected changes:
- All snapshots showing "always allow" options will add one more line
- Option numbering will shift (e.g., "3. No, suggest changes" becomes "4. No, suggest changes")
- Snapshot count: ~8-12 snapshots will need updating

**Command to update snapshots:**
```bash
npm run test -w packages/cli -- -u ToolConfirmationMessage.test.tsx
npm run test -w packages/cli -- -u ToolGroupMessage.test.tsx
```

**Validation:**
- After updating, manually review each snapshot diff
- Verify "save to policy" option appears ONLY in trusted folders
- Verify numbering is consecutive
- Verify option ordering matches specification above

## LLxprt-Specific Adaptations

### Confirmed Differences:

1. **Storage Path:**
   - [OK] `Storage.getUserPoliciesDir()` returns `~/.llxprt/policies/` (verified in `storage.ts` line 60-62)
   - [OK] File will be `~/.llxprt/policies/auto-saved.toml` (NOT `~/.gemini-code-cli/`)

2. **No Telemetry:**
   - [OK] Grep confirms ZERO `ClearcutLogger` references in current codebase (239 matches are all in project plans, documentation, and removal comments)
   - [OK] `coreEvents.emitFeedback()` is local logging only (verified no Google telemetry)
   - [OK] NO telemetry in this implementation

3. **Tool Files:**
   - [OK] `smart-edit.ts` - DOES NOT EXIST in LLxprt (removed), SKIP this file
   - [OK] `web-fetch.ts` - DOES NOT EXIST, use `google-web-fetch.ts` and `direct-web-fetch.ts` instead
   - [OK] `edit.ts`, `memoryTool.ts`, `write-file.ts`, `shell.ts`, `mcp-tool.ts` - all exist

4. **No Persistence Module:**
   - [ERROR] `packages/core/src/policy/persistence.ts` does NOT exist
   - [OK] Must create this file from scratch (copy from upstream with adaptations)

5. **Confirmation Bus:**
   - [OK] `MessageBus` exists in `packages/core/src/confirmation-bus/message-bus.ts`
   - [OK] `MessageBusType.UPDATE_POLICY` already used for session-only policies
   - [OK] Just need to extend `UpdatePolicy` interface in `types.ts`

## Implementation Plan

### PHASE 1: Core Type Extensions (Low Risk)

#### Step 1.1: Extend `ToolConfirmationOutcome` enum

**File:** `packages/core/src/tools/tool-confirmation-types.ts`

**Location:** After `ProceedAlways = 'proceed_always',` (line ~11)

```typescript
export enum ToolConfirmationOutcome {
  ProceedOnce = 'proceed_once',
  ProceedAlways = 'proceed_always',
  ProceedAlwaysAndSave = 'proceed_always_and_save',  // NEW
  ProceedAlwaysServer = 'proceed_always_server',
  ProceedAlwaysTool = 'proceed_always_tool',
  ModifyWithEditor = 'modify_with_editor',
  SuggestEdit = 'suggest_edit',
  Cancel = 'cancel',
}
```

**Verification:**
```bash
npm run typecheck -w packages/core
```

#### Step 1.2: Extend `UpdatePolicy` message type

**File:** `packages/core/src/confirmation-bus/types.ts`

**Location:** Replace existing `UpdatePolicy` interface (~line 39-42)

```typescript
export interface UpdatePolicy {
  type: MessageBusType.UPDATE_POLICY;
  toolName: string;
  persist?: boolean;           // NEW: When true, save to TOML
  argsPattern?: string;        // NEW: Regex pattern for tool args
  commandPrefix?: string;      // NEW: Shell command prefix (e.g., "git status")
  mcpName?: string;           // NEW: MCP server name
}
```

**Verification:**
```bash
npm run typecheck -w packages/core
```

### PHASE 2: Core Policy Engine Changes (CRITICAL - HIGH RISK)

#### Step 2.1: Export `escapeRegex` helper

**File:** `packages/core/src/policy/toml-loader.ts`

**Location:** Line ~129 (the existing `escapeRegex` function)

**Change:**
```typescript
// FROM:
function escapeRegex(str: string): string {

// TO:
export function escapeRegex(str: string): string {
```

**Verification:**
```bash
npm run test -w packages/core -- toml-loader.test.ts
```

#### Step 2.2: Add TOML persistence to `createPolicyUpdater`

**File:** `packages/core/src/policy/config.ts`

**Prerequisites:**
- Add imports at top of file:
```typescript
import * as fs from 'node:fs/promises';
import toml from '@iarna/toml';
import { escapeRegex } from './toml-loader.js';
```

**Location:** Replace the `createPolicyUpdater` function (currently at lines ~237-249)

**CRITICAL VERIFICATION POINTS:**
- [x] Uses `Storage.getUserPoliciesDir()` → `~/.llxprt/policies/` (NOT Google paths)
- [x] NO references to ClearcutLogger
- [x] NO telemetry calls (only `coreEvents.emitFeedback` for local error logging)
- [x] Atomic writes (tmp file + rename)
- [x] Handles existing TOML file merging
- [x] Proper error handling

**Full replacement:**

```typescript
interface TomlRule {
  toolName?: string;
  mcpName?: string;
  decision?: string;
  priority?: number;
  commandPrefix?: string;
  argsPattern?: string;
  // Index signature for toml.stringify compatibility
  [key: string]: unknown;
}

export function createPolicyUpdater(
  policyEngine: PolicyEngine,
  messageBus: MessageBus,
) {
  messageBus.subscribe(
    MessageBusType.UPDATE_POLICY,
    async (message: UpdatePolicy) => {
      const toolName = message.toolName;
      let argsPattern = message.argsPattern
        ? new RegExp(message.argsPattern)
        : undefined;

      if (message.commandPrefix) {
        // Convert commandPrefix to argsPattern for in-memory rule
        // This mimics what toml-loader does when loading persisted rules
        const escapedPrefix = escapeRegex(message.commandPrefix);
        argsPattern = new RegExp(`"command":"${escapedPrefix}`);
      }

      // Add in-memory rule (works for current session, lost on restart unless persist=true)
      policyEngine.addRule({
        toolName,
        decision: PolicyDecision.ALLOW,
        // Priority 2.95 ensures user "always allow" selections win over defaults
        // but lose to admin policies (3.xxx) and settings excludes (200)
        priority: 2.95,
        argsPattern,
      });

      // PERSISTENCE LOGIC - CRITICAL SECTION
      if (message.persist) {
        try {
          const userPoliciesDir = Storage.getUserPoliciesDir();
          await fs.mkdir(userPoliciesDir, { recursive: true });
          const policyFile = path.join(userPoliciesDir, 'auto-saved.toml');

          // Read existing file (if any)
          let existingData: { rule?: TomlRule[] } = {};
          try {
            const fileContent = await fs.readFile(policyFile, 'utf-8');
            existingData = toml.parse(fileContent) as { rule?: TomlRule[] };
          } catch (error) {
            if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
              console.warn(
                `Failed to parse ${policyFile}, overwriting with new policy.`,
                error,
              );
            }
          }

          // Initialize rule array if needed
          if (!existingData.rule) {
            existingData.rule = [];
          }

          // Build new rule
          const newRule: TomlRule = {};

          if (message.mcpName) {
            // MCP tool policy
            newRule.mcpName = message.mcpName;
            // Extract simple tool name (remove "mcpName__" prefix)
            const simpleToolName = toolName.startsWith(`${message.mcpName}__`)
              ? toolName.slice(message.mcpName.length + 2)
              : toolName;
            newRule.toolName = simpleToolName;
            newRule.decision = 'allow';
            newRule.priority = 200;
          } else {
            // Standard tool policy
            newRule.toolName = toolName;
            newRule.decision = 'allow';
            newRule.priority = 100;
          }

          if (message.commandPrefix) {
            newRule.commandPrefix = message.commandPrefix;
          } else if (message.argsPattern) {
            newRule.argsPattern = message.argsPattern;
          }

          existingData.rule.push(newRule);

          // Serialize to TOML
          const newContent = toml.stringify(existingData as toml.JsonMap);

          // Atomic write: tmp file + rename
          const tmpFile = `${policyFile}.tmp`;
          await fs.writeFile(tmpFile, newContent, 'utf-8');
          await fs.rename(tmpFile, policyFile);
        } catch (error) {
          coreEvents.emitFeedback(
            'error',
            `Failed to persist policy for ${toolName}`,
            error,
          );
        }
      }
    },
  );
}
```

**Security Audit Checklist:**
- [ ] Verify Storage.getUserPoliciesDir() returns `~/.llxprt/policies/`
- [ ] Confirm no ClearcutLogger imports
- [ ] Confirm no telemetry calls (coreEvents.emitFeedback is local-only)
- [ ] Verify atomic writes (tmp + rename pattern)
- [ ] Test file permission handling

**Verification:**
```bash
npm run test -w packages/core -- config.test.ts
npm run typecheck -w packages/core
```

### PHASE 3: Tool Integration (Medium Risk)

#### Step 3.1: Add base class helpers in `tools.ts`

**File:** `packages/core/src/tools/tools.ts`

**Location 1:** After `ToolInvocation` interface (~line 65), add:

```typescript
/**
 * Options for policy updates that can be customized by tool invocations.
 */
export interface PolicyUpdateOptions {
  commandPrefix?: string;
  mcpName?: string;
}
```

**Location 2:** In `BaseToolInvocation` class, find the `getConfirmationDetails()` method.

**Current code has NO onConfirm callback** (verified from uploaded files). The method returns:
```typescript
protected async getConfirmationDetails(
  _abortSignal: AbortSignal,
): Promise<ToolCallConfirmationDetails | false> {
  const confirmationDetails: ToolCallConfirmationDetails = {
    type: 'info',
    title: `Confirm: ${this._toolDisplayName || this._toolName}`,
    prompt: this.getDescription(),
    onConfirm: async (outcome: ToolConfirmationOutcome) => {
      await this.publishPolicyUpdate(outcome);  // CHANGE TO THIS
    },
  };
  return confirmationDetails;
}
```

**Location 3:** Add new protected methods in `BaseToolInvocation` class (after `shouldConfirmExecute` method):

```typescript
/**
 * Returns tool-specific options for policy updates.
 * Subclasses can override this to provide additional options like
 * commandPrefix (for shell) or mcpName (for MCP tools).
 */
protected getPolicyUpdateOptions(
  _outcome: ToolConfirmationOutcome,
): PolicyUpdateOptions | undefined {
  return undefined;
}

/**
 * Helper method to publish a policy update when user selects
 * ProceedAlways or ProceedAlwaysAndSave.
 */
protected async publishPolicyUpdate(
  outcome: ToolConfirmationOutcome,
): Promise<void> {
  if (
    outcome === ToolConfirmationOutcome.ProceedAlways ||
    outcome === ToolConfirmationOutcome.ProceedAlwaysAndSave
  ) {
    if (this.messageBus && this._toolName) {
      const options = this.getPolicyUpdateOptions(outcome);
      await this.messageBus.publish({
        type: MessageBusType.UPDATE_POLICY,
        toolName: this._toolName,
        persist: outcome === ToolConfirmationOutcome.ProceedAlwaysAndSave,
        ...options,
      });
    }
  }
}
```

**Verification:**
```bash
npm run test -w packages/core -- tools.test.ts
npm run typecheck -w packages/core
```

#### Step 3.2: Add shell command prefix support

**File:** `packages/core/src/tools/shell.ts`

**Location 1:** Add import at top:
```typescript
import { type PolicyUpdateOptions } from './tools.js';
```

**Location 2:** Add method in `ShellToolInvocation` class (after `getDescription()` method):

```typescript
protected override getPolicyUpdateOptions(
  outcome: ToolConfirmationOutcome,
): PolicyUpdateOptions | undefined {
  if (outcome === ToolConfirmationOutcome.ProceedAlwaysAndSave) {
    return { commandPrefix: this.params.command };
  }
  return undefined;
}
```

**Location 3:** In `getConfirmationDetails()` method, find the onConfirm callback.

**LLxprt's shell.ts already has an onConfirm that manages allowlist.** Need to ADD the publishPolicyUpdate call:

```typescript
// Find this code:
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    commandsToConfirm.forEach((command) => this.allowlist.add(command));
  }
  // ADD THIS LINE:
  await this.publishPolicyUpdate(outcome);
},
```

**Verification:**
```bash
npm run test -w packages/core -- shell.test.ts
```

#### Step 3.3: Add MCP tool support

**File:** `packages/core/src/tools/mcp-tool.ts`

**Location 1:** Add import at top:
```typescript
import { type PolicyUpdateOptions } from './tools.js';
```

**Location 2:** Add method in `DiscoveredMCPToolInvocation` class:

```typescript
protected override getPolicyUpdateOptions(
  _outcome: ToolConfirmationOutcome,
): PolicyUpdateOptions | undefined {
  return { mcpName: this.serverName };
}
```

**Location 3:** In `getConfirmationDetails()` method, find the onConfirm callback.

**LLxprt's mcp-tool.ts already manages allowlist.** Need to ADD the new outcome and publish:

```typescript
// Find this code (around line 115):
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlwaysServer) {
    DiscoveredMCPToolInvocation.allowlist.add(serverAllowListKey);
  } else if (outcome === ToolConfirmationOutcome.ProceedAlwaysTool) {
    DiscoveredMCPToolInvocation.allowlist.add(toolAllowListKey);
  }
  // ADD THIS BLOCK:
  else if (outcome === ToolConfirmationOutcome.ProceedAlwaysAndSave) {
    DiscoveredMCPToolInvocation.allowlist.add(toolAllowListKey);
    await this.publishPolicyUpdate(outcome);
  }
},
```

**Verification:**
```bash
npm run test -w packages/core -- mcp-tool.test.ts
```

#### Step 3.4: Add `publishPolicyUpdate` calls to other tools

**Pattern for tools with existing onConfirm callbacks:**

Find the onConfirm callback in `getConfirmationDetails()`. If it has a `ProceedAlways` check, add `await this.publishPolicyUpdate(outcome);` after it.

**File 1: `packages/core/src/tools/edit.ts`**

**Current code (verified from uploaded files):**
```typescript
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    this.config.setApprovalMode(ApprovalMode.AUTO_EDIT);
  }
  // ADD THIS LINE:
  await this.publishPolicyUpdate(outcome);
  
  // ... rest of code (ideConfirmation handling, etc.)
},
```

**File 2: `packages/core/src/tools/memoryTool.ts`**

```typescript
// Around line 226 in getConfirmationDetails():
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    MemoryToolInvocation.allowlist.add(allowlistKey);
  }
  await this.publishPolicyUpdate(outcome);  // ADD THIS LINE
},
```

**File 3: `packages/core/src/tools/write-file.ts`**

```typescript
// In getConfirmationDetails():
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    this.config.setApprovalMode(ApprovalMode.AUTO_EDIT);
  }
  await this.publishPolicyUpdate(outcome);  // ADD THIS LINE
  
  // ... ideConfirmation handling ...
},
```

**File 4: `packages/core/src/tools/google-web-fetch.ts`**

```typescript
// Around line 263:
onConfirm: async (outcome: ToolConfirmationOutcome) => {
  if (outcome === ToolConfirmationOutcome.ProceedAlways) {
    this.config.setApprovalMode(ApprovalMode.AUTO_EDIT);
  }
  await this.publishPolicyUpdate(outcome);  // ADD THIS LINE
},
```

**File 5: `packages/core/src/tools/direct-web-fetch.ts`**

**Check if this file has getConfirmationDetails().** If it does, add the same pattern. If it relies on base class, no changes needed.

**SKIP: `packages/core/src/tools/smart-edit.ts`**
- This file does NOT exist in LLxprt (removed)
- Do not attempt to modify it

**Verification:**
```bash
npm run test -w packages/core
```

### PHASE 4: UI Integration (Medium Risk)

#### Step 4.1: Add "save to policy" option in confirmation UI

**File:** `packages/cli/src/ui/components/messages/ToolConfirmationMessage.tsx`

**Add the new option in 4 locations (after each `ProceedAlways` option):**

**Location 1:** Edit confirmations (~line 214):
```typescript
if (isTrustedFolder) {
  options.push({
    label: 'Yes, allow always',
    value: ToolConfirmationOutcome.ProceedAlways,
    key: 'Yes, allow always',
  });
  // ADD THIS:
  options.push({
    label: 'Yes, allow always and save to policy',
    value: ToolConfirmationOutcome.ProceedAlwaysAndSave,
    key: 'Yes, allow always and save to policy',
  });
}
```

**Location 2:** Shell command confirmations (~line 289):
```typescript
if (isTrustedFolder) {
  options.push({
    label: `Yes, allow always ...`,
    value: ToolConfirmationOutcome.ProceedAlways,
    key: `Yes, allow always ...`,
  });
  // ADD THIS:
  options.push({
    label: `Yes, allow always and save to policy`,
    value: ToolConfirmationOutcome.ProceedAlwaysAndSave,
    key: `Yes, allow always and save to policy`,
  });
}
```

**Location 3:** Info tool confirmations (~line 353):
```typescript
if (isTrustedFolder) {
  options.push({
    label: 'Yes, allow always',
    value: ToolConfirmationOutcome.ProceedAlways,
    key: 'Yes, allow always',
  });
  // ADD THIS:
  options.push({
    label: 'Yes, allow always and save to policy',
    value: ToolConfirmationOutcome.ProceedAlwaysAndSave,
    key: 'Yes, allow always and save to policy',
  });
}
```

**Location 4:** MCP tool confirmations (~line 380):
```typescript
if (isTrustedFolder) {
  options.push({
    label: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
    value: ToolConfirmationOutcome.ProceedAlwaysTool,
    key: `Yes, always allow tool "${mcpProps.toolName}" from server "${mcpProps.serverName}"`,
  });
  options.push({
    label: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
    value: ToolConfirmationOutcome.ProceedAlwaysServer,
    key: `Yes, always allow all tools from server "${mcpProps.serverName}"`,
  });
  // ADD THIS:
  options.push({
    label: `Yes, allow always tool "${mcpProps.toolName}" and save to policy`,
    value: ToolConfirmationOutcome.ProceedAlwaysAndSave,
    key: `Yes, allow always tool "${mcpProps.toolName}" and save to policy`,
  });
}
```

**Verification:**
```bash
npm run test -w packages/cli -- ToolConfirmationMessage.test.tsx
npm run test -w packages/cli -- ToolGroupMessage.test.tsx
```

**Update snapshots:**
```bash
npm run test -w packages/cli -- -u ToolConfirmationMessage.test.tsx
npm run test -w packages/cli -- -u ToolGroupMessage.test.tsx
```

**Manual review:** Inspect snapshot diffs to ensure option numbering is correct and "save to policy" appears only in trusted folders.

#### Step 4.2: Handle new outcome in Zed integration

**File:** `packages/cli/src/zed-integration/zedIntegration.ts`

**Location:** In the `Session.prompt()` method, find the switch statement handling outcomes (~line 449)

**Find:**
```typescript
case ToolConfirmationOutcome.ProceedOnce:
case ToolConfirmationOutcome.ProceedAlways:
case ToolConfirmationOutcome.ProceedAlwaysServer:
case ToolConfirmationOutcome.ProceedAlwaysTool:
case ToolConfirmationOutcome.ModifyWithEditor:
```

**Change to:**
```typescript
case ToolConfirmationOutcome.ProceedOnce:
case ToolConfirmationOutcome.ProceedAlways:
case ToolConfirmationOutcome.ProceedAlwaysAndSave:  // ADD THIS
case ToolConfirmationOutcome.ProceedAlwaysServer:
case ToolConfirmationOutcome.ProceedAlwaysTool:
case ToolConfirmationOutcome.ModifyWithEditor:
```

**Verification:**
```bash
npm run typecheck -w packages/cli
```

### PHASE 5: Comprehensive Testing (CRITICAL)

#### Step 5.1: Create persistence test suite

**File:** `packages/core/src/policy/persistence.test.ts` (NEW FILE)

**Copy from upstream with adaptations:**

```typescript
/**
 * @license
 * Copyright 2025 Vybestack LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {
  describe,
  it,
  expect,
  vi,
  beforeEach,
  afterEach,
  type Mock,
} from 'vitest';
import * as fs from 'node:fs/promises';
import * as path from 'node:path';
import { createPolicyUpdater } from './config.js';
import { PolicyEngine } from './policy-engine.js';
import { MessageBus } from '../confirmation-bus/message-bus.js';
import { MessageBusType } from '../confirmation-bus/types.js';
import { Storage } from '../config/storage.js';

vi.mock('node:fs/promises');
vi.mock('../config/storage.js');

describe('createPolicyUpdater', () => {
  let policyEngine: PolicyEngine;
  let messageBus: MessageBus;

  beforeEach(() => {
    policyEngine = new PolicyEngine({ rules: [], checkers: [] });
    messageBus = new MessageBus(policyEngine);
    vi.clearAllMocks();
  });

  afterEach(() => {
    vi.restoreAllMocks();
  });

  it('should persist policy when persist flag is true', async () => {
    createPolicyUpdater(policyEngine, messageBus);

    const userPoliciesDir = '/mock/user/policies';
    vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
    (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
    (fs.readFile as unknown as Mock).mockRejectedValue(
      new Error('File not found'),
    ); // Simulate new file
    (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
    (fs.rename as unknown as Mock).mockResolvedValue(undefined);

    const toolName = 'test_tool';
    await messageBus.publish({
      type: MessageBusType.UPDATE_POLICY,
      toolName,
      persist: true,
    });

    // Wait for async operations
    await new Promise((resolve) => setTimeout(resolve, 0));

    expect(Storage.getUserPoliciesDir).toHaveBeenCalled();
    expect(fs.mkdir).toHaveBeenCalledWith(userPoliciesDir, {
      recursive: true,
    });

    // Check written content
    const expectedContent = expect.stringContaining(`toolName = "test_tool"`);
    expect(fs.writeFile).toHaveBeenCalledWith(
      expect.stringMatching(/\.tmp$/),
      expectedContent,
      'utf-8',
    );
    expect(fs.rename).toHaveBeenCalledWith(
      expect.stringMatching(/\.tmp$/),
      path.join(userPoliciesDir, 'auto-saved.toml'),
    );
  });

  it('should not persist policy when persist flag is false or undefined', async () => {
    createPolicyUpdater(policyEngine, messageBus);

    await messageBus.publish({
      type: MessageBusType.UPDATE_POLICY,
      toolName: 'test_tool',
    });

    await new Promise((resolve) => setTimeout(resolve, 0));

    expect(fs.writeFile).not.toHaveBeenCalled();
    expect(fs.rename).not.toHaveBeenCalled();
  });

  it('should persist policy with commandPrefix when provided', async () => {
    createPolicyUpdater(policyEngine, messageBus);

    const userPoliciesDir = '/mock/user/policies';
    vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
    (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
    (fs.readFile as unknown as Mock).mockRejectedValue(
      new Error('File not found'),
    );
    (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
    (fs.rename as unknown as Mock).mockResolvedValue(undefined);

    const toolName = 'run_shell_command';
    const commandPrefix = 'git status';

    await messageBus.publish({
      type: MessageBusType.UPDATE_POLICY,
      toolName,
      persist: true,
      commandPrefix,
    });

    await new Promise((resolve) => setTimeout(resolve, 0));

    // In-memory rule check
    const rules = policyEngine.getRules();
    const addedRule = rules.find((r) => r.toolName === toolName);
    expect(addedRule).toBeDefined();
    expect(addedRule?.priority).toBe(2.95);
    expect(addedRule?.argsPattern).toEqual(new RegExp(`"command":"git status`));

    // Verify file written
    expect(fs.writeFile).toHaveBeenCalledWith(
      expect.stringMatching(/\.tmp$/),
      expect.stringContaining(`commandPrefix = "git status"`),
      'utf-8',
    );
  });

  it('should persist policy with mcpName and toolName when provided', async () => {
    createPolicyUpdater(policyEngine, messageBus);

    const userPoliciesDir = '/mock/user/policies';
    vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
    (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
    (fs.readFile as unknown as Mock).mockRejectedValue(
      new Error('File not found'),
    );
    (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
    (fs.rename as unknown as Mock).mockResolvedValue(undefined);

    const mcpName = 'my-jira-server';
    const simpleToolName = 'search';
    const toolName = `${mcpName}__${simpleToolName}`;

    await messageBus.publish({
      type: MessageBusType.UPDATE_POLICY,
      toolName,
      persist: true,
      mcpName,
    });

    await new Promise((resolve) => setTimeout(resolve, 0));

    // Verify file written
    const writeCall = (fs.writeFile as unknown as Mock).mock.calls[0];
    const writtenContent = writeCall[1] as string;
    expect(writtenContent).toContain(`mcpName = "${mcpName}"`);
    expect(writtenContent).toContain(`toolName = "${simpleToolName}"`);
    expect(writtenContent).toContain('priority = 200');
  });

  it('should escape special characters in commandPrefix', async () => {
    createPolicyUpdater(policyEngine, messageBus);

    const userPoliciesDir = '/mock/user/policies';
    vi.spyOn(Storage, 'getUserPoliciesDir').mockReturnValue(userPoliciesDir);
    (fs.mkdir as unknown as Mock).mockResolvedValue(undefined);
    (fs.readFile as unknown as Mock).mockRejectedValue(
      new Error('File not found'),
    );
    (fs.writeFile as unknown as Mock).mockResolvedValue(undefined);
    (fs.rename as unknown as Mock).mockResolvedValue(undefined);

    const commandPrefix = 'echo "hello world"';

    await messageBus.publish({
      type: MessageBusType.UPDATE_POLICY,
      toolName: 'run_shell_command',
      persist: true,
      commandPrefix,
    });

    await new Promise((resolve) => setTimeout(resolve, 0));

    const writeCall = (fs.writeFile as unknown as Mock).mock.calls[0];
    const writtenContent = writeCall[1] as string;

    // TOML library should escape quotes
    expect(writtenContent).toMatch(/commandPrefix = ["']echo "hello world"["']/);
  });
});
```

**Key test cases:**
1. [x] Persist flag controls TOML writes
2. [x] Command prefixes stored correctly
3. [x] MCP server names stored correctly
4. [x] Simple tool names extracted from MCP prefixed names
5. [x] Special characters escaped properly
6. [x] Priority values correct (100 for tools, 200 for MCP)
7. [ ] Multiple policies accumulate correctly (TODO: add test)
8. [ ] Corrupt TOML handled gracefully (TODO: add test)

**Verification:**
```bash
npm run test -w packages/core -- persistence.test.ts
```

#### Step 5.2: Integration testing

**Manual test scenarios:**

**Test 1: Shell command persistence**
```bash
# Start llxprt-code in a trusted folder
cd ~/trusted-project
llxprt trust

# Trigger shell command
# In chat: "run git status"
# Select "Yes, allow always and save to policy"

# Verify TOML file created
cat ~/.llxprt/policies/auto-saved.toml
# Should contain:
# [[rule]]
# toolName = "run_shell_command"
# commandPrefix = "git status"
# decision = "allow"
# priority = 100

# Exit and restart
exit
llxprt

# Trigger same command
# In chat: "run git status"
# Should auto-execute without confirmation

# Trigger different command
# In chat: "run git push"
# Should still ask for confirmation (different prefix)
```

**Test 2: MCP tool persistence**
```bash
# Configure MCP server
# (Assume "filesystem" server with "read_file" tool)

# Trigger MCP tool
# In chat: "use filesystem tool to read README.md"
# Select "Yes, allow always tool and save to policy"

# Verify TOML file
cat ~/.llxprt/policies/auto-saved.toml
# Should contain:
# [[rule]]
# mcpName = "filesystem"
# toolName = "read_file"
# decision = "allow"
# priority = 200

# Exit and restart
# Trigger same MCP tool - should auto-allow
# Trigger different MCP tool from same server - should ask
```

**Test 3: Multiple policies accumulate**
```bash
# Save policy for git status
# Save policy for edit tool
# Save policy for MCP tool

cat ~/.llxprt/policies/auto-saved.toml
# Should contain 3 [[rule]] blocks

# Restart - all 3 policies should work
```

**Test 4: Untrusted folder restriction**
```bash
cd ~/untrusted-project
# Do NOT run llxprt trust

# Trigger any tool
# Should NOT see "save to policy" option
# Should only see "Yes, allow once" and session-only "Yes, allow always"
```

**Test 5: Corrupt TOML recovery**
```bash
# Manually corrupt the file
echo "invalid toml syntax {{{" > ~/.llxprt/policies/auto-saved.toml

# Start llxprt, trigger tool, save policy
# Should see warning in logs
# Should overwrite corrupt file with valid TOML
```

#### Step 5.3: Security audit

**Checklist:**
- [ ] Run full test suite: `npm run test`
- [ ] Run type check: `npm run typecheck`
- [ ] Inspect `~/.llxprt/policies/auto-saved.toml` format
- [ ] Grep for Google telemetry: `grep -rn "ClearcutLogger" packages/core/src/policy/`
- [ ] Grep for Google paths: `grep -rn "gemini-code-cli" packages/core/src/policy/`
- [ ] Verify Storage.getUserPoliciesDir() uses `~/.llxprt/policies/`
- [ ] Test atomic write behavior (kill process during save)
- [ ] Test with multiple concurrent sessions (observe for data loss)
- [ ] Test with read-only filesystem (verify graceful error)
- [ ] Verify policies survive session restart
- [ ] Verify policies don't interfere with admin policies
- [ ] Verify trusted folder check works (no "save" option in untrusted folders)

### PHASE 6: Documentation

#### Step 6.1: Update user documentation

**Add to README.md or docs/:**

```markdown
## Persistent Always-Allow Policies

LLxprt Code can save your "always allow" confirmations to disk, so they persist across sessions.

### How it works

1. When confirming a tool execution (in a trusted folder), you'll see:
   - "Yes, allow once" - Allow this one time only
   - "Yes, allow always" - Allow for this session (resets on restart)
   - **"Yes, allow always and save to policy"** - Allow forever (persists to file)

2. Saved policies are stored in: `~/.llxprt/policies/auto-saved.toml`

3. Policies are granular:
   - **Shell commands:** Saved by command prefix. "git status" won't allow "git push".
   - **MCP tools:** Saved per server+tool combo. Allowing "jira__search" won't allow "jira__create".
   - **Other tools:** Saved by tool name.

### Viewing saved policies

```bash
cat ~/.llxprt/policies/auto-saved.toml
```

Example content:
```toml
[[rule]]
toolName = "run_shell_command"
commandPrefix = "git status"
decision = "allow"
priority = 100

[[rule]]
mcpName = "filesystem"
toolName = "read_file"
decision = "allow"
priority = 200
```

### Removing policies

To remove a saved policy, edit the file and delete the corresponding `[[rule]]` block.

### Policy priority

User-saved policies (priority 100-200) are overridden by:
- Admin policies (system-wide, priority 300+)
- Settings excludes (priority 200+)

This ensures system administrators can block dangerous operations even if users saved an "always allow" policy.

### Security notes

- "Save to policy" option only appears in **trusted folders** (`llxprt trust`)
- Use granular policies (command prefixes) to avoid over-permissive rules
- Review saved policies regularly: `cat ~/.llxprt/policies/auto-saved.toml`
- Never commit `auto-saved.toml` to version control (it's in `.gitignore`)
```

#### Step 6.2: Update CHANGELOG

**Add to CHANGELOG.md:**

```markdown
## [Unreleased]

### Added
- **Persistent "Always Allow" policies** - User confirmations can now be saved to `~/.llxprt/policies/auto-saved.toml` for cross-session persistence
  - New confirmation option: "Yes, allow always and save to policy"
  - Granular shell command policies via command prefixes (e.g., "git status" won't allow "git push")
  - MCP tool policies saved per server+tool combination
  - Policies survive session restarts and are loaded at startup
  - Only available in trusted folders (security requirement)
  - Admin policies always override user-saved policies
  - Based on upstream commit 5f298c17 with LLxprt adaptations (no Google telemetry)
```

## Implementation Order

### Timeline: 4-5 days

**Day 1: Type System & Core Engine (6-8 hours)**
- [x] Step 1.1: Add `ProceedAlwaysAndSave` enum (15 min)
- [x] Step 1.2: Extend `UpdatePolicy` type (15 min)
- [x] Step 2.1: Export `escapeRegex` (5 min)
- [x] Step 2.2: Implement TOML persistence in `config.ts` (3-4 hours)
- [x] **SECURITY AUDIT CHECKPOINT** (1 hour)
  - Grep for ClearcutLogger, Google paths, telemetry
  - Verify atomic writes, error handling
  - Code review of persistence logic
- [x] Run tests: `npm run test -w packages/core -- config.test.ts` (30 min)
- [x] Run typecheck: `npm run typecheck` (5 min)

**Day 2: Tool Integration (6-8 hours)**
- [x] Step 3.1: Base class helpers in `tools.ts` (1 hour)
- [x] Step 3.2: Shell command support (1 hour)
- [x] Step 3.3: MCP tool support (1 hour)
- [x] Step 3.4: Other tools (2-3 hours)
  - edit.ts
  - memoryTool.ts
  - write-file.ts
  - google-web-fetch.ts
  - direct-web-fetch.ts
- [x] Run tests: `npm run test -w packages/core` (1 hour)
- [x] Manual smoke test: Confirm tools still work (30 min)

**Day 3: UI & Testing (8 hours)**
- [x] Step 4.1: UI changes in `ToolConfirmationMessage.tsx` (2 hours)
- [x] Step 4.2: Zed integration (15 min)
- [x] Update snapshots: `npm run test -w packages/cli -- -u` (30 min)
- [x] Step 5.1: Create `persistence.test.ts` (3 hours)
- [x] Run all tests: `npm run test` (30 min)
- [x] Fix any failures (1 hour buffer)

**Day 4: Integration Testing & Security Audit (8 hours)**
- [x] Step 5.2: Manual integration tests (4 hours)
  - Shell command persistence
  - MCP tool persistence
  - Multiple policies
  - Untrusted folder restriction
  - Corrupt TOML recovery
- [x] Step 5.3: Security audit (2 hours)
  - All checklist items
  - Grep for banned patterns
  - Test atomic writes
  - Test concurrent sessions
- [x] **FINAL SECURITY CHECKPOINT** (1 hour)
- [x] Fix any issues found (1 hour buffer)

**Day 5 (if needed): Documentation & Polish (4 hours)**
- [x] Step 6.1: User documentation (2 hours)
- [x] Step 6.2: CHANGELOG update (30 min)
- [x] Final test run (30 min)
- [x] Code cleanup, comments (1 hour)

## Risk Assessment

### HIGH RISK AREAS

1. **TOML Persistence Logic** (`config.ts` Step 2.2) - **CRITICAL**
   - **Risks:**
     - File I/O errors (disk full, permissions)
     - TOML parsing errors (corrupt file)
     - Atomic write failures (crash mid-write)
     - Race conditions (concurrent sessions)
     - Path injection vulnerabilities
   - **Mitigations:**
     - Comprehensive error handling with `try/catch`
     - Atomic write pattern (tmp + rename)
     - Read-modify-write to append (reduces data loss window)
     - Non-fatal errors (session continues, error logged)
     - Use `Storage.getUserPoliciesDir()` (trusted path)
   - **Testing:**
     - Unit tests for all error paths
     - Manual tests: disk full, read-only, corrupt TOML
     - Concurrent session test (observe behavior)

2. **Security/Privacy** - **CRITICAL**
   - **Risks:**
     - Accidentally reintroduce Google telemetry
     - Use wrong storage path (Google paths)
     - Log sensitive data (command args)
     - Over-permissive policies (security bypass)
   - **Mitigations:**
     - Grep for banned patterns (ClearcutLogger, gemini-code-cli)
     - Verify Storage.getUserPoliciesDir() returns `~/.llxprt/`
     - Trusted folder requirement (no saves in untrusted dirs)
     - Admin policy override (priority 300+ always wins)
     - Granular command prefixes (not wildcards)
   - **Testing:**
     - Security audit checklist (Day 4)
     - Untrusted folder test (verify no "save" option)
     - Admin policy test (verify override works)

3. **Policy Priority System** - **MEDIUM-HIGH**
   - **Risks:**
     - User policies override admin policies (security bypass)
     - Settings excludes broken (wrong priority)
     - In-memory vs persistent priority conflict
   - **Mitigations:**
     - In-memory: priority 2.95 (below settings excludes at 200)
     - Persistent: priority 100/200 (below admin at 300+)
     - Existing policy engine handles priority correctly
   - **Testing:**
     - Test admin policy overrides user policy
     - Test settings excludes override user policy
     - Test in-memory + persistent both work

### MEDIUM RISK AREAS

1. **Tool Integration** (Step 3.x) - **MEDIUM**
   - **Risks:**
     - Missing `publishPolicyUpdate()` call in a tool
     - Wrong `getPolicyUpdateOptions()` implementation
     - Breaking existing tool behavior
   - **Mitigations:**
     - Systematic review of all 8 tool files
     - Grep for existing `ProceedAlways` checks (find injection points)
     - Existing tests ensure tool behavior unchanged
   - **Testing:**
     - Run all tool tests: `npm run test -w packages/core`
     - Manual test each tool type (shell, edit, MCP, info)

2. **UI Consistency** (Step 4.1) - **MEDIUM**
   - **Risks:**
     - Inconsistent option ordering across 4 locations
     - Option appears in untrusted folders (security)
     - Snapshot tests fail (not updated)
   - **Mitigations:**
     - Careful review of all 4 locations in ToolConfirmationMessage.tsx
     - Use `isTrustedFolder` check (already present)
     - Update snapshots systematically
   - **Testing:**
     - Snapshot tests (auto-update with `-u`)
     - Manual UI review (all 4 confirmation types)
     - Untrusted folder test (verify option hidden)

### LOW RISK AREAS

1. **Type System Changes** (Step 1.x) - **LOW**
   - **Risks:** Breaking type compatibility
   - **Mitigations:** Enum addition is backwards compatible, interface extension is optional fields
   - **Testing:** Typecheck passes

2. **Zed Integration** (Step 4.2) - **LOW**
   - **Risks:** Switch statement doesn't handle new outcome
   - **Mitigations:** Simple addition to existing case list
   - **Testing:** Typecheck passes (ensures exhaustiveness)

## Rollback Plan

### Immediate Rollback (if critical issues found)

**Trigger conditions:**
- Google telemetry accidentally introduced (CRITICAL)
- Data corruption in TOML files (HIGH)
- Policy engine broken (admin policies not enforced) (CRITICAL)
- Security bypass discovered (HIGH)

**Rollback steps:**

1. **Revert all code changes:**
   ```bash
   git revert <commit-hash>
   # OR
   git reset --hard HEAD~1  # if not pushed yet
   ```

2. **Remove enum value:**
   - `ToolConfirmationOutcome.ProceedAlwaysAndSave` (remove from `tool-confirmation-types.ts`)
   - Remove `persist`, `argsPattern`, `commandPrefix`, `mcpName` from `UpdatePolicy` interface

3. **Restore original `createPolicyUpdater`:**
   - Remove TOML persistence logic
   - Keep only in-memory rule addition

4. **Data cleanup:**
   - **DO NOT** delete `~/.llxprt/policies/auto-saved.toml`
   - Users can manually delete if needed
   - File will be ignored by old code (harmless)

5. **Verification:**
   ```bash
   npm run test
   npm run typecheck
   npm run build
   ```

### Partial Rollback Options

**Option A: Keep types, disable persistence**
- Keep `ProceedAlwaysAndSave` enum
- Keep `UpdatePolicy` interface extensions
- Remove TOML write logic from `createPolicyUpdater`
- Result: UI option present but does nothing (equivalent to `ProceedAlways`)
- Use case: Bug in TOML persistence, but types are stable

**Option B: Keep core, remove UI**
- Keep all core logic (config.ts, tools.ts)
- Remove UI options from ToolConfirmationMessage.tsx
- Remove Zed integration
- Result: Feature exists but not accessible to users
- Use case: UI bugs, but core logic is solid

**Option C: Feature flag**
- Add `LLXPRT_ENABLE_PERSISTENT_POLICIES=true` env var
- Wrap TOML persistence in `if (process.env.LLXPRT_ENABLE_PERSISTENT_POLICIES)`
- Default: disabled
- Use case: Gradual rollout, testing in production

### Data Recovery

**If TOML files get corrupted:**

```bash
# Backup existing file
cp ~/.llxprt/policies/auto-saved.toml ~/.llxprt/policies/auto-saved.toml.backup

# Try to fix with TOML validator
npm install -g toml-cli
toml-cli check ~/.llxprt/policies/auto-saved.toml

# If unfixable, start fresh
mv ~/.llxprt/policies/auto-saved.toml ~/.llxprt/policies/auto-saved.toml.corrupt
# LLxprt will create a new file on next save
```

## Testing Commands

```bash
# Full test suite
npm run test

# Type checking
npm run typecheck

# Specific test files
npm run test -w packages/core -- persistence.test.ts
npm run test -w packages/core -- config.test.ts
npm run test -w packages/core -- shell.test.ts
npm run test -w packages/core -- mcp-tool.test.ts
npm run test -w packages/cli -- ToolConfirmationMessage.test.tsx

# Update snapshots (after UI changes)
npm run test -w packages/cli -- -u ToolConfirmationMessage.test.tsx
npm run test -w packages/cli -- -u ToolGroupMessage.test.tsx

# Security audit
grep -rn "ClearcutLogger" packages/core/src/policy/
grep -rn "gemini-code-cli" packages/core/src/policy/
grep -rn "clearcut" packages/core/src/policy/

# Integration test (manual)
npm run build
npm start
# 1. Trigger tool confirmation
# 2. Select "save to policy" option
# 3. Exit and restart
# 4. Verify policy loaded (no confirmation for same tool)
# 5. Check TOML file: cat ~/.llxprt/policies/auto-saved.toml
```

## Commit Message

```
reimplement: persistent always-allow policies (upstream 5f298c17)

Adds support for persistent "Always Allow" policies that survive session
restarts, with granular support for shell command prefixes and MCP tools.

Key changes:
- New ProceedAlwaysAndSave confirmation outcome
- TOML persistence to ~/.llxprt/policies/auto-saved.toml
- Granular shell command matching via commandPrefix
- MCP server/tool specific policies via mcpName
- Base tool class helpers for policy updates
- UI options in confirmation dialogs (4 locations)
- Comprehensive test coverage (persistence.test.ts)
- Atomic TOML writes (tmp + rename pattern)

Security:
- All persistence is local TOML only, zero Google telemetry
- Only available in trusted folders (security requirement)
- Admin policies (priority 300+) always override user policies (100/200)
- Granular command prefixes prevent over-permissive wildcards

LLxprt adaptations:
- Uses ~/.llxprt/policies/ (not ~/.gemini-code-cli/)
- Handles google-web-fetch.ts + direct-web-fetch.ts (not web-fetch.ts)
- Skips smart-edit.ts (removed from LLxprt)
- Updated 4 UI confirmation types (edit, exec, info, MCP)

Based on upstream commit 5f298c17d7f6c3a1eabbeac249904cd1cf141352

Fixes #XXXX (insert issue number when available)
```

## Success Criteria

**All of these must pass before merging:**

### Code Quality
- [ ] All tests pass: `npm run test`
- [ ] Type checking passes: `npm run typecheck`
- [ ] No lint errors: `npm run lint`
- [ ] Build succeeds: `npm run build`

### Security Audit
- [ ] NO Google telemetry introduced (verified via grep)
- [ ] NO ClearcutLogger references (verified via grep)
- [ ] Storage.getUserPoliciesDir() returns `~/.llxprt/policies/`
- [ ] Trusted folder check prevents saves in untrusted dirs
- [ ] Admin policies override user policies (manual test)

### Functionality
- [ ] Auto-saved policies persist across sessions (manual test)
- [ ] Shell command prefixes work correctly (manual test)
- [ ] MCP tool policies work correctly (manual test)
- [ ] Multiple policies accumulate without conflicts (manual test)
- [ ] Corrupt TOML handled gracefully (manual test)
- [ ] Error handling is graceful (no crashes) (manual test)

### UI/UX
- [ ] "Save to policy" option appears in 4 confirmation types
- [ ] Option only appears in trusted folders
- [ ] Option numbering is correct
- [ ] Snapshot tests updated and passing

### Documentation
- [ ] User documentation added (README or docs/)
- [ ] CHANGELOG updated
- [ ] Security notes documented
- [ ] Policy priority system explained

### Edge Cases
- [ ] Atomic writes prevent corruption (manual test: kill during save)
- [ ] Concurrent sessions don't lose data (manual test: two sessions)
- [ ] Read-only filesystem handled (manual test: verify error message)
- [ ] Disk full handled (manual test: verify error message)

### Performance
- [ ] No performance regression (existing tests pass in same time)
- [ ] TOML file size reasonable (<10KB for 100 policies)
- [ ] Policy loading fast (<100ms for 100 policies)

## Notes

- This is a **HIGH RISK** change due to file I/O and security implications
- Security audit MUST verify zero Google telemetry before merging
- Test thoroughly in trusted AND untrusted folders
- Verify policy priority system doesn't break existing behavior
- Consider feature flag for gradual rollout (optional)
- Monitor for file permission issues on various platforms
- Document rollback procedure clearly

## Follow-Up Work (Future PRs)

**Not in scope for this PR, but could be added later:**

1. **Policy Management CLI:**
   - `llxprt policy list` - Show all saved policies
   - `llxprt policy remove <id>` - Delete specific policy
   - `llxprt policy clear` - Delete all policies
   - Would improve user control and visibility

2. **Dangerous Command Warnings:**
   - Detect destructive patterns (rm -rf, sudo, chmod 777)
   - Show secondary confirmation before saving
   - Would improve security for novice users

3. **Policy Deduplication:**
   - Detect and merge duplicate rules in TOML
   - Run on file load or via CLI command
   - Would keep file size manageable

4. **Policy Export/Import:**
   - `llxprt policy export policies.toml`
   - `llxprt policy import policies.toml`
   - Would enable policy sharing across machines

5. **Policy Audit Log:**
   - Log when policies are used (which rule matched)
   - Help users understand why confirmations are skipped
   - Would improve transparency
