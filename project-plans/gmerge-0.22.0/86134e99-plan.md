# Reimplementation Plan: Settings Validation with Zod (Upstream 86134e99)

**Upstream Commit**: 86134e9970a80c0e97e563616fc44192defb8de1  
**Author**: Nemo <imshuazi@126.com>  
**Date**: Fri Dec 12 14:30:34 2025 +0800  
**Title**: feat(settings-validation): add validation for settings schema (#12929)

---

## 1. Requirements

### R1: Validate Settings Structure with Zod Schema
Build a comprehensive Zod schema from LLxprt's `SETTINGS_SCHEMA` that validates all settings types: primitives (boolean, string, number), enums, arrays, objects with properties, objects with additionalProperties (maps), and reference types.

**Acceptance Criteria**:
- Valid settings pass validation (returns `{ success: true }`)
- Invalid settings fail validation with detailed error information
- Schema handles all 2023 lines of `SETTINGS_SCHEMA` definitions
- Schema supports optional fields (all settings are partial)
- Schema allows unknown keys via `.passthrough()` for migration compatibility

### R2: Reject Type Mismatches with Clear Error Messages
Detect and report type errors such as string instead of boolean, number in string array, object instead of primitive.

**Acceptance Criteria**:
- Type mismatches produce `invalid_type` error with path
- Error includes expected type and received type
- Error path is formatted as `property.nested[index]`

### R3: Support LLxprt-Specific Settings
Handle LLxprt's unique settings that don't exist in upstream Gemini-cli.

**Acceptance Criteria**:
- `emojifilter` enum: `'allowed' | 'auto' | 'warn' | 'error'`
- `lsp` union: `false | LspConfig` (boolean OR object)
- `sandbox` union: `boolean | string`
- `fileFiltering` object with nested properties
- `subagents` object with `asyncEnabled`, `maxAsync`
- `security` object with `folderTrust`, `trustedFolders`
- `extensions` object with `disabled` array
- `hooks` record of `HookDefinition[]`
- All existing tests continue to pass

### R4: Integrate Validation into Settings Loading
Validate settings after JSON parsing and before merging/usage.

**Acceptance Criteria**:
- Validation runs for all settings files: system, system defaults, user, workspace
- Validation happens after JSON parsing and legacy theme migration
- Validation happens before returning from `loadSettings()`
- Validation errors throw `FatalConfigError` with formatted message
- Existing `FatalConfigError` instances are preserved (not wrapped)

### R5: Format Validation Errors for End Users
Provide helpful error messages with file path, error location, expected vs received types, and documentation link.

**Acceptance Criteria**:
- Error message includes file path (e.g., `~/.llxprt/settings.json`)
- Error lists affected paths (e.g., `ui.theme`, `allowedTools[1]`)
- Error shows expected vs received types for `invalid_type`
- Error limits display to 5 issues with "...and N more errors" summary
- Error includes documentation link

### R6: Maintain 100% Test Coverage
All validation logic must have comprehensive behavioral tests.

**Acceptance Criteria**:
- Tests for valid settings (primitives, nested objects, arrays, enums, refs)
- Tests for invalid types (all major type mismatches)
- Tests for LLxprt-specific settings (emojifilter, lsp, sandbox, etc.)
- Tests for error formatting (path display, type messages, error limit)
- Tests for schema structure (optional fields, passthrough)
- All existing settings tests continue to pass

---

## 2. LLxprt Touchpoints

### 2.1 Current State Analysis

**File: `packages/cli/src/config/settingsSchema.ts` (2023 lines)**

Key structures:
```typescript
// Line 125-158
export interface SettingsSchema {
  [key: string]: SettingDefinition;
}

// Line 159-1674: SETTINGS_SCHEMA object
export const SETTINGS_SCHEMA = {
  accessibility: { type: 'object', properties: { ... } },
  checkpointing: { type: 'object', properties: { ... } },
  lsp: { type: 'boolean' | 'object', ref: 'BooleanOrLspConfig', ... },
  emojifilter: { type: 'enum', options: [...], ... },
  fileFiltering: { type: 'object', properties: { ... } },
  sandbox: { type: 'boolean' | 'string', ref: 'BooleanOrString', ... },
  // ... 100+ more settings
  ui: { type: 'object', properties: { ... } },
  tools: { type: 'object', properties: { ... } },
  mcpServers: { type: 'object', additionalProperties: { ref: 'MCPServerConfig' } },
  // ... many more
};

// Line 1679-2000: SETTINGS_SCHEMA_DEFINITIONS
export const SETTINGS_SCHEMA_DEFINITIONS: Record<string, SettingsJsonSchemaDefinition> = {
  MCPServerConfig: { type: 'object', properties: { command: ..., args: ..., env: ... } },
  TelemetrySettings: { type: 'object', properties: { enabled: ..., target: ... } },
  BugCommandSettings: { type: 'object', properties: { urlTemplate: ... }, required: [...] },
  SummarizeToolOutputSettings: { type: 'object', properties: { tokenBudget: ... } },
  CustomTheme: { type: 'object', properties: { ... }, required: ['type', 'name'] },
  StringOrStringArray: { anyOf: [{ type: 'string' }, { type: 'array', items: ... }] },
  BooleanOrString: { anyOf: [{ type: 'boolean' }, { type: 'string' }] },
  BooleanOrLspConfig: { anyOf: [{ type: 'boolean', const: false }, { type: 'object', properties: ... }] },
};

// Line 2017
export type Settings = InferSettings<SettingsSchemaType>;
```

**Top-level settings keys** (partial list):
- `accessibility`, `checkpointing`, `lsp`, `emojifilter`, `fileFiltering`
- `disableAutoUpdate`, `shouldUseNodePtyShell`, `allowPtyThemeOverride`
- `useExternalAuth`, `sandbox`, `coreTools`, `allowedTools`, `excludeTools`, `defaultDisabledTools`, `coreToolSettings`
- `toolDiscoveryCommand`, `toolCallCommand`, `toolCallProcessingMode`
- `mcpServerCommand`, `mcpServers`, `sessionRetention`, `output`, `ui`, `ide`
- `showStatusInTitle`, `hideCWD`, `hideSandboxStatus`, `hideModelInfo` (legacy UI keys)
- `allowMCPServers`, `excludeMCPServers`, `telemetry`, `bugCommand`, `summarizeToolOutput`
- `tools`, `mcp`, `subagents`, `security`, `model`, `context`, `globalMemory`, `folderTrust`, `folderTrustFeature`
- `extensions`, `hooks`, and 80+ more

**File: `packages/cli/src/config/settings.ts` (846 lines)**

Current loading flow (line 590-745):
```typescript
export function loadSettings(
  workspaceDir: string,
  ...
): LoadedSettings {
  // 1. Read system settings from file (line 598-608)
  // 2. Read system defaults from file (line 610-624)
  // 3. Read user settings from file (line 626-642)
  // 4. Legacy theme migration for user settings (line 633-640)
  // 5. Read workspace settings from file (line 647-679)
  // 6. Legacy theme migration for workspace settings (line 662-674)
  // 7. Check folder trust (line 681-699)
  // 8. Merge settings for temp object (line 700-707)
  // 9. Load environment variables (line 712)
  // 10. Resolve env vars in settings (line 715-717)
  // 11. Throw FatalConfigError if errors exist (line 721-729)
  // 12. Migrate legacy interactive shell setting (line 731-737)
  // 13. Return LoadedSettings instance (line 739-757)
}
```

**Insertion point for validation**: After step 6 (legacy theme migration) and before step 11 (error throwing). This ensures all settings files are parsed and migrated before validation.

**Error handling** (line 721-729):
```typescript
if (settingsErrors.length > 0) {
  const errorMessages = settingsErrors.map(
    (error) => `Error in ${error.path}: ${error.message}`,
  );
  throw new FatalConfigError(
    `${errorMessages.join('\n')}\nPlease fix the configuration file(s) and try again.`,
  );
}
```

**Current FatalConfigError usage**:
- Imported from `@vybestack/llxprt-code-core` (line 14)
- Used in `settings.ts` (line 729)
- Used in `trustedFolders.ts` (line 205)
- Caught in `settings.test.ts` (lines 866, 1707, 1717)

### 2.2 Validation Integration Points

**Location 1: After user settings parsing** (line 642, inside `loadSettings()`)
- After JSON parsing
- After legacy theme migration (`VS` → `DefaultLight.name`, `VS2015` → `DefaultDark.name`)
- Before merging

**Location 2: After workspace settings parsing** (line 679, inside `loadSettings()`)
- After JSON parsing
- After legacy theme migration
- Before merging

**Location 3: Catch block preservation** (line 609, 625, 643, 680)
- Currently catches JSON parse errors and adds to `settingsErrors` array
- Need to preserve `FatalConfigError` instances without wrapping

**New validation flow**:
```typescript
// After parsing user/workspace settings:
const validationResult = validateSettings(settingsObject);
if (!validationResult.success && validationResult.error) {
  const errorMessage = formatValidationError(validationResult.error, filePath);
  throw new FatalConfigError(errorMessage);
}
```

**Catch block update**:
```typescript
} catch (error: unknown) {
  // Preserve FatalConfigError with formatted validation messages
  if (error instanceof FatalConfigError) {
    throw error;
  }
  settingsErrors.push({
    message: getErrorMessage(error),
    path: filePath,
  });
}
```

---

## 3. Existing Tests to Adjust

### 3.1 Current Test Files

**`packages/cli/src/config/settingsSchema.test.ts`** (293 lines)
- Tests `SETTINGS_SCHEMA` structure
- Tests all settings have required fields
- Tests all refs in definitions have corresponding entries
- Tests all definitions are referenced (no orphans)
- Tests specific settings: `accessibility`, `checkpointing`, `fileFiltering`, `includeDirectories`, `folderTrustFeature`, `defaultDisabledTools`
- **NO CHANGES NEEDED** - these test schema structure, not validation

**`packages/cli/src/config/settings.test.ts`** (1746 lines)
- Tests settings loading, merging, migration
- Tests `FatalConfigError` on invalid JSON (line 866, 1707, 1717)
- **POTENTIAL IMPACT**: Invalid JSON tests may need updates if validation errors change message format
- **Action**: Run tests after implementation to verify compatibility

**`packages/cli/src/config/settings.env.test.ts`** (147 lines)
- Tests environment variable resolution
- **NO CHANGES NEEDED** - env resolution happens after validation

**Other test files**:
- `settingsStorage.test.ts`, `settingsIntegration.test.ts`, `settingsPrompt.test.ts`
- **NO CHANGES NEEDED** - these test extension settings, not core validation

### 3.2 Test Verification Strategy

1. **Run existing tests first**: `npm run test --workspace @vybestack/llxprt-code-cli -- settingsSchema.test.ts settings.test.ts`
2. **Identify failures**: Look for tests expecting specific error formats
3. **Update if needed**: Adjust error message assertions to match new validation format
4. **Add new tests**: Create `settings-validation.test.ts` with comprehensive validation tests

---

## 4. New Tests (RED Phase)

**File: `packages/cli/src/config/settings-validation.test.ts`** (new file, ~450 lines)

### 4.1 Test Structure

```typescript
/**
 * @license
 * Copyright 2025 Vybestack LLC
 * SPDX-License-Identifier: Apache-2.0
 */

/// <reference types="vitest/globals" />

import { describe, it, expect } from 'vitest';
import {
  validateSettings,
  formatValidationError,
  settingsZodSchema,
} from './settings-validation.js';
import { z } from 'zod';

describe('settings-validation', () => {
  describe('validateSettings', () => {
    // Valid settings tests (10 tests)
    // Invalid type tests (15 tests)
    // LLxprt-specific tests (10 tests)
  });

  describe('formatValidationError', () => {
    // Error formatting tests (10 tests)
  });

  describe('settingsZodSchema', () => {
    // Schema structure tests (3 tests)
  });
});
```

### 4.2 Valid Settings Tests (10 tests)

```typescript
describe('validateSettings - valid settings', () => {
  it('should accept empty settings object', () => {
    const result = validateSettings({});
    expect(result.success).toBe(true);
  });

  it('should accept valid flat boolean setting', () => {
    const validSettings = { disableAutoUpdate: false };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept valid flat string setting', () => {
    const validSettings = { sandbox: '/path/to/sandbox' };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept valid flat number setting', () => {
    const validSettings = { ptyScrollbackLimit: 1000 };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept valid string array', () => {
    const validSettings = { allowedTools: ['git', 'npm', 'node'] };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept valid nested object', () => {
    const validSettings = {
      ui: { theme: 'DefaultDark', hideWindowTitle: true },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept valid deeply nested object', () => {
    const validSettings = {
      ui: {
        footer: {
          hideCWD: false,
          hideSandboxStatus: true,
          hideModelInfo: false,
        },
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept valid object with additionalProperties (mcpServers)', () => {
    const validSettings = {
      mcpServers: {
        'my-server': {
          command: 'node',
          args: ['server.js'],
          env: { NODE_ENV: 'production' },
        },
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept unknown top-level keys (passthrough for migration)', () => {
    const validSettings = {
      unknownKey: 'some value',
      anotherUnknown: 123,
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept complex valid settings', () => {
    const validSettings = {
      disableAutoUpdate: false,
      emojifilter: 'auto',
      allowedTools: ['git', 'npm'],
      ui: {
        theme: 'DefaultDark',
        hideWindowTitle: true,
        footer: { hideCWD: false },
      },
      mcpServers: {
        server1: { command: 'node', args: ['index.js'] },
      },
      accessibility: {
        disableLoadingPhrases: true,
        screenReader: false,
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });
});
```

### 4.3 Invalid Type Tests (15 tests)

```typescript
describe('validateSettings - invalid types', () => {
  it('should reject string instead of boolean', () => {
    const invalidSettings = { disableAutoUpdate: 'yes' };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    expect(result.error).toBeDefined();
    if (result.error) {
      expect(result.error.issues[0]?.path).toEqual(['disableAutoUpdate']);
      expect(result.error.issues[0]?.code).toBe('invalid_type');
    }
  });

  it('should reject number instead of string', () => {
    const invalidSettings = { sandbox: 123 };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    expect(result.error).toBeDefined();
    if (result.error) {
      expect(result.error.issues[0]?.path).toEqual(['sandbox']);
      expect(result.error.issues[0]?.code).toBe('invalid_type');
    }
  });

  it('should reject boolean instead of number', () => {
    const invalidSettings = { ptyScrollbackLimit: true };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
  });

  it('should reject number in string array', () => {
    const invalidSettings = { allowedTools: ['git', 123, 'npm'] };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      expect(result.error.issues[0]?.path).toEqual(['allowedTools', 1]);
    }
  });

  it('should reject object in string array', () => {
    const invalidSettings = { allowedTools: ['git', { tool: 'npm' }] };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
  });

  it('should reject string instead of object', () => {
    const invalidSettings = { ui: 'invalid' };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      expect(result.error.issues[0]?.path).toEqual(['ui']);
    }
  });

  it('should reject invalid nested property type', () => {
    const invalidSettings = { ui: { theme: 123 } };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      expect(result.error.issues[0]?.path).toEqual(['ui', 'theme']);
    }
  });

  it('should reject invalid deeply nested type', () => {
    const invalidSettings = {
      ui: { footer: { hideCWD: 'yes' } },
    };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      expect(result.error.issues[0]?.path).toEqual(['ui', 'footer', 'hideCWD']);
    }
  });

  it('should reject invalid mcpServers structure', () => {
    const invalidSettings = {
      mcpServers: {
        'my-server': {
          command: 123, // Should be string
          args: ['arg1'],
        },
      },
    };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      const issue = result.error.issues.find((i) => i.path.includes('command'));
      expect(issue).toBeDefined();
      expect(issue?.code).toBe('invalid_type');
    }
  });

  it('should reject array instead of object', () => {
    const invalidSettings = { accessibility: ['option1', 'option2'] };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
  });

  it('should reject null value for required type', () => {
    const invalidSettings = { disableAutoUpdate: null };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
  });

  it('should reject undefined is allowed (all fields optional)', () => {
    // This test verifies that undefined is acceptable (not an error)
    const settingsWithUndefined = { disableAutoUpdate: undefined };
    const result = validateSettings(settingsWithUndefined);
    expect(result.success).toBe(true);
  });

  it('should reject multiple type errors in one settings object', () => {
    const invalidSettings = {
      disableAutoUpdate: 'yes',
      ptyScrollbackLimit: 'not-a-number',
      allowedTools: [123, 456],
    };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      expect(result.error.issues.length).toBeGreaterThan(1);
    }
  });

  it('should reject invalid customThemes structure', () => {
    const invalidSettings = {
      ui: {
        customThemes: {
          'my-theme': {
            type: 'custom',
            // Missing required 'name' field
            text: { primary: '#ffffff' },
          },
        },
      },
    };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      const issue = result.error.issues.find(
        (i) => i.code === 'invalid_type' && i.message.includes('Required')
      );
      expect(issue).toBeDefined();
    }
  });

  it('should provide detailed error for complex nested validation failure', () => {
    const invalidSettings = {
      mcpServers: {
        server1: {
          command: 'valid-command',
          args: ['arg1'],
          env: { VAR1: 123 }, // Should be string
        },
      },
    };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      const issue = result.error.issues.find((i) => i.path.includes('env'));
      expect(issue).toBeDefined();
    }
  });
});
```

### 4.4 LLxprt-Specific Settings Tests (10 tests)

```typescript
describe('validateSettings - LLxprt-specific settings', () => {
  it('should accept valid emojifilter enum values', () => {
    for (const value of ['allowed', 'auto', 'warn', 'error']) {
      const result = validateSettings({ emojifilter: value });
      expect(result.success).toBe(true);
    }
  });

  it('should reject invalid emojifilter value', () => {
    const invalidSettings = { emojifilter: 'invalid-mode' };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
    if (result.error) {
      expect(result.error.issues[0]?.path).toEqual(['emojifilter']);
    }
  });

  it('should accept lsp as boolean false', () => {
    const validSettings = { lsp: false };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept lsp as object', () => {
    const validSettings = {
      lsp: {
        servers: [{ id: 'ts-server', command: 'typescript-language-server' }],
        includeSeverities: ['error', 'warning'],
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should reject lsp as boolean true (only false or object allowed)', () => {
    const invalidSettings = { lsp: true };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
  });

  it('should reject lsp as string', () => {
    const invalidSettings = { lsp: 'enabled' };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);
  });

  it('should accept sandbox as boolean', () => {
    const result1 = validateSettings({ sandbox: true });
    const result2 = validateSettings({ sandbox: false });
    expect(result1.success).toBe(true);
    expect(result2.success).toBe(true);
  });

  it('should accept sandbox as string path', () => {
    const validSettings = { sandbox: '/usr/bin/sandbox' };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept fileFiltering nested object', () => {
    const validSettings = {
      fileFiltering: {
        respectGitIgnore: true,
        respectLlxprtIgnore: false,
        enableRecursiveFileSearch: true,
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept subagents configuration', () => {
    const validSettings = {
      subagents: {
        asyncEnabled: true,
        maxAsync: 5,
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept security settings', () => {
    const validSettings = {
      security: {
        folderTrust: true,
        trustedFolders: ['/home/user/projects', '/workspace'],
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept extensions with disabled array', () => {
    const validSettings = {
      extensions: {
        disabled: ['ext1', 'ext2'],
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });

  it('should accept hooks configuration', () => {
    const validSettings = {
      hooks: {
        'session-start': [
          {
            name: 'init-hook',
            command: 'echo "Starting session"',
          },
        ],
      },
    };
    const result = validateSettings(validSettings);
    expect(result.success).toBe(true);
  });
});
```

### 4.5 Error Formatting Tests (10 tests)

```typescript
describe('formatValidationError', () => {
  it('should format error with file path and helpful message', () => {
    const invalidSettings = { disableAutoUpdate: 'yes' };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(
        result.error,
        '/path/to/settings.json'
      );

      expect(formatted).toContain('/path/to/settings.json');
      expect(formatted).toContain('disableAutoUpdate');
      expect(formatted).toContain('Expected:');
      expect(formatted).toContain('but received:');
      expect(formatted).toContain('Please fix the configuration and try again.');
    }
  });

  it('should format nested property path correctly', () => {
    const invalidSettings = { ui: { theme: 123 } };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(result.error, 'settings.json');
      expect(formatted).toContain('ui.theme');
    }
  });

  it('should format array index path correctly', () => {
    const invalidSettings = { allowedTools: ['git', 123, 'npm'] };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(result.error, 'settings.json');
      expect(formatted).toContain('allowedTools[1]');
    }
  });

  it('should format deeply nested object path correctly', () => {
    const invalidSettings = {
      mcpServers: {
        'my-server': { command: 123 },
      },
    };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(result.error, 'settings.json');
      expect(formatted).toContain('mcpServers');
      expect(formatted).toContain('command');
    }
  });

  it('should include expected vs received for invalid_type errors', () => {
    const invalidSettings = { disableAutoUpdate: 'yes' };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(result.error, 'settings.json');
      expect(formatted).toContain('Expected: boolean');
      expect(formatted).toContain('but received: string');
    }
  });

  it('should list all validation errors when multiple exist', () => {
    const invalidSettings = {
      disableAutoUpdate: 'yes',
      ptyScrollbackLimit: 'not-a-number',
    };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(result.error, 'settings.json');
      expect(formatted).toContain('disableAutoUpdate');
      expect(formatted).toContain('ptyScrollbackLimit');
    }
  });

  it('should limit displayed errors to 5', () => {
    const invalidSettings = {
      allowedTools: [1, 2, 3, 4, 5, 6, 7], // 7 invalid items
    };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(result.error, 'settings.json');
      expect(formatted).toContain('allowedTools[0]');
      expect(formatted).toContain('allowedTools[4]');
      expect(formatted).not.toContain('allowedTools[5]');
      expect(formatted).not.toContain('allowedTools[6]');
      expect(formatted).toContain('...and 2 more errors.');
    }
  });

  it('should include documentation link', () => {
    const invalidSettings = { disableAutoUpdate: 'yes' };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(result.error, 'settings.json');
      expect(formatted).toContain('https://');
      expect(formatted).toContain('configuration');
    }
  });

  it('should handle root-level error path', () => {
    // Test with a setting that might error at root
    const invalidSettings = { invalidTopLevel: 123 };
    // This will pass due to passthrough, so create a real error:
    const invalidSettingsActual = { ui: 'not-an-object' };
    const result = validateSettings(invalidSettingsActual);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(result.error, 'settings.json');
      expect(formatted).toContain('Error in: ui');
    }
  });

  it('should use proper formatting for settings file path', () => {
    const invalidSettings = { disableAutoUpdate: 'yes' };
    const result = validateSettings(invalidSettings);
    expect(result.success).toBe(false);

    if (result.error) {
      const formatted = formatValidationError(
        result.error,
        '~/.llxprt/settings.json'
      );
      expect(formatted).toContain('~/.llxprt/settings.json');
    }
  });
});
```

### 4.6 Schema Structure Tests (3 tests)

```typescript
describe('settingsZodSchema', () => {
  it('should be a valid Zod object schema', () => {
    expect(settingsZodSchema).toBeInstanceOf(z.ZodObject);
  });

  it('should have all fields as optional', () => {
    // Empty object should be valid
    const result = settingsZodSchema.safeParse({});
    expect(result.success).toBe(true);
  });

  it('should allow passthrough for unknown keys', () => {
    const result = settingsZodSchema.safeParse({
      unknownKey1: 'value1',
      unknownKey2: 123,
      unknownKey3: true,
    });
    expect(result.success).toBe(true);
  });
});
```

**Total: ~48 tests covering all requirements**

---

## 5. Implementation (GREEN Phase)

### 5.1 Create Validation Module

**File: `packages/cli/src/config/settings-validation.ts`** (new file, ~350 lines)

```typescript
/**
 * @license
 * Copyright 2025 Vybestack LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import { z } from 'zod';
import {
  getSettingsSchema,
  type SettingDefinition,
  type SettingCollectionDefinition,
  SETTINGS_SCHEMA_DEFINITIONS,
} from './settingsSchema.js';

/**
 * Builds a Zod schema from JSON-schema-like definitions used in
 * SETTINGS_SCHEMA_DEFINITIONS.
 *
 * Handles: type, anyOf, properties, additionalProperties, required, enum, items
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
function buildZodSchemaFromJsonSchema(def: any): z.ZodTypeAny {
  if (def.anyOf) {
    return z.union(
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      def.anyOf.map((d: any) => buildZodSchemaFromJsonSchema(d)) as any,
    );
  }

  if (def.type === 'string') {
    if (def.enum) return z.enum(def.enum as [string, ...string[]]);
    return z.string();
  }
  if (def.type === 'number') return z.number();
  if (def.type === 'boolean') {
    // Handle boolean const values (e.g., const: false)
    if ('const' in def) {
      return z.literal(def.const);
    }
    return z.boolean();
  }

  if (def.type === 'array') {
    if (def.items) {
      return z.array(buildZodSchemaFromJsonSchema(def.items));
    }
    return z.array(z.unknown());
  }

  if (def.type === 'object') {
    let schema;
    if (def.properties) {
      const shape: Record<string, z.ZodTypeAny> = {};
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      for (const [key, propDef] of Object.entries(def.properties) as any) {
        let propSchema = buildZodSchemaFromJsonSchema(propDef);
        if (
          def.required &&
          Array.isArray(def.required) &&
          def.required.includes(key)
        ) {
          // keep it required
        } else {
          propSchema = propSchema.optional();
        }
        shape[key] = propSchema;
      }
      schema = z.object(shape).passthrough();
    } else {
      schema = z.object({}).passthrough();
    }

    if (def.additionalProperties === false) {
      schema = schema.strict();
    } else if (typeof def.additionalProperties === 'object') {
      schema = schema.catchall(
        buildZodSchemaFromJsonSchema(def.additionalProperties),
      );
    }

    return schema;
  }

  return z.unknown();
}

/**
 * Builds a Zod enum schema from options array.
 */
function buildEnumSchema(
  options: ReadonlyArray<{ value: string | number | boolean; label: string }>,
): z.ZodTypeAny {
  if (!options || options.length === 0) {
    throw new Error(
      'Enum type must have options defined. Check your settings schema definition.',
    );
  }
  const values = options.map((opt) => opt.value);
  if (values.every((v) => typeof v === 'string')) {
    return z.enum(values as [string, ...string[]]);
  } else if (values.every((v) => typeof v === 'number')) {
    return z.union(
      values.map((v) => z.literal(v)) as [
        z.ZodLiteral<number>,
        z.ZodLiteral<number>,
        ...Array<z.ZodLiteral<number>>,
      ],
    );
  } else {
    return z.union(
      values.map((v) => z.literal(v)) as [
        z.ZodLiteral<unknown>,
        z.ZodLiteral<unknown>,
        ...Array<z.ZodLiteral<unknown>>,
      ],
    );
  }
}

/**
 * Builds a Zod object shape from properties record.
 */
function buildObjectShapeFromProperties(
  properties: Record<string, SettingDefinition>,
): Record<string, z.ZodTypeAny> {
  const shape: Record<string, z.ZodTypeAny> = {};
  for (const [key, childDef] of Object.entries(properties)) {
    shape[key] = buildZodSchemaFromDefinition(childDef);
  }
  return shape;
}

/**
 * Builds a Zod schema for primitive types (string, number, boolean).
 */
function buildPrimitiveSchema(
  type: 'string' | 'number' | 'boolean',
): z.ZodTypeAny {
  switch (type) {
    case 'string':
      return z.string();
    case 'number':
      return z.number();
    case 'boolean':
      return z.boolean();
    default:
      return z.unknown();
  }
}

const REF_SCHEMAS: Record<string, z.ZodTypeAny> = {};

// Initialize REF_SCHEMAS from SETTINGS_SCHEMA_DEFINITIONS
for (const [name, def] of Object.entries(SETTINGS_SCHEMA_DEFINITIONS)) {
  REF_SCHEMAS[name] = buildZodSchemaFromJsonSchema(def);
}

/**
 * Recursively builds a Zod schema from a SettingDefinition.
 */
function buildZodSchemaFromDefinition(
  definition: SettingDefinition,
): z.ZodTypeAny {
  let baseSchema: z.ZodTypeAny;

  // Handle refs using registry
  if (definition.ref && definition.ref in REF_SCHEMAS) {
    return REF_SCHEMAS[definition.ref].optional();
  }

  switch (definition.type) {
    case 'string':
    case 'number':
    case 'boolean':
      baseSchema = buildPrimitiveSchema(definition.type);
      break;

    case 'enum': {
      baseSchema = buildEnumSchema(definition.options!);
      break;
    }

    case 'array':
      if (definition.items) {
        const itemSchema = buildZodSchemaFromCollection(definition.items);
        baseSchema = z.array(itemSchema);
      } else {
        baseSchema = z.array(z.unknown());
      }
      break;

    case 'object':
      if (definition.properties) {
        const shape = buildObjectShapeFromProperties(definition.properties);
        baseSchema = z.object(shape).passthrough();

        if (definition.additionalProperties) {
          const additionalSchema = buildZodSchemaFromCollection(
            definition.additionalProperties,
          );
          baseSchema = z.object(shape).catchall(additionalSchema);
        }
      } else if (definition.additionalProperties) {
        const valueSchema = buildZodSchemaFromCollection(
          definition.additionalProperties,
        );
        baseSchema = z.record(z.string(), valueSchema);
      } else {
        baseSchema = z.record(z.string(), z.unknown());
      }
      break;

    default:
      baseSchema = z.unknown();
  }

  // Make all fields optional since settings are partial
  return baseSchema.optional();
}

/**
 * Builds a Zod schema from a SettingCollectionDefinition.
 */
function buildZodSchemaFromCollection(
  collection: SettingCollectionDefinition,
): z.ZodTypeAny {
  if (collection.ref && collection.ref in REF_SCHEMAS) {
    return REF_SCHEMAS[collection.ref];
  }

  switch (collection.type) {
    case 'string':
    case 'number':
    case 'boolean':
      return buildPrimitiveSchema(collection.type);

    case 'enum': {
      return buildEnumSchema(collection.options!);
    }

    case 'array':
      if (collection.properties) {
        const shape = buildObjectShapeFromProperties(collection.properties);
        return z.array(z.object(shape));
      }
      return z.array(z.unknown());

    case 'object':
      if (collection.properties) {
        const shape = buildObjectShapeFromProperties(collection.properties);
        return z.object(shape).passthrough();
      }
      return z.record(z.string(), z.unknown());

    default:
      return z.unknown();
  }
}

/**
 * Builds the complete Zod schema for Settings from SETTINGS_SCHEMA.
 */
function buildSettingsZodSchema(): z.ZodObject<Record<string, z.ZodTypeAny>> {
  const schema = getSettingsSchema();
  const shape: Record<string, z.ZodTypeAny> = {};

  for (const [key, definition] of Object.entries(schema)) {
    shape[key] = buildZodSchemaFromDefinition(definition);
  }

  return z.object(shape).passthrough();
}

export const settingsZodSchema = buildSettingsZodSchema();

/**
 * Validates settings data against the Zod schema.
 */
export function validateSettings(data: unknown): {
  success: boolean;
  data?: unknown;
  error?: z.ZodError;
} {
  const result = settingsZodSchema.safeParse(data);
  return result;
}

/**
 * Format a Zod error into a helpful error message for end users.
 */
export function formatValidationError(
  error: z.ZodError,
  filePath: string,
): string {
  const lines: string[] = [];
  lines.push(`Invalid configuration in ${filePath}:`);
  lines.push('');

  const MAX_ERRORS_TO_DISPLAY = 5;
  const displayedIssues = error.issues.slice(0, MAX_ERRORS_TO_DISPLAY);

  for (const issue of displayedIssues) {
    const path = issue.path.reduce(
      (acc, curr) =>
        typeof curr === 'number'
          ? `${acc}[${curr}]`
          : `${acc ? acc + '.' : ''}${curr}`,
      '',
    );
    lines.push(`Error in: ${path || '(root)'}`);
    lines.push(`    ${issue.message}`);

    if (issue.code === 'invalid_type') {
      const expected = issue.expected;
      const received = issue.received;
      lines.push(`Expected: ${expected}, but received: ${received}`);
    }
    lines.push('');
  }

  if (error.issues.length > MAX_ERRORS_TO_DISPLAY) {
    lines.push(
      `...and ${error.issues.length - MAX_ERRORS_TO_DISPLAY} more errors.`,
    );
    lines.push('');
  }

  lines.push('Please fix the configuration and try again.');
  lines.push(
    'See: https://github.com/vybestack/llxprt-code/blob/main/docs/cli/configuration.md',
  );

  return lines.join('\n');
}
```

### 5.2 Integrate Validation into settings.ts

**File: `packages/cli/src/config/settings.ts`** (modifications)

**Step 1: Add imports** (at top, around line 32)

```typescript
import {
  validateSettings,
  formatValidationError,
} from './settings-validation.js';
```

**Step 2: Add validation helper function** (before `loadSettings`, around line 580)

```typescript
/**
 * Validates a settings object and throws FatalConfigError on validation failure.
 */
function validateSettingsOrThrow(
  settingsObject: unknown,
  filePath: string,
): void {
  const validationResult = validateSettings(settingsObject);
  if (!validationResult.success && validationResult.error) {
    const errorMessage = formatValidationError(
      validationResult.error,
      filePath,
    );
    throw new FatalConfigError(errorMessage);
  }
}
```

**Step 3: Add validation calls in loadSettings** (4 locations)

**Location 1: After system settings parsing** (around line 608, inside try block)

```typescript
// After line 608:
if (fs.existsSync(systemSettingsPath)) {
  const content = fs.readFileSync(systemSettingsPath, 'utf-8');
  systemSettings = JSON.parse(stripJsonComments(content)) as Settings;
  validateSettingsOrThrow(systemSettings, systemSettingsPath); // ADD THIS
}
```

**Location 2: After system defaults parsing** (around line 624, inside try block)

```typescript
// After line 624:
if (fs.existsSync(systemDefaultsPath)) {
  const content = fs.readFileSync(systemDefaultsPath, 'utf-8');
  systemDefaultSettings = JSON.parse(stripJsonComments(content)) as Settings;
  validateSettingsOrThrow(systemDefaultSettings, systemDefaultsPath); // ADD THIS
}
```

**Location 3: After user settings parsing and theme migration** (around line 642, inside try block)

```typescript
// After line 642 (after theme migration):
if (userSettings.ui?.theme && userSettings.ui.theme === 'VS') {
  userSettings.ui.theme = DefaultLight.name;
} else if (userSettings.ui?.theme && userSettings.ui.theme === 'VS2015') {
  userSettings.ui.theme = DefaultDark.name;
}
validateSettingsOrThrow(userSettings, userSettingsPath); // ADD THIS
```

**Location 4: After workspace settings parsing and theme migration** (around line 679, inside try block)

```typescript
// After line 679 (after theme migration):
if (workspaceSettings.ui?.theme && workspaceSettings.ui.theme === 'VS') {
  workspaceSettings.ui.theme = DefaultLight.name;
} else if (
  workspaceSettings.ui?.theme &&
  workspaceSettings.ui.theme === 'VS2015'
) {
  workspaceSettings.ui.theme = DefaultDark.name;
}
validateSettingsOrThrow(workspaceSettings, workspaceSettingsPath); // ADD THIS
```

**Step 4: Preserve FatalConfigError in catch blocks** (4 locations)

Update all catch blocks (around lines 609, 625, 643, 680) to preserve `FatalConfigError`:

```typescript
} catch (error: unknown) {
  // Preserve FatalConfigError with formatted validation messages
  if (error instanceof FatalConfigError) {
    throw error;
  }
  settingsErrors.push({
    message: getErrorMessage(error),
    path: filePath,
  });
}
```

**Complete example for user settings block** (around line 626-643):

```typescript
try {
  if (fs.existsSync(userSettingsPath)) {
    const content = fs.readFileSync(userSettingsPath, 'utf-8');
    userSettings = JSON.parse(stripJsonComments(content)) as Settings;
    if (userSettings.ui?.theme && userSettings.ui.theme === 'VS') {
      userSettings.ui.theme = DefaultLight.name;
    } else if (userSettings.ui?.theme && userSettings.ui.theme === 'VS2015') {
      userSettings.ui.theme = DefaultDark.name;
    }
    validateSettingsOrThrow(userSettings, userSettingsPath);
  }
} catch (error: unknown) {
  // Preserve FatalConfigError with formatted validation messages
  if (error instanceof FatalConfigError) {
    throw error;
  }
  settingsErrors.push({
    message: getErrorMessage(error),
    path: userSettingsPath,
  });
}
```

---

## 6. Refactor Phase

### 6.1 Evaluate Refactoring Opportunities

After GREEN phase, assess:

1. **DRY opportunities**: Is there duplication in `buildZodSchemaFromDefinition` and `buildZodSchemaFromCollection`?
   - **Decision**: Keep separate - they handle different schema types (SettingDefinition vs SettingCollectionDefinition)

2. **Naming clarity**: Are function names self-documenting?
   - **Decision**: Current names are clear (`buildZodSchemaFromJsonSchema`, `validateSettingsOrThrow`)

3. **Type safety**: Can we improve type inference?
   - **Decision**: Already using TypeScript strict mode with proper types

4. **Performance**: Is schema building efficient?
   - **Decision**: Schema built once at module load (exported const) - already optimal

5. **Error messages**: Are they user-friendly?
   - **Decision**: Already include file path, property path, expected vs received, doc link

**Conclusion**: No refactoring needed - implementation is clean and follows RULES.md principles.

---

## 7. Verification

### 7.1 Test Execution

```bash
# Run new validation tests
npm run test --workspace @vybestack/llxprt-code-cli -- settings-validation.test.ts

# Run existing settings tests to verify no regressions
npm run test --workspace @vybestack/llxprt-code-cli -- settingsSchema.test.ts
npm run test --workspace @vybestack/llxprt-code-cli -- settings.test.ts

# Run all CLI tests
npm run test --workspace @vybestack/llxprt-code-cli
```

### 7.2 Manual Testing

**Test 1: Valid settings file**

```bash
# Create valid user settings
cat > ~/.llxprt/settings.json << 'EOF'
{
  "disableAutoUpdate": false,
  "emojifilter": "auto",
  "allowedTools": ["git", "npm"],
  "ui": {
    "theme": "DefaultDark",
    "hideWindowTitle": true
  }
}
EOF

# Run CLI - should load without errors
llxprt --version
```

**Test 2: Invalid type in settings**

```bash
# Create invalid user settings (string instead of boolean)
cat > ~/.llxprt/settings.json << 'EOF'
{
  "disableAutoUpdate": "yes"
}
EOF

# Run CLI - should show validation error
llxprt --version
# Expected: FatalConfigError with message:
#   Invalid configuration in ~/.llxprt/settings.json:
#   Error in: disableAutoUpdate
#   Expected: boolean, but received: string
```

**Test 3: Invalid enum value**

```bash
# Create settings with invalid enum
cat > ~/.llxprt/settings.json << 'EOF'
{
  "emojifilter": "invalid-mode"
}
EOF

# Run CLI - should show validation error
llxprt --version
# Expected: Error about invalid enum value
```

**Test 4: Invalid nested object**

```bash
# Create settings with invalid nested type
cat > ~/.llxprt/settings.json << 'EOF'
{
  "ui": {
    "theme": 123
  }
}
EOF

# Run CLI - should show validation error with path ui.theme
llxprt --version
```

**Test 5: Invalid array element**

```bash
# Create settings with invalid array element
cat > ~/.llxprt/settings.json << 'EOF'
{
  "allowedTools": ["git", 123, "npm"]
}
EOF

# Run CLI - should show validation error with path allowedTools[1]
llxprt --version
```

**Test 6: Multiple validation errors**

```bash
# Create settings with multiple errors
cat > ~/.llxprt/settings.json << 'EOF'
{
  "disableAutoUpdate": "yes",
  "ptyScrollbackLimit": "not-a-number",
  "allowedTools": [1, 2, 3, 4, 5, 6, 7],
  "ui": {
    "theme": false
  }
}
EOF

# Run CLI - should show first 5 errors and summary
llxprt --version
```

**Test 7: Unknown keys (should pass)**

```bash
# Create settings with unknown keys
cat > ~/.llxprt/settings.json << 'EOF'
{
  "unknownKey": "value",
  "anotherUnknown": 123,
  "disableAutoUpdate": false
}
EOF

# Run CLI - should load successfully (passthrough allows unknown keys)
llxprt --version
```

### 7.3 Edge Cases

**Edge Case 1: Empty settings file**

```bash
echo '{}' > ~/.llxprt/settings.json
llxprt --version
# Should succeed - all fields are optional
```

**Edge Case 2: Settings with comments**

```bash
cat > ~/.llxprt/settings.json << 'EOF'
{
  // This is a comment
  "disableAutoUpdate": false,
  /* Multi-line
     comment */
  "emojifilter": "auto"
}
EOF
llxprt --version
# Should succeed - stripJsonComments handles this
```

**Edge Case 3: Settings with null values**

```bash
cat > ~/.llxprt/settings.json << 'EOF'
{
  "disableAutoUpdate": null
}
EOF
llxprt --version
# Should fail - null is not a valid boolean
```

**Edge Case 4: Settings with undefined (JSON can't have undefined, so this is JS-only test)**

Test in code:
```typescript
const result = validateSettings({ disableAutoUpdate: undefined });
// Should succeed - undefined is treated as omitted (optional)
```

### 7.4 Performance Testing

```bash
# Measure validation overhead on large settings file
time llxprt --version

# Create settings with many keys
cat > ~/.llxprt/settings.json << 'EOF'
{
  "disableAutoUpdate": false,
  "emojifilter": "auto",
  "allowedTools": ["git", "npm", "node", "python", "ruby", "go", "rust"],
  "excludeTools": ["dangerous1", "dangerous2"],
  "ui": {
    "theme": "DefaultDark",
    "hideWindowTitle": true,
    "hideTips": false,
    "footer": {
      "hideCWD": false,
      "hideSandboxStatus": true,
      "hideModelInfo": false
    },
    "customThemes": {
      "myTheme": {
        "type": "custom",
        "name": "My Custom Theme",
        "text": { "primary": "#ffffff" }
      }
    }
  },
  "mcpServers": {
    "server1": { "command": "node", "args": ["s1.js"] },
    "server2": { "command": "python", "args": ["s2.py"] },
    "server3": { "command": "go", "args": ["run", "s3.go"] }
  },
  "accessibility": {
    "disableLoadingPhrases": true,
    "screenReader": false
  },
  "fileFiltering": {
    "respectGitIgnore": true,
    "respectLlxprtIgnore": true
  },
  "security": {
    "folderTrust": true,
    "trustedFolders": ["/path1", "/path2", "/path3"]
  }
}
EOF

time llxprt --version
# Validation should add negligible overhead (< 10ms)
```

---

## 8. Commit Message

```
reimplement: add settings validation with Zod (upstream 86134e99)

Implements comprehensive settings validation using Zod schemas, adapted from
upstream commit 86134e99 (feat(settings-validation): add validation for
settings schema).

Validation catches configuration errors early with clear, actionable messages:
- Type mismatches (e.g., string instead of boolean, number in array)
- Invalid enum values (e.g., unknown emojifilter mode)
- Missing required fields in nested objects (e.g., CustomTheme.name)
- Invalid nested structures (e.g., mcpServers with wrong types)

Error messages include:
- File path (e.g., ~/.llxprt/settings.json)
- Property path (e.g., ui.theme, allowedTools[1])
- Expected vs received types
- First 5 errors with summary if more exist
- Documentation link

Validation runs after settings are loaded from all sources (system, system
defaults, user, workspace) but before merging, ensuring all settings files
are validated independently.

Key adaptations for LLxprt:
- Built from LLxprt's SETTINGS_SCHEMA (2023 lines) vs Gemini-cli schema
- Handles LLxprt-specific settings:
  - emojifilter enum: 'allowed' | 'auto' | 'warn' | 'error'
  - lsp union: false | LspConfig object
  - sandbox union: boolean | string
  - fileFiltering, subagents, security, extensions, hooks
- Supports union types via anyOf in SETTINGS_SCHEMA_DEFINITIONS
- Allows legacy UI keys at root level via passthrough
- Uses LLxprt's SETTINGS_SCHEMA_DEFINITIONS for ref resolution
  (MCPServerConfig, TelemetrySettings, BugCommandSettings,
   SummarizeToolOutputSettings, CustomTheme, StringOrStringArray,
   BooleanOrString, BooleanOrLspConfig)

Implementation:
- settings-validation.ts: 350 lines (validation logic, error formatting)
- settings-validation.test.ts: 450 lines (48 comprehensive tests)
- settings.ts: Integration at 4 validation points + 4 error handlers

Tests cover:
- Valid settings: primitives, nested objects, arrays, enums, refs (10 tests)
- Invalid types: all major type mismatches (15 tests)
- LLxprt-specific: emojifilter, lsp, sandbox, etc. (13 tests)
- Error formatting: path display, type messages, error limit (10 tests)

All existing tests pass. Validation adds negligible performance overhead.

See: project-plans/gmerge-0.22.0/86134e99-plan.md
Upstream: feat(settings-validation): add validation for settings schema (#12929)
```

---

## 9. Implementation Checklist

### Phase 1: RED (Write Tests First)

- [ ] Create `packages/cli/src/config/settings-validation.test.ts`
- [ ] Write 10 valid settings tests (empty, primitives, nested, arrays, refs, passthrough)
- [ ] Write 15 invalid type tests (all major type mismatches)
- [ ] Write 13 LLxprt-specific tests (emojifilter, lsp, sandbox, fileFiltering, subagents, security, extensions, hooks)
- [ ] Write 10 error formatting tests (path display, type messages, error limit, doc link)
- [ ] Write 3 schema structure tests (ZodObject instance, optional fields, passthrough)
- [ ] Run tests - **all should fail** (RED)
- [ ] Verify test count: 48+ tests

### Phase 2: GREEN (Minimal Implementation)

**Step 1: Create validation module**

- [ ] Create `packages/cli/src/config/settings-validation.ts`
- [ ] Implement `buildZodSchemaFromJsonSchema()` - handles JSON schema to Zod conversion
- [ ] Implement `buildEnumSchema()` - handles string/number/mixed enums
- [ ] Implement `buildPrimitiveSchema()` - handles string/number/boolean
- [ ] Implement `buildObjectShapeFromProperties()` - recursively builds object shapes
- [ ] Initialize `REF_SCHEMAS` from `SETTINGS_SCHEMA_DEFINITIONS`
- [ ] Implement `buildZodSchemaFromDefinition()` - handles SettingDefinition
  - [ ] Handle ref types (use REF_SCHEMAS)
  - [ ] Handle primitives (string, number, boolean)
  - [ ] Handle enums (use buildEnumSchema)
  - [ ] Handle arrays (with items schema)
  - [ ] Handle objects (with properties and additionalProperties)
  - [ ] Make all fields optional (.optional())
- [ ] Implement `buildZodSchemaFromCollection()` - handles SettingCollectionDefinition
- [ ] Implement `buildSettingsZodSchema()` - builds complete schema from SETTINGS_SCHEMA
  - [ ] Iterate all keys in SETTINGS_SCHEMA
  - [ ] Build Zod schema for each setting
  - [ ] Return z.object(shape).passthrough()
- [ ] Export `settingsZodSchema = buildSettingsZodSchema()`
- [ ] Implement `validateSettings()` - calls settingsZodSchema.safeParse()
- [ ] Implement `formatValidationError()` - formats Zod errors for users
  - [ ] Include file path in header
  - [ ] Format paths as `property.nested[index]`
  - [ ] Show expected vs received for invalid_type
  - [ ] Limit to 5 errors with summary
  - [ ] Include documentation link

**Step 2: Integrate into settings.ts**

- [ ] Add imports: `validateSettings`, `formatValidationError`
- [ ] Create helper: `validateSettingsOrThrow(settingsObject, filePath)`
- [ ] Add validation call after system settings parsing (line ~608)
- [ ] Add validation call after system defaults parsing (line ~624)
- [ ] Add validation call after user settings parsing and theme migration (line ~642)
- [ ] Add validation call after workspace settings parsing and theme migration (line ~679)
- [ ] Update catch block after system settings (line ~609) - preserve FatalConfigError
- [ ] Update catch block after system defaults (line ~625) - preserve FatalConfigError
- [ ] Update catch block after user settings (line ~643) - preserve FatalConfigError
- [ ] Update catch block after workspace settings (line ~680) - preserve FatalConfigError

**Step 3: Run tests**

- [ ] Run `npm run test -- settings-validation.test.ts`
- [ ] **All 48+ tests should pass** (GREEN)
- [ ] Run `npm run test -- settingsSchema.test.ts` - verify no regressions
- [ ] Run `npm run test -- settings.test.ts` - verify no regressions
- [ ] Fix any failing tests

### Phase 3: REFACTOR (Only If Valuable)

- [ ] Assess DRY opportunities - keep separate if functions handle different cases
- [ ] Assess naming clarity - rename only if unclear
- [ ] Assess type safety - add types only if missing
- [ ] Run tests after each refactor
- [ ] **Do not refactor unless it improves clarity or maintainability**

### Phase 4: Manual Verification

- [ ] Test valid settings file - should load without errors
- [ ] Test invalid type (string instead of boolean) - should show clear error
- [ ] Test invalid enum value - should show enum error
- [ ] Test invalid nested object - should show path ui.theme
- [ ] Test invalid array element - should show path allowedTools[1]
- [ ] Test multiple errors - should show first 5 + summary
- [ ] Test unknown keys - should pass (passthrough)
- [ ] Test empty settings - should pass (all optional)
- [ ] Test settings with comments - should pass (stripJsonComments)
- [ ] Test null values - should fail (not valid for typed fields)
- [ ] Performance test - validation overhead < 10ms

### Phase 5: Documentation

- [ ] Update docs/cli/configuration.md if needed (mention validation)
- [ ] Document error message format
- [ ] Document common validation errors and solutions

### Phase 6: Commit

- [ ] Commit with message from section 8
- [ ] Tag commit: `git tag -a gmerge-0.22.0-86134e99 -m "Settings validation with Zod"`

---

## 10. Risks and Mitigations

### Risk 1: Missing SETTINGS_SCHEMA_DEFINITIONS refs

**Symptom**: Schema builder throws "ref not found"  
**Mitigation**: Verify all refs before implementation:

```bash
# Check all refs in SETTINGS_SCHEMA are defined
grep -r "ref: '" packages/cli/src/config/settingsSchema.ts | \
  grep -o "ref: '[^']*'" | \
  sort -u > /tmp/refs-used.txt

# List all defined refs
grep -A1 "SETTINGS_SCHEMA_DEFINITIONS" packages/cli/src/config/settingsSchema.ts | \
  grep -o "^  [A-Za-z]*:" | \
  sed 's/://g' | \
  sort > /tmp/refs-defined.txt

# Find missing refs
comm -23 /tmp/refs-used.txt /tmp/refs-defined.txt
```

**Known refs to verify**:
- `MCPServerConfig` [OK] (line 1683)
- `TelemetrySettings` [OK] (line 1780)
- `BugCommandSettings` [OK] (line 1825)
- `SummarizeToolOutputSettings` [OK] (line 1839)
- `CustomTheme` [OK] (line 1852)
- `StringOrStringArray` [OK] (line 1977)
- `BooleanOrString` [OK] (line 1982)
- `BooleanOrLspConfig` [OK] (line 1987)

### Risk 2: Union types not handled correctly

**Symptom**: lsp or sandbox settings fail validation  
**Mitigation**: Test union types explicitly in Phase 4.4 tests

### Risk 3: Legacy UI keys rejected

**Symptom**: Settings with `showStatusInTitle`, `hideCWD` at root fail  
**Mitigation**: `.passthrough()` allows unknown keys - verify in tests

### Risk 4: Performance degradation on startup

**Symptom**: Slow CLI startup after validation  
**Mitigation**: 
- Schema built once at module load (exported const)
- Measure overhead in manual tests (target < 10ms)
- If > 10ms, consider lazy schema building

### Risk 5: Breaking changes to error messages

**Symptom**: Existing tests expect specific error formats  
**Mitigation**: 
- Run all tests after implementation
- Update assertions if needed
- Preserve FatalConfigError type

### Risk 6: Validation errors on valid settings

**Symptom**: Valid settings rejected due to schema mismatch  
**Mitigation**:
- Test with real user settings files
- Add tests for all SETTINGS_SCHEMA keys
- Use passthrough for unknown keys

---

## 11. Success Criteria

Implementation is complete when:

1. [OK] All 48+ new tests pass
2. [OK] All existing settings tests pass (no regressions)
3. [OK] Manual tests verify clear error messages
4. [OK] Validation overhead < 10ms
5. [OK] Invalid settings throw FatalConfigError with helpful messages
6. [OK] Valid settings load without errors
7. [OK] Unknown keys allowed (passthrough)
8. [OK] All LLxprt-specific settings validated correctly
9. [OK] Documentation updated (if needed)
10. [OK] Commit message follows template

---

## 12. References

- **Upstream commit**: 86134e9970a80c0e97e563616fc44192defb8de1
- **Upstream PR**: #12929
- **Zod documentation**: https://zod.dev
- **LLxprt settingsSchema.ts**: packages/cli/src/config/settingsSchema.ts (2023 lines)
- **LLxprt SETTINGS_SCHEMA_DEFINITIONS**: Line 1679-2000 in settingsSchema.ts
- **RULES.md**: dev-docs/RULES.md (TDD mandatory, schema-first with Zod)
- **Zod version**: 3.23.8 (already in package.json)

---

## 13. Appendix: Upstream vs LLxprt Differences

### Upstream Gemini-cli Settings Structure

```typescript
// Top-level nested structure
interface Settings {
  model?: {
    name?: string;
    maxSessionTurns?: number;
    summarizeToolOutput?: Record<string, { tokenBudget?: number }>;
  };
  ui?: { theme?: string; hideWindowTitle?: boolean; footer?: { ... } };
  tools?: { allowed?: string[]; exclude?: string[]; sandbox?: string | boolean };
  mcpServers?: Record<string, MCPServerConfig>;
  general?: { vimMode?: boolean; disableAutoUpdate?: boolean };
  context?: { includeDirectories?: string[] };
}
```

### LLxprt Settings Structure

```typescript
// Mix of flat and nested
interface Settings {
  // Flat settings at root
  disableAutoUpdate?: boolean;
  emojifilter?: 'allowed' | 'auto' | 'warn' | 'error';
  lsp?: false | LspConfig;
  sandbox?: boolean | string;
  allowedTools?: string[];
  excludeTools?: string[];
  defaultDisabledTools?: string[];
  
  // Nested settings
  accessibility?: { disableLoadingPhrases?: boolean; screenReader?: boolean };
  checkpointing?: { enabled?: boolean };
  fileFiltering?: { respectGitIgnore?: boolean; ... };
  ui?: { theme?: string; customThemes?: ...; footer?: { ... }; ... };
  tools?: { sandbox?: boolean | string; autoAccept?: boolean; ... };
  mcp?: { serverCommand?: string; allowed?: string[]; excluded?: string[] };
  mcpServers?: Record<string, MCPServerConfig>;
  subagents?: { asyncEnabled?: boolean; maxAsync?: number };
  security?: { folderTrust?: boolean; trustedFolders?: string[]; ... };
  extensions?: { disabled?: string[]; ... };
  hooks?: Record<HookEventName, HookDefinition[]>;
  
  // Legacy UI keys (may exist at root)
  showStatusInTitle?: boolean;
  hideCWD?: boolean;
  hideSandboxStatus?: boolean;
  hideModelInfo?: boolean;
}
```

### Key Differences Summary

1. **Nesting**: Upstream has more consistent nesting (e.g., `model.name`). LLxprt has many flat keys.
2. **Unique settings**: LLxprt has emojifilter, lsp, fileFiltering, subagents, security, extensions, hooks.
3. **Migration**: Upstream has V1→V2 migration. LLxprt has legacy UI keys at root.
4. **Schema size**: Upstream ~1000 lines. LLxprt ~2023 lines (2x larger).
5. **Refs**: Both use SETTINGS_SCHEMA_DEFINITIONS, but LLxprt has additional refs (BooleanOrLspConfig, BooleanOrString, StringOrStringArray).

**Implication for validation**: LLxprt validation must handle more diverse schema patterns.
