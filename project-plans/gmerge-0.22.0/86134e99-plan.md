# Reimplementation Plan: Settings Validation with Zod (Upstream 86134e99)

**Upstream Commit**: 86134e9970a80c0e97e563616fc44192defb8de1  
**Author**: Nemo <imshuazi@126.com>  
**Date**: Fri Dec 12 14:30:34 2025 +0800  
**Title**: feat(settings-validation): add validation for settings schema (#12929)

---

## 1. What Upstream Does

The upstream commit adds comprehensive settings validation using Zod, consisting of **730+ lines** across two new files:

### Files Added
1. **`packages/cli/src/config/settings-validation.ts`** (~331 lines)
   - Exports `settingsZodSchema`, `validateSettings()`, and `formatValidationError()`
   - Builds Zod schemas dynamically from `SETTINGS_SCHEMA` and `SETTINGS_SCHEMA_DEFINITIONS`
   - Handles various schema types: primitives, enums, objects, arrays, refs
   - Implements recursive schema building with support for:
     - JSON-schema-like definitions → Zod type conversion
     - `anyOf`, `properties`, `additionalProperties`, `required` fields
     - Optional fields (all settings are partial)
     - Reference schemas via `ref` field pointing to `SETTINGS_SCHEMA_DEFINITIONS`
   - Error formatting with:
     - File path indication
     - Path display (e.g., `model.name`, `tools.allowed[1]`)
     - Type mismatch messages (expected vs received)
     - Maximum 5 errors displayed
     - Documentation link to configuration.md
   - Special handling for `TelemetrySettings` (boolean OR object union)

2. **`packages/cli/src/config/settings-validation.test.ts`** (~398 lines)
   - 16 test suites covering:
     - Valid settings acceptance
     - Invalid type rejection (e.g., `model.name` as object instead of string)
     - `model.summarizeToolOutput` structure validation
     - Empty settings object
     - Unknown top-level keys (passthrough for migration)
     - Nested valid settings (`ui`, `tools`, `context`)
     - Array types and invalid array elements
     - Boolean/number field validation
     - Complex nested configs (`mcpServers`, `customThemes`)
     - Error formatting with file paths
     - Array path formatting (`tools.allowed[1]`)
     - Error limit display (max 5 errors)

### Integration into `settings.ts`
The upstream commit modifies `packages/cli/src/config/settings.ts` to:
- Import `validateSettings` and `formatValidationError`
- Call validation **after migration** in `loadSettings()`
- Throw `FatalConfigError` with formatted message on validation failure
- Preserve `FatalConfigError` when re-throwing (to keep formatted messages)

---

## 2. Why Can't Cherry-Pick

**Structural Incompatibility**: LLxprt's settings architecture differs fundamentally from upstream Gemini-cli:

### Upstream (Gemini-cli) Structure
```typescript
// Upstream has V1/V2 migration and a single Settings type
interface Settings {
  model?: {
    name?: string;
    maxSessionTurns?: number;
    summarizeToolOutput?: Record<string, { tokenBudget?: number }>;
  };
  ui?: { theme?: string; hideWindowTitle?: boolean; footer?: { ... } };
  tools?: { allowed?: string[]; exclude?: string[]; sandbox?: string | boolean };
  mcpServers?: Record<string, MCPServerConfig>;
  general?: { vimMode?: boolean; disableAutoUpdate?: boolean };
  context?: { includeDirectories?: string[] };
  // ... many more top-level keys
}

// Has SETTINGS_SCHEMA_DEFINITIONS registry for refs
```

### LLxprt Structure
```typescript
// LLxprt has flat and nested settings (see settingsSchema.ts)
interface Settings {
  // Top-level settings (many are flat, not nested)
  disableAutoUpdate?: boolean;
  shouldUseNodePtyShell?: boolean;
  emojifilter?: 'allowed' | 'auto' | 'warn' | 'error';
  lsp?: boolean | LspConfig;
  sandbox?: boolean | string | undefined;
  coreTools?: string[];
  allowedTools?: string[];
  excludeTools?: string[];
  defaultDisabledTools?: string[];
  coreToolSettings?: Record<string, boolean>;
  
  // Nested objects
  accessibility?: { disableLoadingPhrases?: boolean; screenReader?: boolean };
  checkpointing?: { enabled?: boolean };
  fileFiltering?: { respectGitIgnore?: boolean; ... };
  ui?: {
    theme?: string;
    customThemes?: Record<string, CustomTheme>;
    hideWindowTitle?: boolean;
    footer?: { hideCWD?: boolean; hideSandboxStatus?: boolean; hideModelInfo?: boolean };
    // ... many more UI settings
  };
  tools?: {
    sandbox?: boolean | string;
    autoAccept?: boolean;
    core?: string[];
    allowed?: string[];
    exclude?: string[];
    // ... more tool settings
  };
  mcp?: { serverCommand?: string; allowed?: string[]; excluded?: string[] };
  mcpServers?: Record<string, MCPServerConfig>;
  sessionRetention?: SessionRetentionSettings;
  output?: { format?: 'text' | 'json' };
  ide?: {};
  subagents?: { asyncEnabled?: boolean; maxAsync?: number };
  security?: { folderTrust?: boolean; trustedFolders?: string[]; ... };
  chatCompression?: ChatCompressionSettings;
  extensions?: { disabled?: string[]; ... };
  hooks?: Record<HookEventName, HookDefinition[]>;
  // ... many more (2000+ lines in settingsSchema.ts)
}

// Also has SETTINGS_SCHEMA_DEFINITIONS (1679+) but with different refs
// Has core/src/settings/types.ts with GlobalSettings, ProviderSettings, UISettings (different shape)
```

**Key Differences**:
1. **No V2 migration path** - LLxprt removed this complexity
2. **Different schema shape** - Many settings are at root level vs nested
3. **Different ref definitions** - LLxprt has its own `SETTINGS_SCHEMA_DEFINITIONS` with different types
4. **Additional types** - LLxprt has `emojifilter`, `lsp`, `fileFiltering`, `subagents`, `security`, `extensions`, `hooks` that upstream doesn't have
5. **Different nesting** - e.g., `tools.sandbox` vs `sandbox` at root, `mcp` vs `mcpServers` only
6. **Multi-provider support** - Core types have `ProviderSettings`, `GlobalSettings` that don't exist upstream

**Migration Differences**: Upstream references V1→V2 migration with `needsMigration()`. LLxprt has different migration logic (legacy UI keys at root level).

---

## 3. Reimplementation Strategy

### Phase 1: Core Validation Infrastructure
**File**: `packages/cli/src/config/settings-validation.ts`

Adapt the upstream validation logic to LLxprt's schema:

#### Functions to Port (with modifications):

1. **`buildZodSchemaFromJsonSchema(def: any): z.ZodTypeAny`**
   - Keep as-is (handles JSON-schema → Zod conversion)
   - Used for `SETTINGS_SCHEMA_DEFINITIONS` refs

2. **`buildEnumSchema(options: ReadonlyArray<{ value: ...; label: ... }>): z.ZodTypeAny`**
   - Keep as-is
   - Handles string/number/mixed enums

3. **`buildPrimitiveSchema(type: 'string' | 'number' | 'boolean'): z.ZodTypeAny`**
   - Keep as-is
   - Simple z.string(), z.number(), z.boolean()

4. **`buildObjectShapeFromProperties(properties: Record<string, SettingDefinition>): Record<string, z.ZodTypeAny>`**
   - Keep as-is
   - Recursively builds object shapes

5. **`REF_SCHEMAS: Record<string, z.ZodTypeAny>`**
   - Initialize from LLxprt's `SETTINGS_SCHEMA_DEFINITIONS`
   - LLxprt already has this registry at line 1679+ in settingsSchema.ts
   - Includes: `MCPServerConfig`, `TelemetrySettings`, `BugCommandSettings`, `SummarizeToolOutputSettings`, `CustomTheme`, etc.

6. **`buildZodSchemaFromDefinition(definition: SettingDefinition): z.ZodTypeAny`**
   - **MODIFY**: Remove special handling for `TelemetrySettings` (unless LLxprt also has boolean | object union)
   - **CHECK**: LLxprt's `telemetry` setting - does it support boolean OR object?
     - If yes, keep the special case: `z.union([z.boolean(), objectSchema])`
   - Handle all LLxprt types: `enum`, `array`, `object`, primitives
   - Support `items` (array element schema), `additionalProperties` (map values)
   - Make all fields optional (`.optional()`)

7. **`buildZodSchemaFromCollection(collection: SettingCollectionDefinition): z.ZodTypeAny`**
   - Keep as-is
   - Handles collection types for items/additionalProperties

8. **`buildSettingsZodSchema(): z.ZodObject<...>`**
   - **CRITICAL MODIFICATION**: Build from LLxprt's `SETTINGS_SCHEMA` structure
   - LLxprt has **2000+ lines** of schema - ensure all top-level keys are covered:
     - `accessibility`, `checkpointing`, `lsp`, `emojifilter`, `fileFiltering`
     - `disableAutoUpdate`, `shouldUseNodePtyShell`, `allowPtyThemeOverride`, `ptyScrollbackLimit`
     - `useExternalAuth`, `sandbox`, `coreTools`, `allowedTools`, `excludeTools`, `defaultDisabledTools`, `coreToolSettings`
     - `toolDiscoveryCommand`, `toolCallCommand`, `toolCallProcessingMode`, `mcpServerCommand`, `mcpServers`
     - `sessionRetention`, `output`, `ui` (with nested props), `ide`, `showStatusInTitle`
     - `hideCWD`, `hideSandboxStatus`, `hideModelInfo` (flat UI keys)
     - `allowMCPServers`, `excludeMCPServers`, `telemetry`, `bugCommand`, `summarizeToolOutput`, `dnsResolutionOrder`
     - `tools` (with nested props), `mcp`, `subagents`, `security`, `model`, `context`, `globalMemory`, `folderTrust`, `folderTrustFeature`, etc.
   - Use `.passthrough()` to allow unknown keys (for migration compatibility)

9. **`export const settingsZodSchema = buildSettingsZodSchema()`**
   - Keep as-is

10. **`validateSettings(data: unknown): { success: boolean; data?: unknown; error?: z.ZodError }`**
    - Keep as-is
    - Returns `settingsZodSchema.safeParse(data)`

11. **`formatValidationError(error: z.ZodError, filePath: string): string`**
    - Keep as-is
    - Format path as `property.nested[0]`
    - Show expected vs received for `invalid_type`
    - Limit to 5 errors
    - **MODIFY LINK**: Change documentation link to LLxprt docs (if applicable)
      - Upstream: `https://github.com/google-gemini/gemini-cli/blob/main/docs/get-started/configuration.md`
      - LLxprt: TBD (check if docs/cli/configuration.md exists or use upstream link)

#### Special Handling for LLxprt-Specific Settings:

1. **`lsp` setting**:
   - Type: `boolean | LspConfig` (see schema: `ref: 'BooleanOrLspConfig'`)
   - Need to handle union type if `BooleanOrLspConfig` is in `SETTINGS_SCHEMA_DEFINITIONS`

2. **`emojifilter` setting**:
   - Type: `'allowed' | 'auto' | 'warn' | 'error'`
   - Already defined as enum in schema - should work automatically

3. **`sandbox` setting**:
   - Type: `boolean | string | undefined`
   - Ref: `BooleanOrString` (check if in SETTINGS_SCHEMA_DEFINITIONS)

4. **Nested `tools.*` and flat `allowedTools`, `excludeTools`, etc.**:
   - LLxprt has both:
     - Flat: `allowedTools`, `excludeTools`, `defaultDisabledTools` at root
     - Nested: `tools.allowed`, `tools.exclude` etc.
   - Schema handles both - validation should support

5. **Legacy UI keys** (at root level):
   - `showStatusInTitle`, `hideCWD`, `hideSandboxStatus`, `hideModelInfo`
   - These are handled by `extractLegacyUiKeys()` in settings.ts
   - Validation should allow them via `.passthrough()`

### Phase 2: Integration into settings.ts
**File**: `packages/cli/src/config/settings.ts`

Add validation call after migration:

```typescript
// Around line 670-680, after migration logic

// Validate settings structure with Zod after migration
const validationResult = validateSettings(settingsObject);
if (!validationResult.success && validationResult.error) {
  const errorMessage = formatValidationError(
    validationResult.error,
    filePath,
  );
  throw new FatalConfigError(errorMessage);
}
```

Also update error handling in the catch block (around line 690):

```typescript
} catch (error: unknown) {
  // Preserve FatalConfigError with formatted validation messages
  if (error instanceof FatalConfigError) {
    throw error;
  }
  settingsErrors.push({
    message: getErrorMessage(error),
    path: filePath,
  });
}
```

**Note**: The upstream integration point is after `migratedSettings` assignment. For LLxprt, place it after:
- JSON parsing
- Legacy theme name migration (`VS` → `DefaultLight.name`, `VS2015` → `DefaultDark.name`)
- **Before** returning `{ settings: settingsObject, rawJson: content }`

This ensures validation happens for all settings files:
- System settings
- System defaults
- User settings
- Workspace settings

### Phase 3: Update SETTINGS_SCHEMA_DEFINITIONS
**File**: `packages/cli/src/config/settingsSchema.ts`

**Action**: Verify all refs used in SETTINGS_SCHEMA have corresponding entries in SETTINGS_SCHEMA_DEFINITIONS.

Already present (line 1679+):
- `MCPServerConfig`
- `TelemetrySettings`
- `BugCommandSettings`
- `SummarizeToolOutputSettings`
- `CustomTheme`

**CHECK**: Ensure these refs are also defined (search in settingsSchema.ts):
- `BooleanOrLspConfig` (for `lsp` setting)
- `BooleanOrString` (for `sandbox` setting)
- `StringOrStringArray` (for `contextFileName` setting)
- Any other refs used in SETTINGS_SCHEMA

If missing, add them to SETTINGS_SCHEMA_DEFINITIONS following the pattern:

```typescript
BooleanOrLspConfig: {
  anyOf: [
    { type: 'boolean' },
    { 
      type: 'object',
      properties: {
        // ... LspConfig properties
      }
    }
  ]
},
```

### Phase 4: Comprehensive Tests
**File**: `packages/cli/src/config/settings-validation.test.ts`

Port and adapt upstream tests:

#### Test suites to create:

1. **`validateSettings()` tests**:
   - Valid settings acceptance:
     - Valid flat settings (`disableAutoUpdate: false`, `emojifilter: 'auto'`)
     - Valid nested settings (`ui.theme`, `tools.autoAccept`, `accessibility.screenReader`)
     - Valid arrays (`allowedTools: ['git', 'npm']`, `extensions.disabled: ['ext1']`)
     - Valid objects (`mcpServers`, `ui.customThemes`, `hooks`)
   - Invalid type rejection:
     - String as boolean: `{ disableAutoUpdate: 'yes' }` → error
     - Number in string array: `{ allowedTools: ['git', 123] }` → error
     - Object instead of string: `{ emojifilter: { mode: 'auto' } }` → error
   - Empty settings object (`{}`) → valid
   - Unknown top-level keys → valid (passthrough)
   - Nested invalid settings:
     - `ui.theme: 123` → error
     - `tools.autoAccept: 'true'` → error
   - Complex nested configs:
     - `mcpServers` with invalid command type
     - `ui.customThemes` with missing required fields
     - `hooks` with invalid structure

2. **LLxprt-specific settings tests**:
   - `emojifilter` enum validation:
     - Valid: `'allowed'`, `'auto'`, `'warn'`, `'error'`
     - Invalid: `'unknown'` → error
   - `lsp` boolean OR object:
     - Valid: `true`, `false`, `{ enabled: true }`
     - Invalid: `'enabled'` → error
   - `sandbox` boolean OR string:
     - Valid: `true`, `false`, `'/path/to/sandbox'`
     - Invalid: `123` → error
   - `fileFiltering` nested object
   - `subagents` with `maxAsync` number validation
   - `security` settings

3. **`formatValidationError()` tests**:
   - Error with file path display
   - Path formatting:
     - `ui.theme` (nested property)
     - `allowedTools[1]` (array index)
     - `mcpServers.my-server.command` (nested object key)
   - Expected vs received type display
   - Multiple errors (list all)
   - Error limit (max 5, with "...and N more errors")
   - Documentation link inclusion

4. **`settingsZodSchema` tests**:
   - Is instance of `z.ZodObject`
   - Has optional fields (empty object is valid)
   - Has expected top-level keys (accessibility, ui, tools, etc.)

#### Upstream test patterns to adapt:

```typescript
// Example: Invalid type test
it('should reject invalid emojifilter value', () => {
  const invalidSettings = {
    emojifilter: 'invalid-mode',
  };
  const result = validateSettings(invalidSettings);
  expect(result.success).toBe(false);
  if (result.error) {
    expect(result.error.issues.length).toBeGreaterThan(0);
    expect(result.error.issues[0]?.path).toEqual(['emojifilter']);
  }
});

// Example: Nested object test
it('should validate ui.footer settings correctly', () => {
  const validSettings = {
    ui: {
      footer: {
        hideCWD: true,
        hideSandboxStatus: false,
        hideModelInfo: true,
      },
    },
  };
  const result = validateSettings(validSettings);
  expect(result.success).toBe(true);
});

// Example: Error formatting test
it('should format error for nested array path', () => {
  const invalidSettings = {
    allowedTools: ['git', 123],
  };
  const result = validateSettings(invalidSettings);
  expect(result.success).toBe(false);
  if (result.error) {
    const formatted = formatValidationError(result.error, 'settings.json');
    expect(formatted).toContain('allowedTools[1]');
    expect(formatted).toContain('Expected: string, but received: number');
  }
});
```

**Test count target**: ~20-30 tests covering:
- 5-10 valid settings tests
- 10-15 invalid settings tests (type mismatches, enums, arrays, objects)
- 5-10 error formatting tests

---

## 4. Implementation Checklist

### Step 1: Create validation module
- [ ] Create `packages/cli/src/config/settings-validation.ts`
- [ ] Implement `buildZodSchemaFromJsonSchema()`
- [ ] Implement `buildEnumSchema()`
- [ ] Implement `buildPrimitiveSchema()`
- [ ] Implement `buildObjectShapeFromProperties()`
- [ ] Initialize `REF_SCHEMAS` from `SETTINGS_SCHEMA_DEFINITIONS`
- [ ] Implement `buildZodSchemaFromDefinition()` (handle LLxprt refs)
- [ ] Implement `buildZodSchemaFromCollection()`
- [ ] Implement `buildSettingsZodSchema()` (from LLxprt's SETTINGS_SCHEMA)
- [ ] Export `settingsZodSchema`
- [ ] Implement `validateSettings()`
- [ ] Implement `formatValidationError()` (update doc link if needed)

### Step 2: Verify SETTINGS_SCHEMA_DEFINITIONS
- [ ] Check all refs in SETTINGS_SCHEMA have definitions
- [ ] Add missing refs if needed:
  - [ ] `BooleanOrLspConfig`
  - [ ] `BooleanOrString`
  - [ ] `StringOrStringArray`
  - [ ] Any other refs

### Step 3: Integrate validation into settings.ts
- [ ] Import `validateSettings` and `formatValidationError`
- [ ] Add validation call after JSON parsing/migration in `loadSettings()`
  - [ ] For system settings (after parsing)
  - [ ] For system defaults (after parsing)
  - [ ] For user settings (after parsing + theme migration)
  - [ ] For workspace settings (after parsing + theme migration)
- [ ] Throw `FatalConfigError` on validation failure
- [ ] Preserve `FatalConfigError` in catch block (don't wrap in settingsErrors)

### Step 4: Create comprehensive tests
- [ ] Create `packages/cli/src/config/settings-validation.test.ts`
- [ ] Add valid settings tests (flat, nested, arrays, objects)
- [ ] Add invalid type tests (string as bool, number in array, etc.)
- [ ] Add LLxprt-specific tests (emojifilter, lsp, sandbox, fileFiltering, etc.)
- [ ] Add error formatting tests (path display, type mismatch, limit)
- [ ] Add schema structure tests (optional fields, top-level keys)
- [ ] Ensure at least 20+ tests total

### Step 5: Run existing tests
- [ ] `npm run test --workspace @vybestack/llxprt-code-cli`
- [ ] Ensure no regressions in settings loading
- [ ] Ensure validation doesn't break existing valid settings files

### Step 6: Manual validation
- [ ] Test with valid user settings.json
- [ ] Test with invalid settings.json (wrong types)
- [ ] Verify error messages are helpful
- [ ] Test with workspace settings
- [ ] Test with system defaults

### Step 7: Documentation
- [ ] Update docs (if configuration.md exists) to mention validation
- [ ] Note any new error messages users might see

---

## 5. Testing Strategy

### Unit Tests (settings-validation.test.ts)
- Test each validation function in isolation
- Test edge cases (empty objects, unknown keys, null values)
- Test all LLxprt-specific setting types

### Integration Tests
- Test validation in full settings loading pipeline
- Test with real settings.json files (valid and invalid)
- Test error propagation (FatalConfigError)

### Regression Tests
- Ensure existing settings files continue to work
- Test migration + validation workflow
- Test workspace vs user settings precedence with validation

---

## 6. Potential Issues & Mitigations

### Issue 1: Missing SETTINGS_SCHEMA_DEFINITIONS refs
**Symptom**: Schema builder fails with "ref not found"  
**Mitigation**: Add all missing refs to SETTINGS_SCHEMA_DEFINITIONS before validation integration

### Issue 2: Union types (lsp, sandbox, telemetry)
**Symptom**: Validation rejects valid boolean | object values  
**Mitigation**: Add special handling in `buildZodSchemaFromDefinition()` for union refs

### Issue 3: Legacy UI keys at root level
**Symptom**: Validation rejects `showStatusInTitle`, `hideCWD` at root  
**Mitigation**: `.passthrough()` allows unknown keys - should work. Confirm with tests.

### Issue 4: Different default values
**Symptom**: Schema defaults conflict with loaded settings  
**Mitigation**: Validation happens AFTER loading and merging - should not affect defaults

### Issue 5: Performance with large schemas (2000+ lines)
**Symptom**: Slow validation on startup  
**Mitigation**: 
- Zod is fast, schema built once at module load
- If needed, cache `settingsZodSchema` (already done via module-level export)

---

## 7. Commit Message

```
reimplement: add settings validation (upstream 86134e99)

Implements comprehensive settings validation using Zod, adapted from upstream
commit 86134e99 (feat(settings-validation): add validation for settings schema).

Validation catches common configuration errors early with clear error messages:
- Type mismatches (e.g., string instead of boolean)
- Invalid enum values (e.g., unknown emojifilter mode)
- Missing required fields in nested objects
- Invalid array element types

The validation runs after settings are loaded but before they're merged,
ensuring all settings files (system, user, workspace) are validated.

Key adaptations for LLxprt:
- Built from LLxprt's SETTINGS_SCHEMA (2000+ lines) instead of Gemini-cli schema
- Handles LLxprt-specific settings: emojifilter, lsp, fileFiltering, subagents, 
  security, extensions, hooks, etc.
- Supports union types (lsp: boolean | object, sandbox: boolean | string)
- Allows legacy UI keys at root level via passthrough
- Uses LLxprt's SETTINGS_SCHEMA_DEFINITIONS for ref resolution

Upstream changes:
- settings-validation.ts: 331 lines (validation logic)
- settings-validation.test.ts: 398 lines (comprehensive tests)
- settings.ts: Integration after migration

See: project-plans/gmerge-0.22.0/86134e99-plan.md
Upstream: feat(settings-validation): add validation for settings schema (#12929)
```

---

## 8. Estimated Scope

- **Lines of new code**: ~730 lines (331 validation + 398 tests)
- **Lines modified**: ~20 lines in settings.ts
- **Complexity**: Medium-High (requires understanding Zod, schema definitions, and LLxprt settings structure)
- **Risk**: Medium (validation errors could block settings loading if not careful)
- **Testing burden**: High (need comprehensive tests for all settings types)

---

## 9. Dependencies

- **Zod version**: Already in `packages/cli/package.json` as `"zod": "^3.23.8"`
- **No new dependencies needed**

---

## 10. Follow-up Work (Optional)

After this reimplementation, consider:

1. **Add validation to settings update functions** (not just load)
   - `setValue()` in LoadedSettings
   - `saveSettings()`

2. **Add JSON schema export** (for IDE autocomplete)
   - Generate `settings.schema.json` from SETTINGS_SCHEMA
   - Reference in settings.json: `"$schema": "./settings.schema.json"`

3. **Add migration validation**
   - Validate settings before and after migration
   - Ensure migration doesn't create invalid settings

4. **Performance monitoring**
   - Measure validation time on large settings files
   - Add telemetry if needed

---

## 11. References

- **Upstream commit**: 86134e9970a80c0e97e563616fc44192defb8de1
- **Upstream PR**: #12929
- **Zod docs**: https://zod.dev
- **LLxprt settingsSchema.ts**: packages/cli/src/config/settingsSchema.ts (2024 lines)
- **LLxprt SETTINGS_SCHEMA_DEFINITIONS**: Line 1679+ in settingsSchema.ts
