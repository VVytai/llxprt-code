# Plan: Reimplementation — feat(a2a): Introduce restore command (1f813f6a060e)

Plan ID: PLAN-20250219-GMERGE021.B8-FALLBACK
Generated: 2025-02-19
Total Phases: 8 (0.5 + 1–7)
Context: Cherry-pick conflict resolution fallback — used only when `git cherry-pick 1f813f6a060e` produces conflicts.

## Critical Reminders

Before implementing ANY phase, ensure you have:

1. Completed preflight verification (Phase 0.5)
2. The `Command.execute` interface migration (Phase 2) is atomic — all implementors and their tests must change in the same commit
3. Written integration tests BEFORE implementation (TDD)
4. Verified all dependencies and types exist as assumed

---

# Phase 0.5: Preflight Verification

## Phase ID

`PLAN-20250219-GMERGE021.B8-FALLBACK.P0.5`

## Purpose

Verify ALL assumptions before writing any code.

## Dependency Verification

| Dependency | Check Command | Status |
|------------|---------------|--------|
| `zod` | `npm ls zod` | Confirm present |
| `simple-git` | `npm ls simple-git` | Confirm present |
| `@a2a-js/sdk` | `npm ls @a2a-js/sdk` | Confirm present |

## Type / Interface Verification

| Item | Expected | Check |
|------|----------|-------|
| `GitService.restoreProjectFromSnapshot` | Method exists | `grep -r "restoreProjectFromSnapshot" packages/core/src` |
| `GitService.createSnapshot` | Method exists | `grep -r "createSnapshot" packages/core/src` |
| `Config.getCheckpointingEnabled()` | Returns boolean, default `false` | `grep -n "getCheckpointingEnabled" packages/core/src/config/config.ts` |
| `Config.getGitService()` | Lazy-init method | `grep -n "getGitService" packages/core/src/config/config.ts` |
| `Storage.getProjectTempCheckpointsDir()` | Method exists | `grep -rn "getProjectTempCheckpointsDir" packages/core/src` |
| `EDIT_TOOL_NAME` | `'replace'` | `grep -n "EDIT_TOOL_NAME" packages/core/src/tools/tool-names.ts` |
| `WRITE_FILE_TOOL` | `'write_file'` | `grep -n "WRITE_FILE_TOOL" packages/core/src/tools/tool-names.ts` |
| `ToolCallRequestInfo` fields | `callId, name, args, isClientInitiated, prompt_id, agentId?` | `grep -n "ToolCallRequestInfo" packages/core/src/core/turn.ts` |
| `Command.execute` current signature | `execute(config: Config, args: string[])` | `grep -n "execute" packages/a2a-server/src/commands/types.ts` |
| `checkpointUtils.ts` | Does NOT exist yet | `ls packages/core/src/utils/checkpointUtils.ts` should fail |
| `ToolCallData` core export | Does NOT exist yet | `grep -r "ToolCallData" packages/core/src/index.ts` should return nothing |

## Call Path Verification

| Function | Expected File | Grep Evidence |
|----------|---------------|---------------|
| `scheduleToolCalls` | `packages/a2a-server/src/agent/task.ts` | `grep -n "scheduleToolCalls" packages/a2a-server/src/agent/task.ts` |
| `fs.readFileSync` at line 526 | `task.ts` | Must remain synchronous — do not convert |
| `loadConfig` | `packages/a2a-server/src/config/config.ts` | Confirm `checkpointing` not yet passed to `ConfigParameters` |

## Blocking Issues Checklist

- [ ] `GitService.createSnapshot()` exists — if not, Phase 1 must create it or adapt `processRestorableToolCalls`
- [ ] No name clashes for new exports (`ToolCallData`, `getToolCallDataSchema`, etc.) in `packages/core/src/index.ts`
- [ ] `Config.checkpointing` default confirmed (expected: `false`)
- [ ] `loadConfig` in a2a-server does not yet pass `checkpointing` — Phase 4/5 must wire it

## Verification Gate

- [ ] All dependencies present
- [ ] All types/methods match expectations
- [ ] All call paths are reachable
- [ ] No pre-existing name clashes for new exports
- [ ] `createSnapshot` existence confirmed

**IF ANY CHECKBOX IS UNCHECKED: STOP and update this plan before proceeding.**

---

# Phase 1: Core — ToolCallData Schema and Checkpoint Utilities

## Phase ID

`PLAN-20250219-GMERGE021.B8-FALLBACK.P1`

## Prerequisites

- Required: Phase 0.5 completed and all gates passed
- Verification: Phase 0.5 blocking checklist all checked

## Requirements Implemented (Expanded)

### REQ-RESTORE-001: Checkpoint Data Schema

**Full Text**: Core must export a Zod schema and TypeScript type (`ToolCallData`) for checkpoint JSON files that is backward-compatible with files written by the existing CLI restore command.
**Behavior**:
- GIVEN: A checkpoint JSON file on disk (possibly written by the CLI without schema enforcement)
- WHEN: The file content is parsed and validated with `getToolCallDataSchema()`
- THEN: Valid files (including old CLI-format files with unknown extra fields) pass; files missing `toolCall` fail
**Why This Matters**: Both the CLI and A2A server write/read checkpoint files; a shared schema prevents silent data corruption.

### REQ-RESTORE-002: Checkpoint Filename Generation

**Full Text**: Checkpoint filenames must be unique across concurrent tool calls and safe for all platforms.
**Behavior**:
- GIVEN: Two tool calls with different `callId`s occurring at the same millisecond
- WHEN: `generateCheckpointFileName` is called for each
- THEN: Two distinct filenames are produced, containing no colons, slashes, or backslashes
**Why This Matters**: Concurrent scheduling on POSIX and Windows must not collide or produce invalid paths.

### REQ-RESTORE-003: Checkpoint List Utilities

**Full Text**: Core must export functions to read, sort, and format a directory listing of checkpoint files.
**Behavior**:
- GIVEN: A checkpoint directory with `.json` files, non-json files, and possibly symlinks
- WHEN: `getCheckpointInfoList(dir)` is called
- THEN: Returns sorted `.json` filenames only; symlinks excluded
**Why This Matters**: The restore command must enumerate checkpoints without security vulnerabilities (symlink following, path traversal).

### REQ-RESTORE-004: Restorable Tool Call Processing

**Full Text**: Core must export `processRestorableToolCalls` that builds checkpoint data for edit/write tool calls without writing to disk.
**Behavior**:
- GIVEN: A list of `ToolCallRequestInfo` items, some with restorable tool names
- WHEN: `processRestorableToolCalls` is called
- THEN: Returns maps of checkpoint content and filename mappings; git errors collected but do not abort processing of other calls
**Why This Matters**: Callers (task.ts) own the atomic disk-write step; the utility is pure and testable in isolation.

## Implementation Tasks

### Files to Create

- `packages/core/src/utils/checkpointUtils.ts`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P1`
  - Exports: `getToolCallDataSchema(historyItemSchema?)`, `ToolCallData` (inferred type), `generateCheckpointFileName(toolCall)`, `formatCheckpointDisplayList(filenames)`, `getTruncatedCheckpointNames(filenames)`, `getCheckpointInfoList(checkpointDir)`, `processRestorableToolCalls(toolCalls, gitService, geminiClient?, history?)`
  - Schema: `.passthrough()` on nested objects; only `toolCall` required; all other fields optional
  - `getCheckpointInfoList`: async, uses `fs.lstat` to exclude symlinks; only returns entries where `path.basename(f) === f`
  - `processRestorableToolCalls`: returns `{ checkpointsToWrite: Map<string,string>, toolCallToCheckpointMap: Map<string,string>, errors: Error[] }`; does NOT write to disk
  - Filename format: `<ISO-timestamp-colons-replaced>-<callId>-<toolName>.json`

- `packages/core/src/utils/checkpointUtils.test.ts`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P1`
  - See Phase 7 for full test scenarios

### Files to Modify

- `packages/core/src/tools/tool-names.ts`
  - ADD: `export const WRITE_FILE_TOOL_NAME = 'write_file';` (alias for upstream compat)
  - ADD: `export const EDIT_TOOL_NAMES = new Set([EDIT_TOOL_NAME, WRITE_FILE_TOOL_NAME]);`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P1`

- `packages/core/src/core/turn.ts`
  - ADD: `checkpoint?: string;` to `ToolCallRequestInfo` interface (additive, non-breaking)
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P1`

- `packages/core/src/index.ts`
  - ADD: `export * from './utils/checkpointUtils.js';`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P1`

### Required Code Markers

Every function/export created in this phase MUST include:

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.B8-FALLBACK.P1
 * @requirement REQ-RESTORE-001 (or -002, -003, -004 as applicable)
 */
```

## Verification Commands

### Automated Checks

```bash
# Phase marker present
grep -r "@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P1" packages/core/src | wc -l
# Expected: 3+ occurrences (checkpointUtils.ts, tool-names.ts, turn.ts)

# New exports present in core index
grep "checkpointUtils" packages/core/src/index.ts
# Expected: 1 match

# EDIT_TOOL_NAMES exported
grep "EDIT_TOOL_NAMES" packages/core/src/tools/tool-names.ts
# Expected: 1 match

# checkpoint field in ToolCallRequestInfo
grep "checkpoint" packages/core/src/core/turn.ts
# Expected: 1 match

# Tests pass
npm test -- --reporter=verbose 2>&1 | grep -E "(PASS|FAIL|checkpointUtils)"
# Expected: checkpointUtils tests PASS
```

### Structural Verification Checklist

- [ ] `checkpointUtils.ts` created with all 7 exports
- [ ] `ToolCallData` type exported
- [ ] `WRITE_FILE_TOOL_NAME` and `EDIT_TOOL_NAMES` added to `tool-names.ts`
- [ ] `checkpoint?: string` added to `ToolCallRequestInfo`
- [ ] `export * from './utils/checkpointUtils.js'` in `index.ts`
- [ ] Plan markers in all modified files
- [ ] No TODOs/stubs in implementation

### Deferred Implementation Detection

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB|XXX|TEMPORARY|WIP)" packages/core/src/utils/checkpointUtils.ts
# Expected: No matches

grep -rn -E "(in a real|placeholder|not yet|will be|for now)" packages/core/src/utils/checkpointUtils.ts
# Expected: No matches

grep -rn -E "return \[\]|return \{\}|return null|return undefined" packages/core/src/utils/checkpointUtils.ts | grep -v ".test.ts"
# Expected: No matches in implementation functions
```

### Semantic Verification Checklist

1. **Does the code DO what the requirement says?**
   - [ ] Schema accepts `{ toolCall: { name: 'replace', args: {} } }` minimal payload
   - [ ] Schema accepts payload with all optional fields
   - [ ] Schema rejects payload missing `toolCall`
   - [ ] Schema accepts old CLI-format checkpoint with extra fields (passthrough)
   - [ ] `generateCheckpointFileName` output contains no `:`, `/`, `\`
   - [ ] Two calls with same timestamp but different `callId` produce different filenames
   - [ ] `getCheckpointInfoList` excludes symlinks
   - [ ] `processRestorableToolCalls` returns empty maps for empty input
   - [ ] `processRestorableToolCalls` excludes non-restorable tool names

2. **Is this REAL implementation, not placeholder?**
   - [ ] Deferred implementation detection passed
   - [ ] `getCheckpointInfoList` actually calls `fs.lstat`
   - [ ] `processRestorableToolCalls` actually calls `gitService.createSnapshot`

3. **Would tests FAIL if implementation was removed?**
   - [ ] Schema tests verify actual parse outcomes
   - [ ] Filename tests check actual string content

4. **Is the feature REACHABLE?**
   - [ ] Exported from `packages/core/src/index.ts`
   - [ ] `EDIT_TOOL_NAMES` and `checkpoint` field reachable from a2a-server via core import

5. **Gaps before proceeding:**
   - [ ] None (list any found)

#### Feature Actually Works

```bash
# Run core tests
npx vitest run packages/core/src/utils/checkpointUtils.test.ts
# Expected: All tests pass
```

## Success Criteria

- All verification commands return expected results
- `checkpointUtils.test.ts` passes fully
- TypeScript compilation clean for modified core files
- No name clashes in core index exports

## Failure Recovery

If this phase fails:

1. `git checkout -- packages/core/src/utils/`
2. `git checkout -- packages/core/src/tools/tool-names.ts`
3. `git checkout -- packages/core/src/core/turn.ts`
4. `git checkout -- packages/core/src/index.ts`
5. Cannot proceed to Phase 2 until fixed

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P1.md`

```markdown
Phase: P1
Completed: YYYY-MM-DD HH:MM
Files Created: checkpointUtils.ts, checkpointUtils.test.ts
Files Modified: tool-names.ts, turn.ts, index.ts
Tests Added: [count]
Verification: [paste verification command outputs]
```

---

# Phase 2: A2A Server — Command Interface Migration (Atomic)

## Phase ID

`PLAN-20250219-GMERGE021.B8-FALLBACK.P2`

## Prerequisites

- Required: Phase 1 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P1" packages/core/src | wc -l` returns 3+
- Expected files from Phase 1: `packages/core/src/utils/checkpointUtils.ts`
- **WARNING: ATOMIC PHASE**: All files in this phase MUST be modified in the same commit. The interface change breaks compilation until all implementors are updated.

## Requirements Implemented (Expanded)

### REQ-RESTORE-005: Command Interface Accepts Context

**Full Text**: The `Command.execute` signature must accept a `CommandContext` object (containing `config` and optionally `git`) instead of a bare `Config`, and commands may declare `requiresWorkspace` to require workspace/git context.
**Behavior**:
- GIVEN: An A2A server with `ExtensionsCommand` and new `RestoreCommand` registered
- WHEN: The `/executeCommand` HTTP endpoint dispatches to any registered command
- THEN: The command receives `{ config, git }` and can access `config` identically to before; `RestoreCommand` can additionally use `git`
**Why This Matters**: Without this migration, the new restore command cannot receive `GitService`; doing it atomically prevents a broken intermediate state.

## Implementation Tasks

### Files to Modify (ALL IN SAME COMMIT)

- `packages/a2a-server/src/commands/types.ts`
  - ADD import: `import type { GitService } from '@google/gemini-cli-core';`
  - ADD interface: `export interface CommandContext { config: Config; git?: GitService; }`
  - CHANGE `Command.execute(config: Config, args: string[])` → `execute(context: CommandContext, args: string[]): Promise<CommandExecutionResponse>;`
  - ADD to `Command`: `requiresWorkspace?: boolean;`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P2`

- `packages/a2a-server/src/commands/extensions.ts`
  - CHANGE `ExtensionsCommand.execute(config, _)` → `execute(context, _)` and pass `context.config` to `ListExtensionsCommand`
  - CHANGE `ListExtensionsCommand.execute(config, _)` → `execute(context, _)` and use `context.config`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P2`

- `packages/a2a-server/src/commands/extensions.test.ts`
  - UPDATE mock `execute` signatures to accept `CommandContext`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P2`

- `packages/a2a-server/src/commands/command-registry.test.ts`
  - UPDATE mock `Command` instances' `execute` signatures
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P2`

- `packages/a2a-server/src/http/app.ts`
  - CHANGE `/executeCommand` handler: build `CommandContext = { config, git: requiresWorkspace ? git : undefined }` and pass to `commandToExecute.execute(context, args ?? [])`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P2`

### Required Code Markers

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.B8-FALLBACK.P2
 * @requirement REQ-RESTORE-005
 */
```

## Verification Commands

```bash
# Phase markers present
grep -r "@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P2" packages/a2a-server/src | wc -l
# Expected: 5+ occurrences

# CommandContext type defined
grep "CommandContext" packages/a2a-server/src/commands/types.ts
# Expected: interface declaration present

# requiresWorkspace added to Command
grep "requiresWorkspace" packages/a2a-server/src/commands/types.ts
# Expected: 1 match

# TypeScript compiles cleanly (critical: interface is breaking)
npm run typecheck 2>&1 | grep -E "(error|PASS)"
# Expected: No errors

# Extensions tests still pass
npx vitest run packages/a2a-server/src/commands/extensions.test.ts
# Expected: All pass
```

### Structural Verification Checklist

- [ ] `CommandContext` interface exported from `types.ts`
- [ ] `requiresWorkspace?: boolean` in `Command` interface
- [ ] `extensions.ts` migrated to `CommandContext`
- [ ] `extensions.test.ts` mock signatures updated
- [ ] `command-registry.test.ts` mock signatures updated
- [ ] `app.ts` passes `CommandContext` to all command executions
- [ ] No compilation errors

### Deferred Implementation Detection

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB)" packages/a2a-server/src/commands/extensions.ts packages/a2a-server/src/commands/types.ts
# Expected: No matches
```

### Semantic Verification Checklist

1. **Does the code DO what the requirement says?**
   - [ ] `ExtensionsCommand` and `ListExtensionsCommand` still work after migration (tests pass)
   - [ ] `context.config` is used wherever `config` was used before
   - [ ] `app.ts` constructs `CommandContext` before calling `execute`

2. **Is this REAL implementation, not placeholder?**
   - [ ] `CommandContext` is actually used in `extensions.ts`, not just in the interface
   - [ ] No `config as any` casts hiding migration issues

3. **Would tests FAIL if implementation was removed?**
   - [ ] `extensions.test.ts` exercises the command logic, not just existence

4. **Is the feature REACHABLE?**
   - [ ] `/executeCommand` HTTP endpoint updated to pass context

5. **Gaps before proceeding:**
   - [ ] None (list any found)

## Success Criteria

- TypeScript compilation passes with zero errors
- `extensions.test.ts` and `command-registry.test.ts` pass
- `http/app.ts` uses `CommandContext`

## Failure Recovery

1. `git checkout -- packages/a2a-server/src/commands/`
2. `git checkout -- packages/a2a-server/src/http/app.ts`
3. Must fix ALL files together — partial rollback leaves compilation broken

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P2.md`

---

# Phase 3: A2A Server — Restore Command

## Phase ID

`PLAN-20250219-GMERGE021.B8-FALLBACK.P3`

## Prerequisites

- Required: Phase 2 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P2" packages/a2a-server/src | wc -l` returns 5+
- Expected: `CommandContext` type available; `extensions.ts` migrated

## Requirements Implemented (Expanded)

### REQ-RESTORE-006: List Checkpoints A2A Command

**Full Text**: A2A server must expose a `restore list` command that returns the formatted list of available checkpoints.
**Behavior**:
- GIVEN: A checkpoint directory with some `.json` files
- WHEN: `/executeCommand` is called with `{ command: 'restore list' }`
- THEN: Response lists checkpoint names (without `.json`) joined by newlines
**Why This Matters**: A2A callers need to enumerate available restore points before calling restore.

### REQ-RESTORE-007: Restore Command with Security

**Full Text**: A2A server must expose a `restore` command that reads a named checkpoint, validates it against the Zod schema, optionally restores git state, and returns the tool call data — rejecting path traversal attempts and symlinks.
**Behavior**:
- GIVEN: A valid checkpoint name (no path separators) pointing to a schema-valid `.json` file
- WHEN: `/executeCommand` is called with `{ command: 'restore', args: ['<checkpoint-name>'] }`
- THEN: Git state is restored (if `commitHash` present) and tool call data is returned
- AND GIVEN: A malicious argument like `../../../etc/passwd`
- WHEN: `/executeCommand` is called
- THEN: Error response is returned; no file read occurs
**Why This Matters**: The restore command reads arbitrary filenames from user input; path traversal could expose sensitive files.

## Implementation Tasks

### Files to Create

- `packages/a2a-server/src/commands/restore.ts`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P3`
  - `ListCheckpointsCommand`:
    - `name = 'restore list'`; `requiresWorkspace = false`
    - `execute(context, _)`: call `getCheckpointInfoList(context.config.storage.getProjectTempCheckpointsDir())`, format with `formatCheckpointDisplayList`, return success response
    - If checkpointing disabled: return error response; do NOT throw
  - `RestoreCommand`:
    - `name = 'restore'`; `requiresWorkspace = true`; `topLevel = true`
    - `subCommands = [new ListCheckpointsCommand()]`
    - `execute(context, args)` security steps:
      1. Validate `args[0]` is non-empty string
      2. `const safe = path.basename(args[0])` — if `safe !== args[0]` → error response
      3. Ensure `.json` extension (append if missing)
      4. Resolve full path: `path.join(context.config.storage.getProjectTempCheckpointsDir(), safe)`
      5. `fs.lstat` the path — if symlink → error response
      6. Read and parse; validate with `getToolCallDataSchema()`
      7. If `data.commitHash` and `context.git` exists: call `context.git.restoreProjectFromSnapshot(data.commitHash)`
      8. If `data.commitHash` and `context.git` is undefined: error response
      9. Return `{ name: 'restore', data: { toolCall: data.toolCall, restored: true } }`
    - Map ALL errors to `CommandExecutionResponse` with `data.error`; NEVER throw out of `execute`

- `packages/a2a-server/src/commands/restore.test.ts`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P3`
  - See Phase 7 for full test scenarios

### Files to Modify

- `packages/a2a-server/src/commands/command-registry.ts`
  - ADD: `import { RestoreCommand } from './restore.js';`
  - Register `new RestoreCommand()` in constructor
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P3`

### Required Code Markers

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.B8-FALLBACK.P3
 * @requirement REQ-RESTORE-006 (or REQ-RESTORE-007)
 */
```

## Verification Commands

```bash
# Phase markers present
grep -r "@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P3" packages/a2a-server/src | wc -l
# Expected: 3+ occurrences

# RestoreCommand exported
grep "RestoreCommand" packages/a2a-server/src/commands/restore.ts
# Expected: export class RestoreCommand

# Registered in command registry
grep "RestoreCommand" packages/a2a-server/src/commands/command-registry.ts
# Expected: 2 matches (import + register)

# Security: path.basename check present
grep "path.basename" packages/a2a-server/src/commands/restore.ts
# Expected: 1+ matches

# lstat present
grep "lstat" packages/a2a-server/src/commands/restore.ts
# Expected: 1+ matches

# Tests pass
npx vitest run packages/a2a-server/src/commands/restore.test.ts
# Expected: All pass
```

### Structural Verification Checklist

- [ ] `restore.ts` created with both command classes
- [ ] `ListCheckpointsCommand` does not throw on checkpointing disabled
- [ ] `RestoreCommand` path traversal rejection implemented
- [ ] Symlink rejection implemented
- [ ] Schema validation before using any field
- [ ] `RestoreCommand` registered in command registry
- [ ] Test file created

### Deferred Implementation Detection

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB)" packages/a2a-server/src/commands/restore.ts | grep -v ".test.ts"
# Expected: No matches

grep -rn -E "(in a real|placeholder|not yet)" packages/a2a-server/src/commands/restore.ts
# Expected: No matches
```

### Semantic Verification Checklist

1. **Does the code DO what the requirement says?**
   - [ ] `../../../etc/passwd` argument returns error response (test verified)
   - [ ] Symlink argument returns error response (test verified)
   - [ ] Valid checkpoint with `commitHash` calls `restoreProjectFromSnapshot`
   - [ ] Valid checkpoint without `commitHash` succeeds without calling git
   - [ ] Schema-invalid file returns error response

2. **Is this REAL implementation, not placeholder?**
   - [ ] Security checks are in `execute`, not skipped
   - [ ] `context.git` undefined handled explicitly

3. **Would tests FAIL if security checks were removed?**
   - [ ] Path traversal test would fail
   - [ ] Symlink test would fail

4. **Is the feature REACHABLE by callers?**
   - [ ] `RestoreCommand` registered in command registry
   - [ ] `/listCommands` would include `restore`

5. **Gaps before proceeding:**
   - [ ] None (list any found)

## Success Criteria

- `restore.test.ts` passes fully including all security scenarios
- TypeScript compiles cleanly
- `command-registry` includes `RestoreCommand`

## Failure Recovery

1. `git checkout -- packages/a2a-server/src/commands/restore.ts`
2. `git checkout -- packages/a2a-server/src/commands/restore.test.ts`
3. `git checkout -- packages/a2a-server/src/commands/command-registry.ts`

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P3.md`

---

# Phase 4: Task Checkpoint Creation

## Phase ID

`PLAN-20250219-GMERGE021.B8-FALLBACK.P4`

## Prerequisites

- Required: Phase 1 completed (core utilities available)
- Verification: `grep "EDIT_TOOL_NAMES" packages/core/src/tools/tool-names.ts` returns a match
- Expected: `processRestorableToolCalls` and `EDIT_TOOL_NAMES` importable from core

## Requirements Implemented (Expanded)

### REQ-RESTORE-008: Atomic Checkpoint Write on Edit Tools

**Full Text**: When the A2A task scheduler dispatches edit or write-file tool calls and checkpointing is enabled, checkpoint files must be written atomically (write-then-rename) before tool execution, and the `checkpoint` field on each request set only after the file is durably on disk.
**Behavior**:
- GIVEN: A task with checkpointing enabled and a `replace` or `write_file` tool call scheduled
- WHEN: `scheduleToolCalls()` processes the batch
- THEN: A `.json` checkpoint file appears in the checkpoints directory; `request.checkpoint` is set to its name; if rename fails, `request.checkpoint` is NOT set
- AND GIVEN: A non-edit tool call (e.g., `read_file`)
- WHEN: Processed in same batch
- THEN: No checkpoint written for that call
**Why This Matters**: Atomic writes prevent half-written files from being read by a concurrent restore command.

## Implementation Tasks

### Files to Modify

- `packages/a2a-server/src/agent/task.ts`
  - ADD imports: `EDIT_TOOL_NAMES`, `processRestorableToolCalls` from `@google/gemini-cli-core`
  - In `scheduleToolCalls()`, after filtering requests, ADD checkpoint creation block:
    ```typescript
    if (config.getCheckpointingEnabled()) {
      const restorableRequests = requests.filter(r => EDIT_TOOL_NAMES.has(r.name));
      const { checkpointsToWrite, toolCallToCheckpointMap, errors } =
        await processRestorableToolCalls(restorableRequests, gitService, geminiClient, history);
      for (const [filename, content] of checkpointsToWrite) {
        const dir = config.storage.getProjectTempCheckpointsDir();
        const finalPath = path.join(dir, filename);
        const tmpPath = `${finalPath}.tmp`;
        try {
          await fs.promises.writeFile(tmpPath, content);
          await fs.promises.rename(tmpPath, finalPath);
          // Only set checkpoint after rename succeeds
          const req = requests.find(r => toolCallToCheckpointMap.get(r.callId) === filename);
          if (req) req.checkpoint = filename;
        } catch (err) {
          errors.push(err as Error);
        }
      }
      for (const err of errors) {
        // log error; do not abort scheduling
      }
    }
    ```
  - **DO NOT** convert the existing `fs.readFileSync` at line 526 to async
  - Gate the entire block on `config.getCheckpointingEnabled()`
  - `gitService`: obtain via `await config.getGitService()` (already lazy-initialized)
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P4`

### Required Code Markers

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.B8-FALLBACK.P4
 * @requirement REQ-RESTORE-008
 */
```

## Verification Commands

```bash
# Phase markers present
grep -r "@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P4" packages/a2a-server/src | wc -l
# Expected: 1+ occurrences

# EDIT_TOOL_NAMES import
grep "EDIT_TOOL_NAMES" packages/a2a-server/src/agent/task.ts
# Expected: import line present

# Atomic write pattern
grep "rename" packages/a2a-server/src/agent/task.ts
# Expected: 1+ matches

# Original readFileSync untouched
grep -n "readFileSync" packages/a2a-server/src/agent/task.ts
# Expected: Still present at original line (approximately 526)

# TypeScript compiles
npm run typecheck 2>&1 | grep error
# Expected: No errors
```

### Structural Verification Checklist

- [ ] `EDIT_TOOL_NAMES` imported from core
- [ ] `processRestorableToolCalls` imported from core
- [ ] Checkpoint creation gated on `config.getCheckpointingEnabled()`
- [ ] Write-then-rename pattern implemented
- [ ] `request.checkpoint` set only after `rename` succeeds
- [ ] Errors logged; scheduling not aborted on partial failure
- [ ] Existing `fs.readFileSync` not converted to async

### Deferred Implementation Detection

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB)" packages/a2a-server/src/agent/task.ts | grep -v "existing\|pre-existing"
# Expected: No new markers from this phase
```

### Semantic Verification Checklist

1. **Does the code DO what the requirement says?**
   - [ ] With checkpointing disabled: no checkpoint files written, `request.checkpoint` not set
   - [ ] With `replace` tool call: checkpoint file appears in checkpoints dir
   - [ ] With `read_file` tool call: no checkpoint written
   - [ ] Rename failure: `request.checkpoint` not set

2. **Is this REAL implementation, not placeholder?**
   - [ ] `fs.promises.rename` actually called (not just `writeFile`)
   - [ ] `EDIT_TOOL_NAMES.has(r.name)` filter actually filters

3. **Would tests FAIL if checkpoint logic was removed?**
   - [ ] Task integration tests verify file existence and `request.checkpoint` value

4. **Is the feature REACHABLE?**
   - [ ] `scheduleToolCalls` is called during normal task execution
   - [ ] Checkpointing enabled via config/env

5. **Gaps before proceeding:**
   - [ ] None (list any found)

## Success Criteria

- Task integration tests pass (see Phase 7)
- TypeScript compiles without errors
- Existing task tests (non-checkpoint) continue to pass

## Failure Recovery

1. `git checkout -- packages/a2a-server/src/agent/task.ts`

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P4.md`

---

# Phase 5: HTTP App Integration

## Phase ID

`PLAN-20250219-GMERGE021.B8-FALLBACK.P5`

## Prerequisites

- Required: Phase 2 completed (`CommandContext` type defined and app.ts partially migrated)
- Verification: `grep "CommandContext" packages/a2a-server/src/http/app.ts` returns a match

## Requirements Implemented (Expanded)

### REQ-RESTORE-009: Workspace Validation for Workspace-Required Commands

**Full Text**: The `/executeCommand` HTTP endpoint must check `requiresWorkspace` on the dispatched command; if true, it must verify `CODER_AGENT_WORKSPACE_PATH` is set and provide a `GitService` to the command context, returning HTTP 400 if the env var is absent.
**Behavior**:
- GIVEN: A request to execute `restore` (which has `requiresWorkspace = true`)
- WHEN: `CODER_AGENT_WORKSPACE_PATH` is not set in the environment
- THEN: HTTP 400 returned with a clear error message; no command execution
- AND GIVEN: `CODER_AGENT_WORKSPACE_PATH` is set
- WHEN: `restore` is executed
- THEN: `context.git` is a live `GitService` instance
**Why This Matters**: Restore modifies git state; operating without a known workspace path risks corrupting an unknown directory.

## Implementation Tasks

### Files to Modify

- `packages/a2a-server/src/http/app.ts`
  - In `/executeCommand` handler, after `commandToExecute` is resolved, ADD:
    ```typescript
    let git: GitService | undefined;
    if (commandToExecute.requiresWorkspace) {
      if (!process.env['CODER_AGENT_WORKSPACE_PATH']) {
        return res.status(400).json({ error: 'CODER_AGENT_WORKSPACE_PATH not set; this command requires a workspace' });
      }
      git = await config.getGitService();
    }
    const context: CommandContext = { config, git };
    const result = await commandToExecute.execute(context, args ?? []);
    ```
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P5`

### Required Code Markers

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.B8-FALLBACK.P5
 * @requirement REQ-RESTORE-009
 */
```

## Verification Commands

```bash
# Phase markers present
grep -r "@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P5" packages/a2a-server/src | wc -l
# Expected: 1+ occurrences

# CODER_AGENT_WORKSPACE_PATH check present
grep "CODER_AGENT_WORKSPACE_PATH" packages/a2a-server/src/http/app.ts
# Expected: 1+ matches

# requiresWorkspace check present
grep "requiresWorkspace" packages/a2a-server/src/http/app.ts
# Expected: 1+ matches

# TypeScript compiles
npm run typecheck 2>&1 | grep error
# Expected: No errors
```

### Structural Verification Checklist

- [ ] `requiresWorkspace` check in `/executeCommand` handler
- [ ] `CODER_AGENT_WORKSPACE_PATH` env var validated for workspace commands
- [ ] `git` obtained via `config.getGitService()` for workspace commands
- [ ] `CommandContext` constructed with `git` when workspace required
- [ ] HTTP 400 returned when env var missing
- [ ] Non-workspace commands continue to work without `git`

### Semantic Verification Checklist

1. **Does the code DO what the requirement says?**
   - [ ] Missing env var → HTTP 400 (verified by test or manual check)
   - [ ] Present env var → `context.git` is defined GitService
   - [ ] Non-workspace command → `context.git` is undefined (no unnecessary initialization)

2. **Is this REAL implementation?**
   - [ ] 400 return is before `execute` call
   - [ ] `git` is actually passed in context

3. **Would tests FAIL if check was removed?**
   - [ ] Test verifies 400 response when env var absent

4. **Is the feature REACHABLE?**
   - [ ] `/executeCommand` endpoint is live in HTTP app

5. **Gaps before proceeding:**
   - [ ] None (list any found)

#### Feature Actually Works

```bash
# Start a2a server with checkpointing disabled, call restore list
# (manual verification — paste output)
# Expected: Error response indicating checkpointing not enabled OR empty list
```

## Success Criteria

- HTTP app tests pass
- TypeScript compiles
- Existing `/executeCommand` behavior (extensions command) unchanged

## Failure Recovery

1. `git checkout -- packages/a2a-server/src/http/app.ts`

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P5.md`

---

# Phase 6: Test Utilities Update

## Phase ID

`PLAN-20250219-GMERGE021.B8-FALLBACK.P6`

## Prerequisites

- Required: Phases 1–5 completed
- Verification: All prior phase completion markers present

## Requirements Implemented (Expanded)

### REQ-RESTORE-010: Test Mocks for Checkpointing Infrastructure

**Full Text**: The shared A2A server test utility mock config must include mocks for `getCheckpointingEnabled`, `storage.getProjectTempCheckpointsDir`, and `getGitService` so that tests can exercise checkpoint behavior without real filesystem or git operations.
**Behavior**:
- GIVEN: A test importing `createMockConfig` from `testing_utils.ts`
- WHEN: The mock is used in a restore command test
- THEN: All checkpoint-related methods are present and mockable
**Why This Matters**: Without these mocks, new tests for restore command and task checkpoint creation cannot be written without duplicating mock setup.

## Implementation Tasks

### Files to Modify

- `packages/a2a-server/src/utils/testing_utils.ts`
  - ADD to mock config: `getCheckpointingEnabled: vi.fn().mockReturnValue(false)`
  - ADD to mock storage: `getProjectTempCheckpointsDir: vi.fn().mockReturnValue('/tmp/test-checkpoints')`
  - ADD to mock config: `getGitService: vi.fn().mockResolvedValue({ restoreProjectFromSnapshot: vi.fn(), createSnapshot: vi.fn() })`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P6`

### Required Code Markers

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.B8-FALLBACK.P6
 * @requirement REQ-RESTORE-010
 */
```

## Verification Commands

```bash
# Phase markers present
grep -r "@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P6" packages/a2a-server/src | wc -l
# Expected: 1+ occurrences

# New mocks present
grep "getCheckpointingEnabled" packages/a2a-server/src/utils/testing_utils.ts
# Expected: 1 match

grep "getProjectTempCheckpointsDir" packages/a2a-server/src/utils/testing_utils.ts
# Expected: 1 match

grep "getGitService" packages/a2a-server/src/utils/testing_utils.ts
# Expected: 1 match

# Existing tests still pass
npx vitest run packages/a2a-server/src 2>&1 | tail -5
# Expected: All pass
```

### Structural Verification Checklist

- [ ] `getCheckpointingEnabled` mock added (default: `false`)
- [ ] `getProjectTempCheckpointsDir` mock added
- [ ] `getGitService` mock added (resolves to object with `restoreProjectFromSnapshot` and `createSnapshot`)
- [ ] Existing tests using `testing_utils.ts` still pass after additions

## Success Criteria

- All existing A2A server tests pass
- New restore and task tests can use the mock without additional setup

## Failure Recovery

1. `git checkout -- packages/a2a-server/src/utils/testing_utils.ts`

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P6.md`

---

# Phase 7: Full Test Suite

## Phase ID

`PLAN-20250219-GMERGE021.B8-FALLBACK.P7`

## Prerequisites

- Required: Phases 1–6 completed
- Verification: All prior phase markers present; all prior tests pass

## Requirements Implemented

### REQ-RESTORE-011: Comprehensive Behavioral Test Coverage

**Full Text**: All new code paths must have behavioral tests that verify actual outcomes and would catch a broken implementation.

## Implementation Tasks

### Core `checkpointUtils` Tests (`packages/core/src/utils/checkpointUtils.test.ts`)

Tests MUST cover (annotated with `@plan:PLAN-20250219-GMERGE021.B8-FALLBACK.P7`):

- `generateCheckpointFileName`:
  - Same timestamp + different `callId` → different filenames
  - Output contains no `:`, `/`, `\`
  - Output ends with `.json`

- `formatCheckpointDisplayList`:
  - Strips `.json`, joins with `\n`
  - Empty array → empty string

- `getTruncatedCheckpointNames`:
  - Returns array without `.json`
  - Empty array → empty array

- `getToolCallDataSchema`:
  - Validates `{ toolCall: { name: 'replace', args: {} } }` — PASS
  - Validates payload with all optional fields (`history`, `clientHistory`, `commitHash`) — PASS
  - Validates payload with unknown/extra fields — PASS (passthrough)
  - Rejects payload missing `toolCall` — FAIL
  - Accepts existing CLI-format checkpoint shape — PASS

- `getCheckpointInfoList`:
  - Empty directory → `[]`
  - Non-`.json` files excluded
  - Symlinks excluded
  - Returns lexicographically sorted names
  - Path traversal filenames (containing `/`) excluded

- `processRestorableToolCalls`:
  - Empty input → `{ checkpointsToWrite: empty, toolCallToCheckpointMap: empty, errors: [] }`
  - Non-restorable tool (e.g., `read_file`) excluded from output maps
  - Restorable tool (`replace`) → entry in both maps
  - Git snapshot failure → error collected, other tools still processed
  - With `geminiClient` → `clientHistory` in checkpoint JSON
  - Without `geminiClient` → `clientHistory` absent

### A2A Restore Command Tests (`packages/a2a-server/src/commands/restore.test.ts`)

- `ListCheckpointsCommand`:
  - Empty dir → empty list message
  - Dir with `.json` files → formatted list
  - Non-`.json` files excluded from list
  - Checkpointing disabled → error response (no throw)

- `RestoreCommand`:
  - No args → error response (missing checkpoint name)
  - Path traversal `../../../etc/passwd` → error response (rejected before file read)
  - Path traversal `subdir/name.json` → error response
  - Nonexistent checkpoint → error response
  - Symlink checkpoint file → error response
  - Schema-invalid checkpoint → error response
  - Valid checkpoint with `commitHash` and `context.git` present → calls `restoreProjectFromSnapshot`, returns success
  - Valid checkpoint without `commitHash` → returns success without calling git
  - `context.git` undefined when `commitHash` present → error response
  - `requiresWorkspace === true` on `RestoreCommand`
  - `requiresWorkspace` falsy on `ListCheckpointsCommand`

### Task Integration Tests

- Checkpointing disabled: `processRestorableToolCalls` not called; no files written; `request.checkpoint` not set
- Checkpointing enabled + `replace` tool call: checkpoint file written; `request.checkpoint` set to filename
- Checkpointing enabled + non-edit tool: no checkpoint written for that call
- Partial git failure: remaining checkpoints written; scheduling continues; error logged
- Atomic write: mock `rename` to throw → `request.checkpoint` not set; no partial state

### Regression Tests

- `ExtensionsCommand` and `ListExtensionsCommand` execute correctly after `CommandContext` migration
- `/executeCommand` passes `CommandContext` to extensions command (existing behavior unchanged)
- Command registry tests pass with updated mock signatures

## Verification Commands

```bash
# All tests pass
npm run test 2>&1 | tail -20
# Expected: All test suites pass

# No test failures
npm run test 2>&1 | grep -E "FAIL|failed"
# Expected: No output

# TypeCheck
npm run typecheck
# Expected: Exit 0

# Lint
npm run lint
# Expected: Exit 0

# Build
npm run build
# Expected: Exit 0

# Haiku smoke test
node scripts/start.js --profile-load synthetic "write me a haiku"
# Expected: A haiku is produced
```

### Semantic Verification Checklist

1. **All behavioral scenarios covered?**
   - [ ] Schema tests verify actual parse results (not just that `parse` was called)
   - [ ] Security tests verify rejection before file read
   - [ ] Atomic write test verifies no partial state

2. **Tests would catch broken implementations?**
   - [ ] Remove `path.basename` check → path traversal test fails
   - [ ] Remove `lstat` check → symlink test fails
   - [ ] Remove rename → atomic write test fails
   - [ ] Remove `EDIT_TOOL_NAMES` filter → non-edit tool gets checkpoint

3. **No mock theater?**
   - [ ] Tests verify actual returned values, not just that functions were called

## Success Criteria

- `npm run test` exits 0 — all tests pass
- `npm run typecheck` exits 0
- `npm run lint` exits 0
- `npm run build` exits 0
- Haiku smoke test succeeds
- `npm run format` clean

## Failure Recovery

Address test failures before proceeding. Phase 7 is the final quality gate.

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P7.md`

---

## Implementation Notes (Preserved from Original Plan)

### `performRestore` does not exist in LLxprt

The upstream commit references `performRestore()`. LLxprt's equivalent is `GitService.restoreProjectFromSnapshot(commitHash)`. Use that directly.

### CLI vs A2A restore semantics

These are intentionally different:
- **CLI**: Restores git state + in-process history + Gemini client history, then re-enqueues the tool call.
- **A2A**: Restores git state only; returns checkpoint data for the caller to decide on re-submission. Do NOT attempt to replicate `loadHistory` behavior in A2A.

### Checkpoint filename uniqueness

Use `<ISO-timestamp-sanitized>-<callId>-<toolName>.json`. The `callId` from `ToolCallRequestInfo` is already unique per call; combining with timestamp guarantees no collision even if multiple calls happen in the same millisecond.

### Backward compatibility of checkpoint schema

The Zod schema must accept files created by the CLI (no schema enforcement). Use `.passthrough()` on nested objects and make all fields except `toolCall` optional. Old checkpoints must pass without migration.

### Atomic checkpoint writes

```typescript
const tmpPath = `${finalPath}.tmp`;
await fs.promises.writeFile(tmpPath, JSON.stringify(data));
await fs.promises.rename(tmpPath, finalPath);
// Only set request.checkpoint after rename succeeds
```

### `Command.execute` migration is atomic

All command implementors and tests must be updated in the same change. Do not change the interface without simultaneously updating `extensions.ts`, `extensions.test.ts`, `command-registry.test.ts`, and `app.ts`.

### Security: checkpoint file validation in `RestoreCommand.execute`

1. `const safe = path.basename(args[0])` — reject if `safe !== args[0]`
2. Ensure `.json` extension
3. `fs.lstat` the resolved path — reject if symlink
4. Validate content with Zod schema before using any field

### Config: checkpointing default in a2a-server

`loadConfig()` in `packages/a2a-server/src/config/config.ts` does not currently pass `checkpointing` to `ConfigParameters`. Verify the default value; if it defaults to `false`, add the pass-through from settings or environment as part of Phase 4/5.

---

## Compatibility Matrix (Reference)

| Concern | CLI Behavior | A2A Target Behavior | Action |
|---------|-------------|---------------------|--------|
| Checkpoint JSON shape | `{ history?, clientHistory?, commitHash?, toolCall }` | Must match same shape | Schema uses `.passthrough()` for forward/backward compat |
| Git restore | `gitService.restoreProjectFromSnapshot(commitHash)` | Same | Reuse directly |
| History restore | Calls `loadHistory` | Not applicable | A2A: restore git state only |
| Re-execution | Returns re-enqueue signal | Returns checkpoint data | Caller decides |
| Checkpointing gate | `config.getCheckpointingEnabled()` | Same | Fail with clear error if disabled |

---

## File Changes Summary

| File | Action | Phase | Notes |
|------|--------|-------|-------|
| `packages/core/src/utils/checkpointUtils.ts` | CREATE | P1 | All checkpoint utility functions + `ToolCallData` type |
| `packages/core/src/utils/checkpointUtils.test.ts` | CREATE | P1/P7 | Full behavioral test coverage |
| `packages/core/src/tools/tool-names.ts` | MODIFY | P1 | Add `WRITE_FILE_TOOL_NAME`, `EDIT_TOOL_NAMES` |
| `packages/core/src/core/turn.ts` | MODIFY | P1 | Add `checkpoint?: string` to `ToolCallRequestInfo` |
| `packages/core/src/index.ts` | MODIFY | P1 | Export `checkpointUtils` |
| `packages/a2a-server/src/commands/types.ts` | MODIFY | P2 | Add `CommandContext`, `requiresWorkspace`; update signature |
| `packages/a2a-server/src/commands/extensions.ts` | MODIFY | P2 | Migrate to `CommandContext` |
| `packages/a2a-server/src/commands/extensions.test.ts` | MODIFY | P2 | Update mock signatures |
| `packages/a2a-server/src/commands/command-registry.ts` | MODIFY | P3 | Import and register `RestoreCommand` |
| `packages/a2a-server/src/commands/command-registry.test.ts` | MODIFY | P2 | Update mock execute signatures |
| `packages/a2a-server/src/commands/restore.ts` | CREATE | P3 | `RestoreCommand` + `ListCheckpointsCommand` |
| `packages/a2a-server/src/commands/restore.test.ts` | CREATE | P3/P7 | Full behavioral test coverage |
| `packages/a2a-server/src/agent/task.ts` | MODIFY | P4 | Atomic checkpoint creation in `scheduleToolCalls` |
| `packages/a2a-server/src/http/app.ts` | MODIFY | P2/P5 | `CommandContext` construction; workspace + git validation |
| `packages/a2a-server/src/utils/testing_utils.ts` | MODIFY | P6 | Add checkpoint and git mocks |

---

## Execution Tracker

| Phase | ID | Status | Started | Completed | Verified | Semantic? | Notes |
|-------|-----|--------|---------|-----------|----------|-----------|-------|
| 0.5 | P0.5 | ⬜ | - | - | - | N/A | Preflight verification |
| 1 | P1 | ⬜ | - | - | - | ⬜ | Core checkpoint utilities |
| 2 | P2 | ⬜ | - | - | - | ⬜ | Command interface migration (atomic) |
| 3 | P3 | ⬜ | - | - | - | ⬜ | Restore command |
| 4 | P4 | ⬜ | - | - | - | ⬜ | Task checkpoint creation |
| 5 | P5 | ⬜ | - | - | - | ⬜ | HTTP app integration |
| 6 | P6 | ⬜ | - | - | - | ⬜ | Test utilities |
| 7 | P7 | ⬜ | - | - | - | ⬜ | Full test suite |

Update after EACH phase completion.
