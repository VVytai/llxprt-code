# Plan: Hooks Commands Panel, Enable/Disable, and Migrate

Plan ID: PLAN-20250219-GMERGE021.R5
Generated: 2025-02-19
Total Phases: 8
Requirements: REQ-HOOKS-001 through REQ-HOOKS-007

## Critical Reminders

Before implementing ANY phase, ensure you have:

1. Completed preflight verification (Phase P00.5)
2. Confirmed `1c12da1fad14` (Hook Session Lifecycle) is implemented — `HookSystem.getAllHooks()` must exist
3. Written integration tests BEFORE unit tests
4. Verified all dependencies and types exist as assumed

---

# Execution Tracker

| Phase | ID | Status | Started | Completed | Verified | Semantic? | Notes |
|-------|-----|--------|---------|-----------|----------|-----------|-------|
| 0.5 | P00.5 | ⬜ | - | - | - | N/A | Preflight verification |
| 01 | P01 | ⬜ | - | - | - | ⬜ | Settings schema enhancement |
| 02 | P02 | ⬜ | - | - | - | ⬜ | Settings runtime merge fix |
| 03 | P03 | ⬜ | - | - | - | ⬜ | Config enhancement |
| 04 | P04 | ⬜ | - | - | - | ⬜ | HookRegistry integration |
| 05 | P05 | ⬜ | - | - | - | ⬜ | CLI hooks command |
| 06 | P06 | ⬜ | - | - | - | ⬜ | UI hooks slash commands |
| 07 | P07 | ⬜ | - | - | - | ⬜ | UI components |
| 08 | P08 | ⬜ | - | - | - | ⬜ | Final integration verification |

---

# Phase P00.5: Preflight Verification

## Phase ID

`PLAN-20250219-GMERGE021.R5.P00.5`

## Purpose

Verify ALL assumptions before writing any code.

## Commit Context

- **Commit:** b8c038f41f82
- **Date:** 2025-12-03
- **Author:** Edilmo Palencia
- **Summary:** Adds hooks CLI command with migrate subcommand, UI hooks panel/enable/disable commands, and disabled hooks support in settings.

## Dependency Ordering

Before implementing, verify these commits are already in place:

1. **`1c12da1fad14` (Hook Session Lifecycle)** — required; `HookSystem.getAllHooks()` must exist
2. **`8d4082ef2e38` (Hook System Documentation)** — review for API naming alignment
3. **`eb3312e7baaf` (Extension Hooks Security)** — subsequent commit; not needed for this plan

## Dependency Verification

| Dependency | Verification Command | Status |
|------------|---------------------|--------|
| `HookSystem.getAllHooks()` | `grep -n "getAllHooks" packages/core/src/hooks/hookSystem.ts` | VERIFY |
| `HookRegistry.setHookEnabled()` | `grep -n "setHookEnabled" packages/core/src/hooks/hookRegistry.ts` | VERIFY |
| `strip-json-comments` | `npm ls strip-json-comments` | VERIFY |
| Slash command infrastructure | `ls packages/cli/src/ui/commands/` | VERIFY |
| `MessageType` enum | `grep -n "MessageType" packages/cli/src/ui/types.ts` | VERIFY |

## Gap Analysis — Current LLxprt State

| Feature | Status | Notes |
|---------|--------|-------|
| `llxprt hooks` CLI command | **MISSING** | Need `packages/cli/src/commands/hooks.tsx` |
| `/hooks` slash command | **MISSING** | Need `packages/cli/src/ui/commands/hooksCommand.ts` |
| `hooks.disabled` in settings schema | **MISSING** | Need to add to `settingsSchema.ts` |
| `hooks.disabled` merge in `mergeSettings()` | **MISSING** | Must add explicit merge logic |
| `getDisabledHooks()` in Config | **MISSING** | Need to add to `packages/core/src/config/config.ts` |
| HooksList UI component | **MISSING** | Need `packages/cli/src/ui/components/views/HooksList.tsx` |
| HookRegistry disabled support | **PARTIAL** | Has `setHookEnabled()`, need to read from settings at init |
| `HookSystem.getAllHooks()` | **EXISTS** | Already implemented |
| `strip-json-comments` dependency | **EXISTS** | Used in `settings.ts` and `trustedFolders.ts` — no new dep needed |

## Type/Interface Verification

| Type Name | Expected Definition | Verification Command | Match? |
|-----------|---------------------|---------------------|--------|
| `HookEventName` | Enum/union of hook event names | `grep -n "HookEventName" packages/core/src/hooks/` | VERIFY |
| `HookDefinition` | Hook config structure | `grep -n "HookDefinition" packages/core/src/hooks/` | VERIFY |
| `HistoryItemWithoutId` | Union type in `ui/types.ts` | `grep -n "HistoryItemWithoutId" packages/cli/src/ui/types.ts` | VERIFY |
| `MergeStrategy` enum | Available in `settingsSchema.ts` | `grep -n "MergeStrategy" packages/cli/src/config/settingsSchema.ts` | VERIFY |

## Critical Architecture Notes

| Note | Impact |
|------|--------|
| `getMergeStrategyForPath` **does not exist** | Hooks merging must be added directly to `mergeSettings()` — not via schema annotation |
| `MergeStrategy` enum is **informational only** | Runtime merge behavior is controlled exclusively by `mergeSettings()` |
| `Config.getHooks()` includes `disabled` key | Must filter it out in `getHooks()` and expose via separate `getDisabledHooks()` |
| `setHookEnabled()` matches by command string | `hooks.disabled` list uses command strings — acceptable since commands are the only stable identifier |
| `$CLAUDE_PROJECT_DIR` already handled | `hookRunner.ts` already substitutes all three env var names — migrate rename is cosmetic only |

## Verification Gate

- [ ] All dependencies verified as present
- [ ] All types match expected definitions
- [ ] Gap analysis confirmed accurate against current codebase
- [ ] No additional blocking issues found

**IF ANY CHECKBOX IS UNCHECKED: STOP and update plan before proceeding.**

---

# Phase P01: Settings Schema Enhancement (TDD)

## Phase ID

`PLAN-20250219-GMERGE021.R5.P01`

## Prerequisites

- Required: Phase P00.5 completed
- Verification: Preflight gate all checked
- Expected from P00.5: Confirmed `MergeStrategy` enum and `settingsSchema.ts` structure

## Requirements Implemented (Expanded)

### REQ-HOOKS-001: Disabled Hooks Schema

**Full Text**: The settings schema MUST define a `hooks.disabled` array property that stores command strings for hooks that should be disabled.
**Behavior**:
- GIVEN: A settings file with `hooks: { disabled: ["echo my-hook"] }`
- WHEN: Settings are loaded and validated against the schema
- THEN: The `disabled` field is recognized as a valid array of strings
**Why This Matters**: Without schema definition, the `disabled` field would be rejected or ignored by settings validation.

### REQ-HOOKS-002: Disabled Hooks Merge Strategy

**Full Text**: When merging settings across layers (system, user, workspace), the `hooks.disabled` array MUST be union-merged (deduplicated), and hook event arrays MUST be concatenated.
**Behavior**:
- GIVEN: User settings have `hooks.disabled: ["cmd-a"]` and workspace has `hooks.disabled: ["cmd-b"]`
- WHEN: Settings are merged via `mergeSettings()`
- THEN: Result has `hooks.disabled: ["cmd-a", "cmd-b"]` and hook event arrays from both layers combined
**Why This Matters**: Users need workspace-level disabled hooks to not overwrite user-level ones.

## Implementation Tasks

### Files to Modify

- `packages/cli/src/config/settingsSchema.ts`
  - Expand `hooks` setting to include `disabled` sub-property with `type: 'array'`, `mergeStrategy: MergeStrategy.UNION`
  - Add `additionalProperties` with `mergeStrategy: MergeStrategy.CONCAT` for hook event arrays
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.R5.P01`
  - Implements: `@requirement:REQ-HOOKS-001`

### Required Code Markers

Every function/class/test created in this phase MUST include:

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.R5.P01
 * @requirement REQ-HOOKS-001
 */
```

### Tests to Write First (Failing)

In `packages/cli/src/config/settingsSchema.test.ts`:

```typescript
// FAILING TEST: hooks schema has disabled sub-property
it('hooks schema has disabled array property @plan:PLAN-20250219-GMERGE021.R5.P01 @requirement:REQ-HOOKS-001', () => {
  const hooksSchema = SETTINGS_SCHEMA.hooks;
  expect(hooksSchema.properties?.disabled).toBeDefined();
  expect(hooksSchema.properties?.disabled.type).toBe('array');
});

// FAILING TEST: schema validation rejects non-string entries in hooks.disabled
it('schema rejects non-string entries in hooks.disabled @plan:PLAN-20250219-GMERGE021.R5.P01 @requirement:REQ-HOOKS-001', () => {
  // Validate that items schema specifies type: 'string'
  const hooksSchema = SETTINGS_SCHEMA.hooks;
  expect(hooksSchema.properties?.disabled.items?.type).toBe('string');
});
```

### Schema Addition

```typescript
hooks: {
  type: 'object',
  label: 'Hooks',
  category: 'Advanced',
  requiresRestart: false,
  default: {} as { disabled?: string[]; [K: string]: HookDefinition[] | string[] | undefined },
  description: 'Hook configurations for intercepting and customizing agent behavior.',
  showInDialog: false,
  mergeStrategy: MergeStrategy.SHALLOW_MERGE,
  properties: {
    disabled: {
      type: 'array',
      label: 'Disabled Hooks',
      default: [] as string[],
      description: 'List of hook command strings that should be disabled.',
      showInDialog: false,
      mergeStrategy: MergeStrategy.UNION,
      items: { type: 'string' },
    },
  },
  additionalProperties: {
    type: 'array',
    mergeStrategy: MergeStrategy.CONCAT,
  },
},
```

## Verification Commands

### Automated Checks (Structural)

```bash
# Check plan markers exist
grep -r "@plan:PLAN-20250219-GMERGE021.R5.P01" . | wc -l
# Expected: 2+ occurrences

# Check requirements covered
grep -r "@requirement:REQ-HOOKS-001" . | wc -l
# Expected: 2+ occurrences

# Verify disabled property added
grep -n "disabled" packages/cli/src/config/settingsSchema.ts | head -10
# Expected: shows disabled property definition

# Run phase tests
npm run test -- --testPathPattern=settingsSchema
# Expected: new tests pass
```

### Deferred Implementation Detection (MANDATORY)

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB|XXX)" packages/cli/src/config/settingsSchema.ts | grep -v ".test.ts"
# Expected: No matches
```

### Structural Verification Checklist

- [ ] P00.5 preflight gate completed
- [ ] `hooks.disabled` property added to schema with correct type
- [ ] `items: { type: 'string' }` defined
- [ ] `mergeStrategy: MergeStrategy.UNION` set on disabled
- [ ] `additionalProperties` with `MergeStrategy.CONCAT` set on parent
- [ ] Plan markers added to all changes
- [ ] Tests pass for this phase

### Semantic Verification Checklist (MANDATORY)

1. **Does the code DO what the requirement says?**
   - [ ] Schema now defines `disabled` as a string array
   - [ ] Items type is `string`, not `any`

2. **Is this REAL implementation, not placeholder?**
   - [ ] No empty type definitions
   - [ ] `mergeStrategy` annotation is set correctly

3. **Would the test FAIL if implementation was removed?**
   - [ ] Test checks `hooksSchema.properties?.disabled` exists
   - [ ] Test checks `type` is `'array'`

4. **Is the feature REACHABLE?**
   - [ ] Schema is read by `mergeSettings()` (verified in P02)

## Success Criteria

- Schema defines `hooks.disabled` as `array` of `string`
- `additionalProperties` marks event arrays for concat merge
- Tests pass for schema structure

## Failure Recovery

If this phase fails:

1. `git checkout -- packages/cli/src/config/settingsSchema.ts`
2. Re-run Phase P01 with corrected schema

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P01.md`

---

# Phase P02: Settings Runtime Merge Fix (TDD)

## Phase ID

`PLAN-20250219-GMERGE021.R5.P02`

## Prerequisites

- Required: Phase P01 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.R5.P01" .`
- Expected files from P01: `settingsSchema.ts` with `disabled` property

## Requirements Implemented (Expanded)

### REQ-HOOKS-002: Runtime Merge of `hooks.disabled`

**Full Text**: `mergeSettings()` MUST union-merge `hooks.disabled` across all layers and concatenate hook event arrays.
**Behavior**:
- GIVEN: User settings `hooks.disabled: ["cmd-a"]` and workspace `hooks.disabled: ["cmd-b"]`
- WHEN: `mergeSettings(system, {}, user, workspace, true)` is called
- THEN: Result `hooks.disabled` contains both `"cmd-a"` and `"cmd-b"` (deduplicated), and event arrays from both layers are concatenated
**Why This Matters**: `MergeStrategy` annotations are not read at runtime — `mergeSettings()` is the sole authority for merge behavior.

## Implementation Tasks

### Files to Modify

- `packages/cli/src/config/settings.ts`
  - Add hooks-specific merge block to `mergeSettings()` after the `extensions` block
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.R5.P02`
  - Implements: `@requirement:REQ-HOOKS-002`

### Tests to Write First (Failing)

In `packages/cli/src/config/settingsSchema.test.ts` (or `settings.test.ts`):

```typescript
// FAILING TEST: mergeSettings unions hooks.disabled across layers
it('mergeSettings unions hooks.disabled from user and workspace @plan:PLAN-20250219-GMERGE021.R5.P02 @requirement:REQ-HOOKS-002', () => {
  const user = { hooks: { disabled: ['cmd-a'] } };
  const workspace = { hooks: { disabled: ['cmd-b'] } };
  const merged = mergeSettings(system, {}, user, workspace, true);
  expect(merged.hooks?.disabled).toContain('cmd-a');
  expect(merged.hooks?.disabled).toContain('cmd-b');
  expect(merged.hooks?.disabled).toHaveLength(2);
});

// FAILING TEST: mergeSettings concatenates hook event arrays
it('mergeSettings concatenates hook event arrays from user and workspace @plan:PLAN-20250219-GMERGE021.R5.P02 @requirement:REQ-HOOKS-002', () => {
  const hookDef = { hooks: [{ type: 'command', command: 'echo test' }] };
  const user = { hooks: { BeforeTool: [hookDef] } };
  const workspace = { hooks: { BeforeTool: [hookDef] } };
  const merged = mergeSettings(system, {}, user, workspace, true);
  expect(merged.hooks?.BeforeTool).toHaveLength(2);
});
```

### Merge Logic to Add to `mergeSettings()`

```typescript
// Merge hooks: concat event arrays, union disabled list
// @plan PLAN-20250219-GMERGE021.R5.P02
// @requirement REQ-HOOKS-002
const allHooksLayers = [systemDefaults.hooks, user.hooks, safeWorkspace.hooks, system.hooks]
  .filter(Boolean) as Array<Record<string, unknown>>;

const mergedHooks: Record<string, unknown> = {};
const allHookKeys = new Set(allHooksLayers.flatMap((h) => Object.keys(h)));

for (const key of allHookKeys) {
  if (key === 'disabled') {
    mergedHooks.disabled = [
      ...new Set(allHooksLayers.flatMap((h) => (h.disabled as string[] | undefined) ?? [])),
    ];
  } else {
    const arrays = allHooksLayers
      .map((h) => h[key])
      .filter(Array.isArray)
      .flat();
    if (arrays.length > 0) {
      mergedHooks[key] = arrays;
    }
  }
}
// Add to returned merged object: hooks: mergedHooks,
```

## Verification Commands

### Automated Checks (Structural)

```bash
# Check plan markers exist
grep -r "@plan:PLAN-20250219-GMERGE021.R5.P02" . | wc -l
# Expected: 2+ occurrences

# Run settings tests
npm run test -- --testPathPattern=settings
# Expected: all pass
```

### Deferred Implementation Detection (MANDATORY)

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB)" packages/cli/src/config/settings.ts | grep -v ".test.ts"
# Expected: No matches

grep -rn -E "return \[\]|return \{\}" packages/cli/src/config/settings.ts | grep -v ".test.ts"
# Expected: No matches in merge logic
```

### Structural Verification Checklist

- [ ] P01 markers present in settingsSchema.ts
- [ ] `mergeSettings()` has hooks block with event-concat and disabled-union logic
- [ ] Tests for union merge pass
- [ ] Tests for event concat pass
- [ ] Plan markers added

### Semantic Verification Checklist (MANDATORY)

1. **Does the code DO what the requirement says?**
   - [ ] `disabled` arrays are union-merged (not overwritten)
   - [ ] Hook event arrays are concatenated (not last-wins)

2. **Is this REAL implementation, not placeholder?**
   - [ ] `Set` deduplication actually applied to `disabled`
   - [ ] `Array.isArray` filter applied to event arrays

3. **Would the test FAIL if implementation was removed?**
   - [ ] Test asserts length = 2 after merging two 1-item arrays
   - [ ] Test verifies both values present in result

4. **Is the feature REACHABLE?**
   - [ ] `mergeSettings()` is called during config load (verify call site)

## Success Criteria

- `mergeSettings()` union-merges `hooks.disabled`
- `mergeSettings()` concatenates hook event arrays
- All tests pass

## Failure Recovery

If this phase fails:

1. `git checkout -- packages/cli/src/config/settings.ts`
2. Re-run Phase P02

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P02.md`

---

# Phase P03: Config Enhancement (TDD)

## Phase ID

`PLAN-20250219-GMERGE021.R5.P03`

## Prerequisites

- Required: Phase P02 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.R5.P02" .`
- Expected files from P02: `settings.ts` with hooks merge logic

## Requirements Implemented (Expanded)

### REQ-HOOKS-003: Config `getDisabledHooks()` Method

**Full Text**: `Config` MUST expose a `getDisabledHooks(): string[]` method and `getHooks()` MUST NOT include the `disabled` key in its return value.
**Behavior**:
- GIVEN: Config constructed with `hooks: { disabled: ['cmd-x'], BeforeTool: [] }`
- WHEN: `config.getDisabledHooks()` is called
- THEN: Returns `['cmd-x']`
- WHEN: `config.getHooks()` is called
- THEN: Returns object without `disabled` key, with `BeforeTool` present
**Why This Matters**: `HookRegistry.processHooksConfiguration()` iterates event-name keys — a `disabled` key would be treated as an invalid `HookEventName` and cause a crash.

## Implementation Tasks

### Files to Modify

- `packages/core/src/config/config.ts`
  - Add `disabledHooks: string[]` private property
  - Add `getDisabledHooks(): string[]` method
  - Update `getHooks()` to strip `disabled` key before returning
  - Widen `hooks` type in `ConfigParameters` to allow `disabled?: string[]`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.R5.P03`
  - Implements: `@requirement:REQ-HOOKS-003`

### Tests to Write First (Failing)

In `packages/core/src/config/config.test.ts`:

```typescript
it('getDisabledHooks() returns empty array when no hooks.disabled configured @plan:PLAN-20250219-GMERGE021.R5.P03 @requirement:REQ-HOOKS-003', () => {
  const config = new Config({ ...baseParams, hooks: { BeforeTool: [] } });
  expect(config.getDisabledHooks()).toEqual([]);
});

it('getDisabledHooks() returns disabled list from hooks config @plan:PLAN-20250219-GMERGE021.R5.P03 @requirement:REQ-HOOKS-003', () => {
  const config = new Config({ ...baseParams, hooks: { disabled: ['cmd-x', 'cmd-y'], BeforeTool: [] } });
  expect(config.getDisabledHooks()).toEqual(['cmd-x', 'cmd-y']);
});

it('getHooks() does not include disabled key in returned object @plan:PLAN-20250219-GMERGE021.R5.P03 @requirement:REQ-HOOKS-003', () => {
  const config = new Config({ ...baseParams, hooks: { disabled: ['cmd-x'], BeforeTool: [] } });
  const hooks = config.getHooks();
  expect('disabled' in hooks!).toBe(false);
  expect(hooks!.BeforeTool).toBeDefined();
});
```

### Code to Add

```typescript
// In ConfigParameters interface — widen hooks type:
hooks?:
  | { [K in HookEventName]?: HookDefinition[] }
  | ({ [K in HookEventName]?: HookDefinition[] } & { disabled?: string[] });

// Private property:
private readonly disabledHooks: string[];

// In constructor:
this.disabledHooks =
  (params.hooks && 'disabled' in params.hooks
    ? (params.hooks as { disabled?: string[] }).disabled
    : undefined) ?? [];

// Getter:
/**
 * @plan PLAN-20250219-GMERGE021.R5.P03
 * @requirement REQ-HOOKS-003
 */
getDisabledHooks(): string[] {
  return this.disabledHooks;
}

// Updated getHooks():
getHooks(): { [K in HookEventName]?: HookDefinition[] } | undefined {
  if (!this.hooks) return undefined;
  const { disabled: _removed, ...eventHooks } = this.hooks as Record<string, unknown> & { disabled?: string[] };
  return eventHooks as { [K in HookEventName]?: HookDefinition[] };
}
```

### Mock Updates Required

Any test file that mocks `Config` must add:

```typescript
getDisabledHooks: vi.fn().mockReturnValue([]),
```

## Verification Commands

### Automated Checks (Structural)

```bash
# Check plan markers exist
grep -r "@plan:PLAN-20250219-GMERGE021.R5.P03" . | wc -l
# Expected: 3+ occurrences

grep -n "getDisabledHooks\|disabledHooks" packages/core/src/config/config.ts
# Expected: method and property definitions

npm run test -- --testPathPattern=config
# Expected: all pass including new tests

npm run typecheck
# Expected: no errors
```

### Deferred Implementation Detection (MANDATORY)

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB)" packages/core/src/config/config.ts | grep -v ".test.ts"
# Expected: No matches
```

### Structural Verification Checklist

- [ ] P02 markers present in settings.ts
- [ ] `getDisabledHooks()` method exists and returns `string[]`
- [ ] `getHooks()` strips `disabled` key before returning
- [ ] `ConfigParameters.hooks` type widened
- [ ] All Config mocks updated with `getDisabledHooks`
- [ ] TypeScript compiles without error

### Semantic Verification Checklist (MANDATORY)

1. **Does the code DO what the requirement says?**
   - [ ] `getDisabledHooks()` extracts `disabled` from hooks config
   - [ ] `getHooks()` destructures out `disabled` before returning

2. **Is this REAL implementation, not placeholder?**
   - [ ] No `return []` without actual extraction logic
   - [ ] Destructuring actually removes the key

3. **Would the test FAIL if implementation was removed?**
   - [ ] Test asserts `'disabled' in hooks` is `false` — would fail if not stripped

4. **Is the feature REACHABLE?**
   - [ ] `getDisabledHooks()` will be called from `HookRegistry` in P04

## Success Criteria

- `getDisabledHooks()` returns `string[]` from hooks config
- `getHooks()` never returns the `disabled` key
- TypeScript compiles, all tests pass

## Failure Recovery

If this phase fails:

1. `git checkout -- packages/core/src/config/config.ts`
2. Revert any mock updates
3. Re-run Phase P03

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P03.md`

---

# Phase P04: HookRegistry Integration (TDD)

## Phase ID

`PLAN-20250219-GMERGE021.R5.P04`

## Prerequisites

- Required: Phase P03 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.R5.P03" .`
- Expected files from P03: `config.ts` with `getDisabledHooks()`

## Requirements Implemented (Expanded)

### REQ-HOOKS-004: Disabled Hooks Applied at Registration

**Full Text**: `HookRegistry` MUST apply the `hooks.disabled` list after registering all hooks, so hooks whose command strings are in the disabled list start with `enabled: false`.
**Behavior**:
- GIVEN: Config has `hooks.disabled: ["echo my-hook"]` and a hook with `command: "echo my-hook"` is registered
- WHEN: `registry.initialize()` is called
- THEN: `registry.getAllHooks()[0].enabled` is `false`
- GIVEN: Hook command is NOT in disabled list
- THEN: `registry.getAllHooks()[0].enabled` is `true`
**Why This Matters**: Persisted disabled hooks must be restored on startup — otherwise users must manually re-disable hooks every session.

## Implementation Tasks

### Files to Modify

- `packages/core/src/hooks/hookRegistry.ts`
  - In `processHooksFromConfig()`: call `getDisabledHooks()` after all hooks registered and apply via `setHookEnabled()`
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.R5.P04`
  - Implements: `@requirement:REQ-HOOKS-004`
- `packages/core/src/hooks/hookRegistry.test.ts`
  - Add tests for disabled list behavior

### Tests to Write First (Failing)

```typescript
// FAILING TEST: hooks in disabled list start disabled
it('hooks with command in disabled list start disabled @plan:PLAN-20250219-GMERGE021.R5.P04 @requirement:REQ-HOOKS-004', async () => {
  const mockConfig = createMockConfig({
    hooks: { BeforeTool: [{ hooks: [{ type: 'command', command: 'echo disabled' }] }] },
    disabledHooks: ['echo disabled'],
  });
  const registry = new HookRegistry(mockConfig);
  await registry.initialize();
  const all = registry.getAllHooks();
  expect(all[0].enabled).toBe(false);
});

// FAILING TEST: hooks not in disabled list start enabled
it('hooks with command not in disabled list start enabled @plan:PLAN-20250219-GMERGE021.R5.P04 @requirement:REQ-HOOKS-004', async () => {
  const mockConfig = createMockConfig({
    hooks: { BeforeTool: [{ hooks: [{ type: 'command', command: 'echo allowed' }] }] },
    disabledHooks: ['echo other'],
  });
  const registry = new HookRegistry(mockConfig);
  await registry.initialize();
  const all = registry.getAllHooks();
  expect(all[0].enabled).toBe(true);
});

// FAILING TEST: multiple hooks sharing same command all disabled when in disabled list
it('all hooks sharing same command are disabled when command in disabled list @plan:PLAN-20250219-GMERGE021.R5.P04 @requirement:REQ-HOOKS-004', async () => {
  const hookDef = { hooks: [{ type: 'command', command: 'shared-cmd' }] };
  const mockConfig = createMockConfig({
    hooks: { BeforeTool: [hookDef], AfterTool: [hookDef] },
    disabledHooks: ['shared-cmd'],
  });
  const registry = new HookRegistry(mockConfig);
  await registry.initialize();
  const all = registry.getAllHooks();
  expect(all.every((h) => !h.enabled)).toBe(true);
});

// FAILING TEST: does not crash when disabled list is non-empty
it('processHooksFromConfig does not crash when disabled list is non-empty @plan:PLAN-20250219-GMERGE021.R5.P04 @requirement:REQ-HOOKS-004', async () => {
  const mockConfig = createMockConfig({
    hooks: { BeforeTool: [] },
    disabledHooks: ['something'],
  });
  const registry = new HookRegistry(mockConfig);
  await expect(registry.initialize()).resolves.not.toThrow();
});
```

### Code to Add to `processHooksFromConfig()`

```typescript
private processHooksFromConfig(): void {
  const configHooks = this.config.getHooks(); // already strips 'disabled' key
  if (configHooks) {
    this.processHooksConfiguration(configHooks, ConfigSource.Project);
  }

  const extensions = this.config.getExtensions() || [];
  for (const extension of extensions) {
    if (extension.isActive && extension.hooks) {
      this.processHooksConfiguration(extension.hooks, ConfigSource.Extensions);
    }
  }

  // @plan PLAN-20250219-GMERGE021.R5.P04
  // @requirement REQ-HOOKS-004
  // Apply disabled list from config after all hooks are registered
  const disabledHooks = this.config.getDisabledHooks() ?? [];
  for (const commandName of disabledHooks) {
    this.setHookEnabled(commandName, false);
  }
}
```

## Verification Commands

### Automated Checks (Structural)

```bash
grep -r "@plan:PLAN-20250219-GMERGE021.R5.P04" . | wc -l
# Expected: 4+ occurrences

grep -n "getDisabledHooks" packages/core/src/hooks/hookRegistry.ts
# Expected: call in processHooksFromConfig

npm run test -- --testPathPattern=hookRegistry
# Expected: all pass
```

### Deferred Implementation Detection (MANDATORY)

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB)" packages/core/src/hooks/hookRegistry.ts | grep -v ".test.ts"
# Expected: No matches
```

### Structural Verification Checklist

- [ ] P03 markers present in config.ts
- [ ] `processHooksFromConfig()` calls `getDisabledHooks()`
- [ ] Disabled hooks applied after all hooks registered
- [ ] All 4 new tests pass
- [ ] TypeScript compiles

### Semantic Verification Checklist (MANDATORY)

1. **Does the code DO what the requirement says?**
   - [ ] Hooks in disabled list have `enabled: false` after init
   - [ ] Hooks not in disabled list have `enabled: true`

2. **Is this REAL implementation, not placeholder?**
   - [ ] Loop actually calls `setHookEnabled(commandName, false)`
   - [ ] Not skipped if list is empty (length 0 = no-op, fine)

3. **Would the test FAIL if implementation was removed?**
   - [ ] Yes — test asserts `enabled === false`

4. **Is the feature REACHABLE?**
   - [ ] `processHooksFromConfig()` is called during `initialize()` (verify call chain)

## Success Criteria

- Hooks in disabled list start with `enabled: false`
- Hooks not in disabled list start with `enabled: true`
- No crash when disabled list is non-empty but no hooks match

## Failure Recovery

If this phase fails:

1. `git checkout -- packages/core/src/hooks/hookRegistry.ts`
2. Re-run Phase P04

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P04.md`

---

# Phase P05: CLI Hooks Command (TDD)

## Phase ID

`PLAN-20250219-GMERGE021.R5.P05`

## Prerequisites

- Required: Phase P04 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.R5.P04" .`
- Expected files from P04: `hookRegistry.ts` with disabled list applied at init

## Requirements Implemented (Expanded)

### REQ-HOOKS-005: `llxprt hooks migrate` CLI Command

**Full Text**: The CLI MUST provide a `hooks migrate` subcommand that reads Claude Code settings files (JSONC), maps event/tool names to LLxprt equivalents, and writes the result to LLxprt hook settings.
**Behavior**:
- GIVEN: Claude settings at `~/.claude/settings.json` with `PreToolUse` hooks
- WHEN: `llxprt hooks migrate` is run
- THEN: LLxprt settings are updated with `BeforeTool` hooks using mapped event names
- GIVEN: Claude settings file does not exist at specified path
- WHEN: `llxprt hooks migrate --from /nonexistent` is run
- THEN: Command exits with a descriptive error: "Claude settings file not found"
**Why This Matters**: Users migrating from Claude Code need their hook configurations preserved without manual rewriting.

## Implementation Tasks

### Files to Create

- `packages/cli/src/commands/hooks.tsx`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.R5.P05`
  - MUST include: `@requirement:REQ-HOOKS-005`
  - Top-level yargs `CommandModule` with `migrate` subcommand

- `packages/cli/src/commands/hooks/migrate.ts`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.R5.P05`
  - MUST include: `@requirement:REQ-HOOKS-005`
  - Migration logic with event/tool name mapping

- `packages/cli/src/commands/hooks/migrate.test.ts`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.R5.P05`
  - MUST include: `@requirement:REQ-HOOKS-005`

### Files to Modify

- `packages/cli/src/config/config.ts` (CLI config — NOT core)
  - Register `hooksCommand` when `tools.enableHooks` is true
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.R5.P05`

### Tests to Write First (Failing)

```typescript
// FAILING TEST: Claude PreToolUse maps to LLxprt BeforeTool
it('maps Claude PreToolUse event to LLxprt BeforeTool @plan:PLAN-20250219-GMERGE021.R5.P05 @requirement:REQ-HOOKS-005', () => {
  expect(mapClaudeEventName('PreToolUse')).toBe('BeforeTool');
});

// FAILING TEST: unknown Claude event name is passed through with warning
it('preserves unknown Claude event names with a warning @plan:PLAN-20250219-GMERGE021.R5.P05 @requirement:REQ-HOOKS-005', () => {
  expect(mapClaudeEventName('UnknownEvent')).toBe('UnknownEvent');
});

// FAILING TEST: missing Claude settings file produces clear error
it('throws descriptive error when Claude settings not found @plan:PLAN-20250219-GMERGE021.R5.P05 @requirement:REQ-HOOKS-005', async () => {
  await expect(migrateFromClaude({ from: '/nonexistent' }))
    .rejects.toThrow(/Claude settings file not found/);
});

// FAILING TEST: JSONC source with comments is parsed correctly
it('parses Claude settings with JSON comments @plan:PLAN-20250219-GMERGE021.R5.P05 @requirement:REQ-HOOKS-005', async () => {
  const jsonc = '{ /* comment */ "hooks": { "PreToolUse": [] } }';
  const result = parseClaudeSettings(jsonc);
  expect(result.hooks).toBeDefined();
});

// FAILING TEST: --merge flag concatenates with existing hooks
it('merges into existing hooks when --merge flag is set @plan:PLAN-20250219-GMERGE021.R5.P05 @requirement:REQ-HOOKS-005', async () => {
  // verify existing hooks survive when --merge is passed
});

// FAILING TEST: warns if target has existing hooks without --merge
it('prompts for confirmation when target has existing hooks without --merge @plan:PLAN-20250219-GMERGE021.R5.P05 @requirement:REQ-HOOKS-005', async () => {
  // verify confirmation required
});
```

### Event Name Mapping Table

| Claude Event | LLxprt Event |
|---|---|
| `PreToolUse` | `BeforeTool` |
| `PostToolUse` | `AfterTool` |
| `UserPromptSubmit` | `BeforeAgent` |
| `Stop` | `AfterAgent` |
| `SessionStart` | `SessionStart` |
| `SessionEnd` | `SessionEnd` |
| `PreCompact` | `PreCompress` |
| `Notification` | `Notification` |

Unknown event names: passed through unchanged with a warning logged.

### Tool Name Mapping Table (for matchers)

| Claude Tool | LLxprt Tool |
|---|---|
| `Edit` | `replace` |
| `Bash` | `run_shell_command` |
| `Read` | `read_file` |
| `Write` | `write_file` |
| `LS` | `list_directory` |
| `Glob` | `glob` |
| `Grep` | `search_file_content` |
| `Task` | `task` |
| `WebSearch` | `web_search` |
| `WebFetch` | `web_fetch` |

Unknown tool names: passed through unchanged with a warning logged.

### `hooks.tsx` Structure

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.R5.P05
 * @requirement REQ-HOOKS-005
 */
export const hooksCommand: CommandModule = {
  command: 'hooks <command>',
  aliases: ['hook'],
  describe: 'Manage LLxprt CLI hooks.',
  builder: (yargs) =>
    yargs
      .middleware(() => initializeOutputListenersAndFlush())
      .command(migrateCommand)
      .demandCommand(1, 'You need at least one command before continuing.')
      .version(false),
  handler: () => {},
};
```

### Key Implementation Notes

- Use `strip-json-comments` (already in CLI package) to handle JSONC
- Look for `.claude/settings.json` or `.claude/settings.local.json`
- `--merge` flag: concatenate migrated hooks with existing LLxprt hooks
- Without `--merge` and existing hooks: warn and require `--overwrite`
- `--from <path>`: specify alternate Claude settings path
- `$CLAUDE_PROJECT_DIR` renaming is cosmetic only — `hookRunner.ts` already handles all three env var names

## Verification Commands

### Automated Checks (Structural)

```bash
grep -r "@plan:PLAN-20250219-GMERGE021.R5.P05" . | wc -l
# Expected: 6+ occurrences

ls packages/cli/src/commands/hooks.tsx packages/cli/src/commands/hooks/migrate.ts
# Expected: both files exist

grep -n "hooksCommand" packages/cli/src/config/config.ts
# Expected: import and registration line

npm run test -- --testPathPattern=migrate
# Expected: all 6+ tests pass
```

### Deferred Implementation Detection (MANDATORY)

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB)" packages/cli/src/commands/hooks/ | grep -v ".test.ts"
# Expected: No matches

grep -rn -E "(in a real|placeholder|not yet|will be)" packages/cli/src/commands/hooks/ | grep -v ".test.ts"
# Expected: No matches
```

### Structural Verification Checklist

- [ ] P04 markers present in hookRegistry.ts
- [ ] `hooks.tsx` created with `hooksCommand` export
- [ ] `migrate.ts` created with full mapping tables
- [ ] `migrate.test.ts` created with 6+ tests
- [ ] CLI registration added to `config.ts` (gated on `enableHooks`)
- [ ] All 6+ tests pass

### Semantic Verification Checklist (MANDATORY)

1. **Does the code DO what the requirement says?**
   - [ ] All 8 event name mappings implemented
   - [ ] All 10 tool name mappings implemented
   - [ ] JSONC parsed via `strip-json-comments`
   - [ ] Missing file produces correct error message

2. **Is this REAL implementation, not placeholder?**
   - [ ] Mapping is a real lookup table, not hardcoded single value
   - [ ] `strip-json-comments` actually invoked before `JSON.parse`

3. **Would the test FAIL if implementation was removed?**
   - [ ] Yes — tests check specific mapped values

4. **Is the feature REACHABLE?**
   - [ ] `llxprt hooks migrate` reachable when `enableHooks` is true

#### Feature Actually Works

```bash
# Manual test (run after implementation):
node -e "const {mapClaudeEventName} = require('./packages/cli/src/commands/hooks/migrate.js'); console.log(mapClaudeEventName('PreToolUse'))"
# Expected: BeforeTool
```

## Success Criteria

- All 8 event name mappings implemented and tested
- All 10 tool name mappings implemented and tested
- JSONC parsing works
- Missing file error is descriptive
- `--merge` and `--overwrite` flags behave correctly

## Failure Recovery

If this phase fails:

1. `git checkout -- packages/cli/src/commands/hooks.tsx`
2. `git checkout -- packages/cli/src/commands/hooks/`
3. Revert registration in `packages/cli/src/config/config.ts`
4. Re-run Phase P05

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P05.md`

---

# Phase P06: UI Hooks Slash Commands (TDD)

## Phase ID

`PLAN-20250219-GMERGE021.R5.P06`

## Prerequisites

- Required: Phase P05 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.R5.P05" .`
- Expected files from P05: `hooks.tsx`, `migrate.ts`, CLI registration

## Requirements Implemented (Expanded)

### REQ-HOOKS-006: `/hooks` Slash Commands

**Full Text**: The UI MUST provide `/hooks panel`, `/hooks enable <cmd>`, and `/hooks disable <cmd>` slash commands for managing hooks within an active session.
**Behavior**:
- GIVEN: No hooks are configured
- WHEN: `/hooks panel` is invoked
- THEN: A message "No hooks configured" is shown
- GIVEN: A hook with command `"echo my-hook"` is registered
- WHEN: `/hooks enable echo my-hook` is invoked
- THEN: `setHookEnabled("echo my-hook", true)` is called AND `hooks.disabled` in user settings is updated
- GIVEN: An unknown command is passed
- WHEN: `/hooks enable nonexistent` is invoked
- THEN: An error message "No hook found" is shown
**Why This Matters**: Users need real-time toggle control without editing settings files manually.

### Persistence Contract

- Writes to **user-level** settings via `settings.setValue('hooks.disabled', updatedList)`
- Also calls `config.getHookSystem()?.setHookEnabled()` for immediate in-session effect
- If `settings.setValue()` fails, runtime toggle still applies but an error message is shown

## Implementation Tasks

### Files to Create

- `packages/cli/src/ui/commands/hooksCommand.ts`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.R5.P06`
  - MUST include: `@requirement:REQ-HOOKS-006`
  - `panelCommand`, `enableCommand`, `disableCommand` sub-commands
  - `hooksCommand` export as `SlashCommand`

- `packages/cli/src/ui/commands/hooksCommand.test.ts`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.R5.P06`
  - MUST include: `@requirement:REQ-HOOKS-006`

### Files to Modify

- `packages/cli/src/services/BuiltinCommandLoader.ts`
  - Register `hooksCommand` when `config.getEnableHooks()` is true
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.R5.P06`
  - Implements: `@requirement:REQ-HOOKS-006`

### Tests to Write First (Failing)

```typescript
// FAILING TEST: panel shows info when no hooks configured
it('/hooks panel shows info message when no hooks registered @plan:PLAN-20250219-GMERGE021.R5.P06 @requirement:REQ-HOOKS-006', async () => {
  const context = buildMockContext({ hookSystem: { getAllHooks: () => [] } });
  const output = await invokeHooksPanel(context);
  expect(output).toContain('No hooks configured');
});

// FAILING TEST: enable calls setHookEnabled and persists
it('/hooks enable calls setHookEnabled(true) and saves to settings @plan:PLAN-20250219-GMERGE021.R5.P06 @requirement:REQ-HOOKS-006', async () => {
  const setHookEnabled = vi.fn();
  const setValue = vi.fn();
  const context = buildMockContext({ hookSystem: { getAllHooks: () => [...], setHookEnabled }, settings: { setValue } });
  await invokeHooksEnable(context, 'echo my-hook');
  expect(setHookEnabled).toHaveBeenCalledWith('echo my-hook', true);
  expect(setValue).toHaveBeenCalledWith(
    expect.stringContaining('hooks.disabled'),
    expect.not.arrayContaining(['echo my-hook']),
  );
});

// FAILING TEST: disable calls setHookEnabled and persists
it('/hooks disable calls setHookEnabled(false) and saves to settings @plan:PLAN-20250219-GMERGE021.R5.P06 @requirement:REQ-HOOKS-006', async () => {
  const setHookEnabled = vi.fn();
  const setValue = vi.fn();
  const context = buildMockContext({ hookSystem: { getAllHooks: () => [...], setHookEnabled }, settings: { setValue } });
  await invokeHooksDisable(context, 'echo my-hook');
  expect(setHookEnabled).toHaveBeenCalledWith('echo my-hook', false);
  expect(setValue).toHaveBeenCalledWith(
    expect.stringContaining('hooks.disabled'),
    expect.arrayContaining(['echo my-hook']),
  );
});

// FAILING TEST: enable with unknown name produces error
it('/hooks enable shows error for unknown command @plan:PLAN-20250219-GMERGE021.R5.P06 @requirement:REQ-HOOKS-006', async () => {
  const context = buildMockContext({ hookSystem: { getAllHooks: () => [] } });
  const result = await invokeHooksEnable(context, 'nonexistent');
  expect(result).toContain('No hook found');
});

// FAILING TEST: command not registered when enableHooks is false
it('hooks slash command is not loaded when enableHooks is false @plan:PLAN-20250219-GMERGE021.R5.P06 @requirement:REQ-HOOKS-006', async () => {
  const loader = new BuiltinCommandLoader({ config: mockConfigWithEnableHooks(false) });
  const commands = await loader.loadCommands(new AbortController().signal);
  expect(commands.map((c) => c.name)).not.toContain('hooks');
});

// FAILING TEST: completion returns registered hook command strings
it('completion returns registered hook command strings @plan:PLAN-20250219-GMERGE021.R5.P06 @requirement:REQ-HOOKS-006', async () => {
  const hooks = [{ config: { command: 'echo a' } }, { config: { command: 'echo b' } }];
  const context = buildMockContext({ hookSystem: { getAllHooks: () => hooks } });
  const completions = await getHooksCompletions(context);
  expect(completions).toContain('echo a');
  expect(completions).toContain('echo b');
});
```

### `hooksCommand.ts` Structure

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.R5.P06
 * @requirement REQ-HOOKS-006
 */
export const hooksCommand: SlashCommand = {
  name: 'hooks',
  description: 'Manage hooks',
  kind: CommandKind.BUILT_IN,
  subCommands: [panelCommand, enableCommand, disableCommand],
  action: async (context) => panelCommand.action!(context, ''),
};
```

- **panelCommand**: Shows all hooks grouped by event name (command, status, source, matcher, sequential, timeout); empty state: "No hooks configured."
- **enableCommand**: Removes from `hooks.disabled` in user settings; calls `setHookEnabled(name, true)`
- **disableCommand**: Adds to `hooks.disabled` in user settings; calls `setHookEnabled(name, false)`
- **completions**: Returns currently registered hook command strings from `getAllHooks()`

## Verification Commands

### Automated Checks (Structural)

```bash
grep -r "@plan:PLAN-20250219-GMERGE021.R5.P06" . | wc -l
# Expected: 6+ occurrences

ls packages/cli/src/ui/commands/hooksCommand.ts packages/cli/src/ui/commands/hooksCommand.test.ts
# Expected: both files exist

grep -n "hooksCommand" packages/cli/src/services/BuiltinCommandLoader.ts
# Expected: import and conditional registration

npm run test -- --testPathPattern=hooksCommand
# Expected: all 6 tests pass
```

### Deferred Implementation Detection (MANDATORY)

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB|in a real|placeholder)" packages/cli/src/ui/commands/hooksCommand.ts | grep -v ".test.ts"
# Expected: No matches
```

### Structural Verification Checklist

- [ ] P05 markers present in commands/hooks.tsx
- [ ] `hooksCommand.ts` created with panel/enable/disable subcommands
- [ ] `hooksCommand.test.ts` created with 6+ tests
- [ ] `BuiltinCommandLoader.ts` updated with gated registration
- [ ] All 6 tests pass

### Semantic Verification Checklist (MANDATORY)

1. **Does the code DO what the requirement says?**
   - [ ] `enable` removes from disabled list AND calls runtime toggle
   - [ ] `disable` adds to disabled list AND calls runtime toggle
   - [ ] `panel` shows grouped hooks with status indicator
   - [ ] Unknown command gives error, not crash

2. **Is this REAL implementation, not placeholder?**
   - [ ] `settings.setValue()` actually invoked (not just mocked)
   - [ ] `setHookEnabled()` actually invoked (not just mocked)

3. **Would the test FAIL if implementation was removed?**
   - [ ] Yes — spy assertions on `setHookEnabled` and `setValue`

4. **Is the feature REACHABLE?**
   - [ ] `/hooks` available in CLI when `enableHooks` is true

## Success Criteria

- All three subcommands implemented and tested
- Both runtime and persistent effects verified
- Command not accessible when `enableHooks` is false

## Failure Recovery

If this phase fails:

1. `git checkout -- packages/cli/src/ui/commands/hooksCommand.ts`
2. `git checkout -- packages/cli/src/ui/commands/hooksCommand.test.ts`
3. Revert registration in `BuiltinCommandLoader.ts`
4. Re-run Phase P06

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P06.md`

---

# Phase P07: UI Components (TDD)

## Phase ID

`PLAN-20250219-GMERGE021.R5.P07`

## Prerequisites

- Required: Phase P06 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.R5.P06" .`
- Expected files from P06: `hooksCommand.ts`, `hooksCommand.test.ts`, `BuiltinCommandLoader.ts` updated

## Requirements Implemented (Expanded)

### REQ-HOOKS-007: `HooksList` UI Component

**Full Text**: The UI MUST render a `HooksList` component that displays all registered hooks grouped by event name, showing command, enabled/disabled status, source, matcher, sequential, and timeout. An empty state MUST show "No hooks configured."
**Behavior**:
- GIVEN: An array of hook objects with `enabled: true`
- WHEN: `<HooksList hooks={hooks} />` is rendered
- THEN: Each hook appears with a visual indicator for its status, grouped under its event name
- GIVEN: An empty hooks array
- WHEN: `<HooksList hooks={[]} />` is rendered
- THEN: "No hooks configured" message is shown
**Why This Matters**: The `/hooks panel` command output requires a structured display that distinguishes enabled from disabled hooks.

## Implementation Tasks

### Files to Modify

- `packages/cli/src/ui/types.ts`
  - Add `HOOKS_LIST = 'hooks_list'` to `MessageType` enum
  - Add `HistoryItemHooksList` type with hooks array
  - Add `HistoryItemHooksList` to `HistoryItemWithoutId` union
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.R5.P07`
  - Implements: `@requirement:REQ-HOOKS-007`

- `packages/cli/src/ui/components/HistoryItemDisplay.tsx`
  - Add render case for `hooks_list` type
  - Import `HooksList` component
  - ADD comment: `@plan:PLAN-20250219-GMERGE021.R5.P07`
  - Implements: `@requirement:REQ-HOOKS-007`

### Files to Create

- `packages/cli/src/ui/components/views/HooksList.tsx`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.R5.P07`
  - MUST include: `@requirement:REQ-HOOKS-007`
  - Groups hooks by event name
  - Shows command, status, source, matcher, sequential, timeout
  - Shows tip: "Use /hooks enable \<command\> or /hooks disable \<command\> to toggle"
  - Empty state: "No hooks configured. Add hooks to your settings to get started."

### Tests to Write First (Failing)

In `packages/cli/src/ui/components/views/HooksList.test.tsx`:

```typescript
// FAILING TEST: renders enabled hooks correctly
it('renders enabled hooks with enabled status @plan:PLAN-20250219-GMERGE021.R5.P07 @requirement:REQ-HOOKS-007', () => {
  const hooks = [{ config: { command: 'echo a', type: 'command' }, source: 'project', eventName: 'BeforeTool', enabled: true }];
  const { getByText } = render(<HooksList hooks={hooks} />);
  expect(getByText('echo a')).toBeDefined();
});

// FAILING TEST: renders disabled hooks with distinct indicator
it('renders disabled hooks with distinct visual indicator @plan:PLAN-20250219-GMERGE021.R5.P07 @requirement:REQ-HOOKS-007', () => {
  const hooks = [{ config: { command: 'echo b', type: 'command' }, source: 'project', eventName: 'BeforeTool', enabled: false }];
  const { getByText } = render(<HooksList hooks={hooks} />);
  expect(getByText(/disabled/i)).toBeDefined();
});

// FAILING TEST: groups hooks by event name
it('groups hooks by event name @plan:PLAN-20250219-GMERGE021.R5.P07 @requirement:REQ-HOOKS-007', () => {
  const hooks = [
    { config: { command: 'echo a', type: 'command' }, source: 'project', eventName: 'BeforeTool', enabled: true },
    { config: { command: 'echo b', type: 'command' }, source: 'project', eventName: 'AfterTool', enabled: true },
  ];
  const { getByText } = render(<HooksList hooks={hooks} />);
  expect(getByText('BeforeTool')).toBeDefined();
  expect(getByText('AfterTool')).toBeDefined();
});

// FAILING TEST: shows empty state message
it('shows empty state message when hooks array is empty @plan:PLAN-20250219-GMERGE021.R5.P07 @requirement:REQ-HOOKS-007', () => {
  const { getByText } = render(<HooksList hooks={[]} />);
  expect(getByText(/No hooks configured/)).toBeDefined();
});

// FAILING TEST: union type addition does not break exhaustiveness
it('adding HistoryItemHooksList to union does not break exhaustiveness checks @plan:PLAN-20250219-GMERGE021.R5.P07 @requirement:REQ-HOOKS-007', () => {
  // TypeScript compilation passing is the primary check; runtime: render dispatch works
  const item: HistoryItemHooksList = { type: 'hooks_list', hooks: [], id: 'test-1' };
  expect(item.type).toBe('hooks_list');
});
```

### `HistoryItemHooksList` Type

```typescript
export type HistoryItemHooksList = HistoryItemBase & {
  type: 'hooks_list';
  hooks: Array<{
    config: { command?: string; type: string; timeout?: number };
    source: string;
    eventName: string;
    matcher?: string;
    sequential?: boolean;
    enabled: boolean;
  }>;
};
```

**IMPORTANT after adding to union:** Run TypeScript type check immediately:

```bash
npm run typecheck
# Fix any exhaustiveness errors in components that switch on HistoryItemWithoutId
```

## Verification Commands

### Automated Checks (Structural)

```bash
grep -r "@plan:PLAN-20250219-GMERGE021.R5.P07" . | wc -l
# Expected: 5+ occurrences

grep -n "HOOKS_LIST\|hooks_list\|HistoryItemHooksList" packages/cli/src/ui/types.ts
# Expected: enum value, type alias, and union member

grep -n "HooksList" packages/cli/src/ui/components/HistoryItemDisplay.tsx
# Expected: import and render call

ls packages/cli/src/ui/components/views/HooksList.tsx
# Expected: file exists

npm run typecheck
# Expected: no errors

npm run test -- --testPathPattern=HooksList
# Expected: all 5 tests pass
```

### Deferred Implementation Detection (MANDATORY)

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB)" packages/cli/src/ui/components/views/HooksList.tsx | grep -v ".test.tsx"
# Expected: No matches

grep -rn -E "return \[\]|return \{\}|return null" packages/cli/src/ui/components/views/HooksList.tsx | grep -v ".test.tsx"
# Expected: No matches (component must render actual content)
```

### Structural Verification Checklist

- [ ] P06 markers present in hooksCommand.ts
- [ ] `MessageType.HOOKS_LIST` added to enum
- [ ] `HistoryItemHooksList` type defined
- [ ] `HistoryItemHooksList` added to `HistoryItemWithoutId` union
- [ ] `HooksList.tsx` created with grouping, status, empty state
- [ ] `HistoryItemDisplay.tsx` renders `hooks_list` type
- [ ] TypeScript compiles without error
- [ ] All 5 tests pass

### Semantic Verification Checklist (MANDATORY)

1. **Does the code DO what the requirement says?**
   - [ ] Hooks are grouped by event name (not flat list)
   - [ ] Enabled/disabled shown with distinct visual indicator
   - [ ] Empty state shows "No hooks configured" text

2. **Is this REAL implementation, not placeholder?**
   - [ ] Component renders actual hook data (not hardcoded)
   - [ ] Grouping logic actually groups (e.g., uses `reduce` or `Map`)

3. **Would the test FAIL if implementation was removed?**
   - [ ] Yes — tests check rendered text content

4. **Is the feature REACHABLE?**
   - [ ] `HistoryItemDisplay.tsx` dispatches to `HooksList` for `hooks_list` type
   - [ ] `panelCommand` in P06 creates a `hooks_list` history item

#### Feature Actually Works

```bash
# After implementation, run haiku test to ensure no regressions:
node scripts/start.js --profile-load synthetic "write me a haiku"
# Expected: Haiku output, no crash
```

## Success Criteria

- `HooksList` renders hooks grouped by event name
- Disabled hooks have distinct visual indicator
- Empty state message shown for empty array
- TypeScript compiles without exhaustiveness errors

## Failure Recovery

If this phase fails:

1. `git checkout -- packages/cli/src/ui/types.ts`
2. `git checkout -- packages/cli/src/ui/components/HistoryItemDisplay.tsx`
3. `git checkout -- packages/cli/src/ui/components/views/HooksList.tsx`
4. Re-run Phase P07

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P07.md`

---

# Phase P08: Final Integration Verification

## Phase ID

`PLAN-20250219-GMERGE021.R5.P08`

## Prerequisites

- Required: All phases P01–P07 completed
- Verification: All `.completed/P0*.md` files exist

## Implementation Tasks

No new code. This phase verifies the full feature works end-to-end and runs the full verification suite.

## Full Test Matrix Verification

| # | Test | Phase | Pass? |
|---|------|-------|-------|
| 1 | `hooks.disabled` in settings schema has correct type | P01 | ⬜ |
| 2 | `mergeSettings` unions `hooks.disabled` from all layers | P02 | ⬜ |
| 3 | `mergeSettings` concatenates hook event arrays from all layers | P02 | ⬜ |
| 4 | Schema validation rejects non-string entries in `hooks.disabled` | P01 | ⬜ |
| 5 | `getDisabledHooks()` returns empty array when no `disabled` configured | P03 | ⬜ |
| 6 | `getDisabledHooks()` returns list from hooks config | P03 | ⬜ |
| 7 | `getHooks()` does not include `disabled` key in returned object | P03 | ⬜ |
| 8 | HookRegistry: hooks in disabled list start with `enabled: false` | P04 | ⬜ |
| 9 | HookRegistry: hooks not in disabled list start with `enabled: true` | P04 | ⬜ |
| 10 | HookRegistry: does not crash when disabled list is non-empty | P04 | ⬜ |
| 11 | Multiple hooks sharing same command all disabled | P04 | ⬜ |
| 12 | Claude `PreToolUse` maps to LLxprt `BeforeTool` | P05 | ⬜ |
| 13 | Unknown Claude event names pass through with warning | P05 | ⬜ |
| 14 | Claude tool names map correctly in matchers | P05 | ⬜ |
| 15 | Unknown Claude tool names pass through with warning | P05 | ⬜ |
| 16 | JSONC source file with comments is parsed correctly | P05 | ⬜ |
| 17 | Missing Claude settings file produces clear error | P05 | ⬜ |
| 18 | Migrate with `--merge` flag concatenates | P05 | ⬜ |
| 19 | Migrate without `--merge` flag: warns if target has existing hooks | P05 | ⬜ |
| 20 | `/hooks panel` shows info when no hooks configured | P06 | ⬜ |
| 21 | `/hooks enable <cmd>` calls `setHookEnabled(true)` and writes to user settings | P06 | ⬜ |
| 22 | `/hooks disable <cmd>` calls `setHookEnabled(false)` and writes to user settings | P06 | ⬜ |
| 23 | `/hooks enable <unknown>` shows error, does not crash | P06 | ⬜ |
| 24 | `/hooks` not registered when `getEnableHooks()` is false | P06 | ⬜ |
| 25 | Completion returns registered hook command strings only | P06 | ⬜ |
| 26 | Adding `HistoryItemHooksList` to union does not break exhaustiveness | P07 | ⬜ |
| 27 | `HooksList` renders enabled hooks correctly | P07 | ⬜ |
| 28 | `HooksList` renders disabled hooks with distinct visual indicator | P07 | ⬜ |
| 29 | `HooksList` groups hooks by event name | P07 | ⬜ |
| 30 | `HooksList` shows empty-state message when hooks array is empty | P07 | ⬜ |

## Verification Commands

### Full Suite

```bash
npm run test
npm run typecheck
npm run lint
npm run format
npm run build
node scripts/start.js --profile-load synthetic "write me a haiku"
```

### Plan Marker Audit

```bash
# Verify all phases have markers
for phase in P01 P02 P03 P04 P05 P06 P07; do
  echo -n "$phase: "
  grep -r "@plan:PLAN-20250219-GMERGE021.R5.$phase" . | wc -l
done
# Expected: non-zero for each phase
```

### Manual Verification

```bash
# Test CLI command (with hooks enabled)
llxprt hooks migrate --from-claude
llxprt hooks migrate --from-claude --merge

# Test slash commands (in active session with hooks enabled)
/hooks panel
/hooks enable <hook-command>
/hooks disable <hook-command>
```

### File Summary Verification

**New Files Created:**

| File | Status |
|------|--------|
| `packages/cli/src/commands/hooks.tsx` | ⬜ |
| `packages/cli/src/commands/hooks/migrate.ts` | ⬜ |
| `packages/cli/src/commands/hooks/migrate.test.ts` | ⬜ |
| `packages/cli/src/ui/commands/hooksCommand.ts` | ⬜ |
| `packages/cli/src/ui/commands/hooksCommand.test.ts` | ⬜ |
| `packages/cli/src/ui/components/views/HooksList.tsx` | ⬜ |

**Files Modified:**

| File | Status |
|------|--------|
| `packages/cli/src/config/settingsSchema.ts` | ⬜ |
| `packages/cli/src/config/settings.ts` | ⬜ |
| `packages/core/src/config/config.ts` | ⬜ |
| `packages/core/src/hooks/hookRegistry.ts` | ⬜ |
| `packages/cli/src/config/config.ts` | ⬜ |
| `packages/cli/src/services/BuiltinCommandLoader.ts` | ⬜ |
| `packages/cli/src/ui/types.ts` | ⬜ |
| `packages/cli/src/ui/components/HistoryItemDisplay.tsx` | ⬜ |
| `packages/core/src/hooks/hookRegistry.test.ts` | ⬜ |

### Semantic Verification Checklist (MANDATORY)

1. **All 30 tests pass**
   - [ ] `npm run test` exits with code 0

2. **TypeScript compiles**
   - [ ] `npm run typecheck` exits with code 0
   - [ ] No exhaustiveness errors from union type change

3. **No deferred implementations remain**
   - [ ] `grep -rn "TODO\|FIXME\|HACK\|STUB" packages/cli/src/commands/hooks/ packages/cli/src/ui/commands/hooksCommand.ts packages/cli/src/ui/components/views/HooksList.tsx packages/core/src/hooks/hookRegistry.ts packages/core/src/config/config.ts` → no matches in non-test files

4. **Haiku test passes**
   - [ ] `node scripts/start.js --profile-load synthetic "write me a haiku"` produces output

5. **Priority order satisfied**
   - [ ] P0-Critical (P02+P03+P04): disabled hooks work at runtime
   - [ ] P1-High (P06+P07): user-facing panel and toggle
   - [ ] P2-Medium (P05): migrate command
   - [ ] P3-Low (P01): schema annotation

## Success Criteria

- All 30 tests pass
- TypeScript compiles without error
- Full verification suite green
- Haiku test passes
- All plan markers present for all 7 phases

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P08.md`
Contents:

```markdown
Phase: P08
Completed: YYYY-MM-DD HH:MM
Tests: 30/30 passing
Build: green
Haiku: passing
Notes: Feature complete
```

---

## Notes

- The hooks CLI command is only available when `tools.enableHooks` is true
- The slash command is only available when hooks are enabled
- Disabled hooks are stored in **user-level settings** and applied at hook registration time
- `setHookEnabled()` in HookSystem allows runtime toggling for the current session without persisting
- The slash command does **both**: runtime toggle via `setHookEnabled()` AND persistence via `settings.setValue()`
- `strip-json-comments` is already available in the CLI package — no new dependency needed
- `$CLAUDE_PROJECT_DIR` is already handled by `hookRunner.ts` — renaming in migrate is cosmetic only
- After adding `HistoryItemHooksList` to the union type, run `npm run typecheck` immediately to catch exhaustiveness errors
