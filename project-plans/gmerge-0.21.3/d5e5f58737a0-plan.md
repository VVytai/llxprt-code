# Plan: Update Setting Search UX (Commit d5e5f58737a0)

Plan ID: `PLAN-20250219-GMERGE021.R11`
Generated: 2025-02-19
Total Phases: 6
Requirements: Upstream commit d5e5f58737a0 "Update setting search UX (#14451)"

## Critical Reminders

Before implementing ANY phase, ensure you have:

1. Completed preflight verification (Phase P01)
2. Written failing tests BEFORE implementation (Phase P02)
3. Verified all dependencies and types exist as assumed
4. Confirmed no `isSearching` state is introduced — the UX is persistent (always-visible) search only
5. Confirmed no "/" handler to remove — LLxprt's SettingsDialog never had one

---

## Overview

### Summary of Upstream Changes

The upstream commit modifies the Settings dialog to improve the search/filter UX by:

1. **Replacing the "/" hotkey-triggered search mode** with a persistent search input field always visible in the UI
2. **Adding a `shared/TextInput` component** (backed by `useTextBuffer`) for real-time filtering as users type
3. **Removing the modal-style search UI** in favor of inline filtering
4. **Simplifying escape behavior**: Pressing Escape while searching now closes the dialog entirely (instead of just exiting search mode)
5. **Updating test expectations** to match the new UX

### Visual Changes

**Before:**
```
Settings
▲
// settings list...
▼

Apply To
● User Settings

(Use Enter to select, Tab to change focus, Esc to close)
```

**After:**
```
Settings
╭──────────────────────────────────────────────────────────────────────╮
│ Search to filter                                                    │
╰──────────────────────────────────────────────────────────────────────╯
▲
// filtered settings list...
▼

Apply To
● User Settings

(Use Enter to select, Tab to change focus, Esc to close)
```

### Current State Analysis

**Files Involved:**

| File | Status |
|------|--------|
| `/packages/cli/src/ui/components/SettingsDialog.tsx` | Exists (~1272 lines); no search functionality |
| `/packages/cli/src/ui/components/shared/TextInput.tsx` | **Does not exist** — must create (buffer-based API) |
| `/packages/cli/src/ui/components/ProfileCreateWizard/TextInput.tsx` | Exists; different API (value/onChange) — do NOT modify |
| `/packages/cli/src/ui/components/shared/text-buffer.ts` | Exists; exports `useTextBuffer` and `TextBuffer` |
| `/packages/cli/src/ui/semantic-colors.ts` | Exists; exports `theme` with `theme.border.default`, `theme.border.focused` |
| `/packages/cli/src/ui/contexts/UIStateContext.tsx` | Exists; exports `useUIState()` with `mainAreaWidth` |

**Key confirmed codebase facts:**

| Item | Status |
|------|--------|
| `useTextBuffer` hook | OK — exists; no `singleLine` option |
| `TextBuffer` type export | OK — exported from `text-buffer.ts` |
| `onChange` prop on `useTextBuffer` | OK — supported |
| `shared/TextInput.tsx` | MISSING — needs creation |
| `semantic-colors.ts` with `theme` | OK — use directly; no Colors adaptation needed |
| `useUIState()` with `mainAreaWidth` | OK — available from UIStateContext |
| "/" hotkey in SettingsDialog | NOT PRESENT — no removal step needed |
| Modal `isSearching` state | NOT PRESENT — do NOT introduce |

---

# Phase P01: Preflight Verification

## Phase ID

`PLAN-20250219-GMERGE021.R11.P01`

## Prerequisites

- None (this is the first phase)

## Purpose

Verify ALL assumptions before writing any code.

## Implementation Tasks

### Dependency Verification

Confirm each file exists and exports the expected symbols:

```bash
# Verify text-buffer exports
grep -n "export" packages/cli/src/ui/components/shared/text-buffer.ts | grep -E "useTextBuffer|TextBuffer"

# Verify semantic-colors exports
grep -n "export" packages/cli/src/ui/semantic-colors.ts | grep "theme"

# Verify UIStateContext exports
grep -n "export" packages/cli/src/ui/contexts/UIStateContext.tsx | grep -E "useUIState|UIStateProvider"

# Verify ProfileCreateWizard TextInput (must NOT be touched)
ls packages/cli/src/ui/components/ProfileCreateWizard/TextInput.tsx

# Confirm shared/TextInput does NOT yet exist
ls packages/cli/src/ui/components/shared/TextInput.tsx 2>&1 || echo "CONFIRMED MISSING"
```

### Type/Interface Verification

| Type Name | Expected Definition | Actual Definition | Match? |
|-----------|---------------------|-------------------|--------|
| `TextBuffer` | Exported type from `text-buffer.ts` | [verify with grep] | TBD |
| `useTextBuffer` | Hook accepting `{initialText, initialCursorOffset, viewport, isValidPath, onChange}` | [verify with grep] | TBD |
| `theme.border.default` | String color from `semantic-colors.ts` | [verify with grep] | TBD |
| `theme.border.focused` | String color from `semantic-colors.ts` | [verify with grep] | TBD |
| `mainAreaWidth` | Number from `useUIState()` | [verify with grep] | TBD |

### Call Path Verification

```bash
# Verify useKeypress usage pattern in SettingsDialog (to understand current handler shape)
grep -n "useKeypress\|handleKeyPress" packages/cli/src/ui/components/SettingsDialog.tsx | head -20

# Verify current digit handler (the potential conflict)
grep -n "0-9\|digit\|number" packages/cli/src/ui/components/SettingsDialog.tsx

# Verify editingKey state shape
grep -n "editingKey\|setEditingKey" packages/cli/src/ui/components/SettingsDialog.tsx | head -20

# Confirm no "/" search handler exists
grep -n "isSearching\|searchMode\|key.*\/" packages/cli/src/ui/components/SettingsDialog.tsx || echo "CONFIRMED: No search mode"
```

### Test Infrastructure Verification

| Component | Test File Exists? | Provider wrappers currently used? |
|-----------|-------------------|-----------------------------------|
| `SettingsDialog.test.tsx` | [verify] | [list providers in render helpers] |
| `UIStateProvider` available in tests | [verify] | [check if imported anywhere in tests] |

```bash
# Find current test render pattern
grep -n "render\|UIState\|KeypressProvider\|VimMode" packages/cli/src/ui/components/SettingsDialog.test.tsx | head -30
```

## Verification Commands

```bash
# Run complete preflight verification
grep -n "export" packages/cli/src/ui/components/shared/text-buffer.ts | grep -E "useTextBuffer|TextBuffer"
grep -n "export" packages/cli/src/ui/semantic-colors.ts | grep "theme"
grep -n "export" packages/cli/src/ui/contexts/UIStateContext.tsx | grep -E "useUIState|UIStateProvider"
ls packages/cli/src/ui/components/shared/TextInput.tsx 2>&1 || echo "CONFIRMED MISSING"
grep -n "isSearching" packages/cli/src/ui/components/SettingsDialog.tsx || echo "CONFIRMED: No isSearching state"
```

## Semantic Verification Checklist

- [ ] `useTextBuffer` confirmed to exist with expected parameters
- [ ] `TextBuffer` type confirmed exportable
- [ ] `theme.border.default` and `theme.border.focused` confirmed present
- [ ] `useUIState()` confirmed to return `mainAreaWidth`
- [ ] `shared/TextInput.tsx` confirmed absent (needs creation)
- [ ] No `isSearching` state in SettingsDialog confirmed
- [ ] No "/" handler in SettingsDialog confirmed
- [ ] Digit handler in SettingsDialog identified (potential conflict with search — see Risk Assessment)
- [ ] Current test provider chain documented

## Success Criteria

- All dependency verifications return positive results
- All types match plan expectations
- Test infrastructure requirements understood
- Blocking issues (if any) resolved before proceeding

## Failure Recovery

If any assumption fails:
1. Update plan sections to reflect actual codebase state
2. Re-run preflight verification
3. Do not proceed to P02 until all checkboxes are checked

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P01.md`

---

# Phase P02: TDD — Write Failing Tests First

## Phase ID

`PLAN-20250219-GMERGE021.R11.P02`

## Prerequisites

- Required: Phase P01 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.R11.P01" .`
- Preflight verification: Phase P01 MUST be completed before writing tests

## Requirements Implemented (Expanded)

### REQ-SEARCH-001: Persistent Search Input Renders

**Full Text**: The Settings dialog MUST display a persistent "Search to filter" input field visible at all times (not behind a hotkey).
**Behavior**:
- GIVEN: The Settings dialog is open
- WHEN: The dialog renders its initial state
- THEN: A text input with placeholder "Search to filter" is visible without any keypress
**Why This Matters**: Users can discover and use filtering immediately without hunting for a hotkey.

### REQ-SEARCH-002: Real-Time Filter on Typing

**Full Text**: Typing in the search field MUST reduce the displayed settings list to only items whose labels match the query (case-insensitive substring).
**Behavior**:
- GIVEN: The Settings dialog is open with multiple settings visible
- WHEN: The user types a query into the search field
- THEN: Only settings whose labels contain the query (case-insensitive) remain visible
**Why This Matters**: Users can quickly locate specific settings without scrolling.

### REQ-SEARCH-003: Empty Query Shows All Settings

**Full Text**: When the search query is empty, ALL settings MUST be shown.
**Behavior**:
- GIVEN: A search query was typed and then cleared
- WHEN: The search field is empty
- THEN: All settings are visible (unfiltered)
**Why This Matters**: Clearing the search restores full browsing capability.

### REQ-SEARCH-004: No-Results State

**Full Text**: When no settings match the search query, the dialog MUST display a "No matching settings" message.
**Behavior**:
- GIVEN: The user has typed a query that matches no setting labels
- WHEN: The filtered list is empty
- THEN: A "No matching settings" message appears instead of settings
**Why This Matters**: Users understand their query matched nothing rather than thinking the settings list is broken.

### REQ-SEARCH-005: Escape Closes Dialog (Not Just Clears Search)

**Full Text**: Pressing Escape with an active search query MUST close the Settings dialog entirely.
**Behavior**:
- GIVEN: The Settings dialog is open with a non-empty search query
- WHEN: The user presses Escape
- THEN: The dialog closes (not just the search query is cleared)
**Why This Matters**: Simplifies the escape behavior — no modal search state to exit from first.

## Implementation Tasks

### Files to Modify

- `packages/cli/src/ui/components/SettingsDialog.test.tsx`
  - ADD: `@plan:PLAN-20250219-GMERGE021.R11.P02`
  - ADD: Test suite "search box UX" containing all tests below

### Required Tests to Write

Write these tests as FAILING before any implementation:

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.R11.P02
 * @requirement REQ-SEARCH-001
 */
it('renders search input with "Search to filter" placeholder @plan:PLAN-20250219-GMERGE021.R11.P02 @requirement:REQ-SEARCH-001', async () => {
  const { lastFrame } = render(<SettingsDialog ... />);
  expect(lastFrame()).toContain('Search to filter');
});

/**
 * @plan PLAN-20250219-GMERGE021.R11.P02
 * @requirement REQ-SEARCH-002
 */
it('filters settings list as user types @plan:PLAN-20250219-GMERGE021.R11.P02 @requirement:REQ-SEARCH-002', async () => {
  // type a distinctive query, verify only matching items appear
});

/**
 * @plan PLAN-20250219-GMERGE021.R11.P02
 * @requirement REQ-SEARCH-003
 */
it('shows all settings when search query is empty @plan:PLAN-20250219-GMERGE021.R11.P02 @requirement:REQ-SEARCH-003', async () => {
  // type a query then clear it, verify all settings visible
});

/**
 * @plan PLAN-20250219-GMERGE021.R11.P02
 * @requirement REQ-SEARCH-004
 */
it('shows "No matching settings" when query matches nothing @plan:PLAN-20250219-GMERGE021.R11.P02 @requirement:REQ-SEARCH-004', async () => {
  // type an unmatched query, verify no-results message
});

/**
 * @plan PLAN-20250219-GMERGE021.R11.P02
 * @requirement REQ-SEARCH-005
 */
it('Escape closes dialog even with active search query @plan:PLAN-20250219-GMERGE021.R11.P02 @requirement:REQ-SEARCH-005', async () => {
  // type a query, press Escape, verify onClose called
});
```

### Required Code Markers

Every test MUST include `@plan:PLAN-20250219-GMERGE021.R11.P02` and the relevant `@requirement:REQ-SEARCH-XXX` in the test name or JSDoc.

## Verification Commands

```bash
# Run the new tests — ALL must FAIL before proceeding to P03
npm test packages/cli/src/ui/components/SettingsDialog.test.tsx

# Confirm plan markers added
grep -n "@plan:PLAN-20250219-GMERGE021.R11.P02" packages/cli/src/ui/components/SettingsDialog.test.tsx | wc -l
# Expected: 5+ occurrences

# Confirm requirement markers added
grep -n "@requirement:REQ-SEARCH-" packages/cli/src/ui/components/SettingsDialog.test.tsx | wc -l
# Expected: 5 occurrences
```

### Deferred Implementation Detection

```bash
# Should be no implementation code yet — only test code
grep -rn "shared/TextInput\|searchQuery\|filteredItems" packages/cli/src/ui/components/SettingsDialog.tsx
# Expected: No matches
```

## Semantic Verification Checklist

1. **Tests actually test behavior, not structure:**
   - [ ] Tests verify text content rendered, not just that component mounted
   - [ ] Tests simulate actual user input (keypresses)
   - [ ] Tests would fail if search feature was not implemented

2. **All 5 requirement scenarios have test coverage:**
   - [ ] REQ-SEARCH-001: placeholder renders
   - [ ] REQ-SEARCH-002: typing filters
   - [ ] REQ-SEARCH-003: clearing restores all
   - [ ] REQ-SEARCH-004: no-results message
   - [ ] REQ-SEARCH-005: Escape closes dialog

3. **Tests fail for the right reason:**
   - [ ] Failure is "cannot find element" or "expected X got Y" — not syntax error or import error

## Success Criteria

- 5+ new tests added
- All new tests tagged with P02 plan marker
- All new tests FAIL (not error) when run — confirms they test real behavior
- No implementation code added yet

## Failure Recovery

If tests error (not fail):
1. `git checkout -- packages/cli/src/ui/components/SettingsDialog.test.tsx`
2. Diagnose import/syntax issues
3. Re-write tests, re-run

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P02.md`

---

# Phase P03: Create `shared/TextInput.tsx`

## Phase ID

`PLAN-20250219-GMERGE021.R11.P03`

## Prerequisites

- Required: Phase P02 completed
- Verification: `grep -r "@plan:PLAN-20250219-GMERGE021.R11.P02" packages/cli/src/ui/components/SettingsDialog.test.tsx`
- Expected files: P02 test additions in `SettingsDialog.test.tsx`
- Preflight verification: Phase P01 MUST be completed

## Requirements Implemented (Expanded)

### REQ-TEXTINPUT-001: Buffer-Based TextInput Component

**Full Text**: A new `shared/TextInput` component MUST be created with a `buffer: TextBuffer` prop pattern matching upstream API.
**Behavior**:
- GIVEN: A `TextBuffer` instance from `useTextBuffer`
- WHEN: `<TextInput buffer={buffer} placeholder="Search to filter" focus={true} />` is rendered
- THEN: The component renders a single-line text input showing the buffer's current text with cursor, or the placeholder when empty
**Why This Matters**: Separates the buffer-based API from the existing `ProfileCreateWizard/TextInput` which uses value/onChange pattern.

## Implementation Tasks

### Files to Create

- `packages/cli/src/ui/components/shared/TextInput.tsx`
  - MUST include: `@plan:PLAN-20250219-GMERGE021.R11.P03`
  - MUST include: `@requirement:REQ-TEXTINPUT-001`

### Implementation

```typescript
/**
 * @license
 * Copyright 2025 Vybestack LLC
 * SPDX-License-Identifier: Apache-2.0
 *
 * @plan PLAN-20250219-GMERGE021.R11.P03
 * @requirement REQ-TEXTINPUT-001
 */

import type React from 'react';
import { useCallback } from 'react';
import type { Key } from '../../hooks/useKeypress.js';
import { Text, Box } from 'ink';
import { useKeypress } from '../../hooks/useKeypress.js';
import chalk from 'chalk';
import { theme } from '../../semantic-colors.js';
import type { TextBuffer } from './text-buffer.js';
import { cpSlice } from '../../utils/textUtils.js';

export interface TextInputProps {
  buffer: TextBuffer;
  placeholder?: string;
  onSubmit?: (value: string) => void;
  onCancel?: () => void;
  focus?: boolean;
}

export function TextInput({
  buffer,
  placeholder = '',
  onSubmit,
  onCancel,
  focus = true,
}: TextInputProps): React.JSX.Element {
  const {
    text,
    handleInput,
    visualCursor,
    viewportVisualLines,
    visualScrollRow,
  } = buffer;
  const [cursorVisualRowAbsolute, cursorVisualColAbsolute] = visualCursor;

  const handleKeyPress = useCallback(
    (key: Key) => {
      if (key.name === 'escape') {
        onCancel?.();
        return;
      }
      if (key.name === 'return') {
        onSubmit?.(text);
        return;
      }
      handleInput(key);
    },
    [handleInput, onCancel, onSubmit, text],
  );

  useKeypress(handleKeyPress, { isActive: focus });

  const showPlaceholder = text.length === 0 && placeholder;

  if (showPlaceholder) {
    return (
      <Box>
        {focus ? (
          <Text>
            {chalk.inverse(placeholder[0] || ' ')}
            <Text color={theme.text.secondary}>{placeholder.slice(1)}</Text>
          </Text>
        ) : (
          <Text color={theme.text.secondary}>{placeholder}</Text>
        )}
      </Box>
    );
  }

  return (
    <Box flexDirection="column">
      {viewportVisualLines.map((lineText, idx) => {
        const currentVisualRow = visualScrollRow + idx;
        const isCursorLine =
          focus && currentVisualRow === cursorVisualRowAbsolute;

        const lineDisplay = isCursorLine
          ? cpSlice(lineText, 0, cursorVisualColAbsolute) +
            chalk.inverse(
              cpSlice(
                lineText,
                cursorVisualColAbsolute,
                cursorVisualColAbsolute + 1,
              ) || ' ',
            ) +
            cpSlice(lineText, cursorVisualColAbsolute + 1)
          : lineText;

        return (
          <Box key={idx} height={1}>
            <Text>{lineDisplay}</Text>
          </Box>
        );
      })}
    </Box>
  );
}
```

**Implementation Notes:**
- Uses `viewport.height: 1` (set by SettingsDialog caller) to enforce single-line display — `useTextBuffer` has no `singleLine` option
- Uses `theme` from `semantic-colors.ts` directly — no `Colors` adaptation needed
- `useKeypress` `isActive: focus` prevents key capture when not focused
- `cpSlice` from `textUtils.js` handles multi-byte unicode in cursor display correctly

### Files NOT to Modify

- `packages/cli/src/ui/components/ProfileCreateWizard/TextInput.tsx` — different API, different use case; leave untouched

## Verification Commands

```bash
# Confirm file created
ls -la packages/cli/src/ui/components/shared/TextInput.tsx

# Confirm plan marker present
grep "@plan:PLAN-20250219-GMERGE021.R11.P03" packages/cli/src/ui/components/shared/TextInput.tsx

# Typecheck the new file in isolation
npx tsc --noEmit packages/cli/src/ui/components/shared/TextInput.tsx 2>&1 | head -30

# Full typecheck
npm run typecheck 2>&1 | grep -i "TextInput\|error" | head -20
```

### Deferred Implementation Detection

```bash
grep -n -E "(TODO|FIXME|HACK|STUB|not yet|placeholder|will be)" packages/cli/src/ui/components/shared/TextInput.tsx | grep -v ".test.ts"
# Expected: No matches
```

## Semantic Verification Checklist

1. **Does the component render correctly?**
   - [ ] Placeholder renders when `text === ''`
   - [ ] Cursor highlights correct character when focused
   - [ ] `isActive: focus` correctly disables key handling when not focused

2. **Is this REAL implementation, not placeholder?**
   - [ ] Deferred implementation detection passed
   - [ ] No empty returns
   - [ ] Actual rendering logic present

3. **Integration path exists:**
   - [ ] Exports `TextInput` and `TextInputProps` (named exports)
   - [ ] Imports resolve correctly (`.js` extensions used)

## Success Criteria

- `shared/TextInput.tsx` created with buffer-based API
- File typechecks without errors
- Plan marker `@plan:PLAN-20250219-GMERGE021.R11.P03` present in file
- `ProfileCreateWizard/TextInput.tsx` unchanged

## Failure Recovery

If typecheck fails:
1. `git checkout -- packages/cli/src/ui/components/shared/TextInput.tsx`
2. Diagnose import path issues (`.js` extensions, utility paths)
3. Re-implement and re-verify

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P03.md`

---

# Phase P04: Modify `SettingsDialog.tsx`

## Phase ID

`PLAN-20250219-GMERGE021.R11.P04`

## Prerequisites

- Required: Phase P03 completed
- Verification: `ls packages/cli/src/ui/components/shared/TextInput.tsx`
- Expected files: `shared/TextInput.tsx` created in P03
- Preflight verification: Phase P01 MUST be completed

## Requirements Implemented (Expanded)

### REQ-DIALOG-001: Add Search State and Buffer

**Full Text**: SettingsDialog MUST add `searchQuery` state and a `useTextBuffer` instance with `viewport.height: 1` to enforce single-line behavior.
**Behavior**:
- GIVEN: SettingsDialog mounts
- WHEN: Component initializes
- THEN: `searchQuery` starts as `''`; buffer is ready to accept input
**Why This Matters**: Foundation for all search/filter behavior.

### REQ-DIALOG-002: Filter Settings Items

**Full Text**: Settings list MUST be filtered by `searchQuery` (case-insensitive substring match on label) before display and navigation.
**Behavior**:
- GIVEN: `searchQuery` is "theme"
- WHEN: `filteredItems` is computed
- THEN: Only items whose `.label` contains "theme" (case-insensitive) are in `filteredItems`
**Why This Matters**: Connects user input to visible settings.

### REQ-DIALOG-003: Reset Navigation on Filter Change

**Full Text**: When `searchQuery` changes, `activeSettingIndex` and `scrollOffset` MUST reset to 0.
**Behavior**:
- GIVEN: User is at item index 5, then types a query
- WHEN: `searchQuery` changes
- THEN: `activeSettingIndex` = 0, `scrollOffset` = 0
**Why This Matters**: Prevents out-of-bounds index on a shorter filtered list.

### REQ-DIALOG-004: Render Persistent Search Box

**Full Text**: The Settings dialog header MUST include a rounded-border `Box` containing `<TextInput>` with placeholder "Search to filter", always visible.
**Behavior**:
- GIVEN: The Settings dialog is open
- WHEN: Any state — initial, mid-search, editing inline
- THEN: The search box is always rendered (not conditionally hidden)
**Why This Matters**: Persistent visibility is the core UX improvement over the hidden "/" mode.

### REQ-DIALOG-005: No-Results Message

**Full Text**: When `filteredItems` is empty and `searchQuery` is non-empty, MUST render "No matching settings" text.
**Behavior**:
- GIVEN: Search query matches no settings
- WHEN: The settings area renders
- THEN: "No matching settings" appears instead of (or in addition to) the empty list
**Why This Matters**: User feedback when query is too specific.

### REQ-DIALOG-006: Clear Search on Sub-Settings Mode Entry

**Full Text**: When entering sub-settings mode (e.g., `coreToolSettings`), the search query MUST be cleared.
**Behavior**:
- GIVEN: User has a search query active and selects a sub-settings group
- WHEN: Sub-settings mode activates
- THEN: `searchQuery` resets to `''`
**Why This Matters**: Prevents the sub-settings list from being pre-filtered by a query intended for the parent list.

## Implementation Tasks

### Files to Modify

- `packages/cli/src/ui/components/SettingsDialog.tsx`
  - ADD: `@plan:PLAN-20250219-GMERGE021.R11.P04`

#### Step 4.1: Add Imports

```typescript
import { useUIState } from '../contexts/UIStateContext.js';
import { useTextBuffer } from './shared/text-buffer.js';
import { TextInput } from './shared/TextInput.js';
import { theme } from '../semantic-colors.js';
```

#### Step 4.2: Add Search State and Buffer

Add after existing state declarations, before `generateSettingsItems`:

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.R11.P04
 * @requirement REQ-DIALOG-001
 */
const { mainAreaWidth } = useUIState();
// Subtract 8 for dialog border (2) + padding (2) + scroll indicator margin (2) + search box padding (2)
const viewportWidth = Math.max(10, (mainAreaWidth ?? 80) - 8);
const [searchQuery, setSearchQuery] = useState('');

const buffer = useTextBuffer({
  initialText: '',
  initialCursorOffset: 0,
  viewport: { width: viewportWidth, height: 1 },
  isValidPath: () => false,
  onChange: (text) => setSearchQuery(text.replace(/\n/g, '')), // strip newlines from paste
});
```

**Note:** `isSearching` state MUST NOT be added.

#### Step 4.3: Add Filter Logic

After `const items = generateSettingsItems();`, add:

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.R11.P04
 * @requirement REQ-DIALOG-002
 */
const filteredItems = searchQuery.trim()
  ? items.filter((item) =>
      item.label.toLowerCase().includes(searchQuery.trim().toLowerCase()),
    )
  : items;
```

Replace all subsequent uses of `items` in navigation bounds and rendering with `filteredItems`.

#### Step 4.4: Reset Navigation on Filter Change

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.R11.P04
 * @requirement REQ-DIALOG-003
 */
useEffect(() => {
  setActiveSettingIndex(0);
  setScrollOffset(0);
}, [searchQuery]);
```

#### Step 4.5: Update Visible Items Slice and Navigation Bounds

Change:
```typescript
const visibleItems = items.slice(scrollOffset, scrollOffset + maxItemsToShow);
```
To:
```typescript
const visibleItems = filteredItems.slice(scrollOffset, scrollOffset + maxItemsToShow);
```

Update all navigation upper bounds from `items.length` to `filteredItems.length` throughout the keypress handler.

#### Step 4.6: Audit Keystroke Routing

Verify the existing keypress handler does NOT consume printable characters when `editingKey` is null and `focusSection === 'settings'`. These must pass through to the search buffer.

- Check the digits handler: `/^[0-9]$/.test(key.sequence)` that starts edit mode. This CONFLICTS with typing digits into the search field.
- **Resolution**: Scope the digit-to-edit-mode handler to only activate when `searchQuery === ''` and `editingKey === null`, OR remove it entirely since users can press Enter to initiate editing on a number setting.

#### Step 4.7: Escape Behavior Stays the Same

No change to Escape behavior required. The current priority:
1. `editingKey` set → commit edit
2. `subSettingsMode.isActive` → return to parent
3. else → save restart settings, close dialog

Search does NOT add a fourth Escape layer.

#### Step 4.8: Clear Search on Sub-Settings Mode Entry

When setting `subSettingsMode` to active, also clear the search:

```typescript
/**
 * @plan PLAN-20250219-GMERGE021.R11.P04
 * @requirement REQ-DIALOG-006
 */
setSubSettingsMode({ ...newSubSettingsMode });
setSearchQuery('');
// If TextBuffer exposes a reset/clear method, call it here; otherwise the onChange
// callback will sync state via the next buffer interaction
```

Inspect `TextBuffer` type for a `clear()` or `reset()` method. If absent, the `searchQuery` state reset is sufficient for filtering — the buffer's visual state will clear on next mount/focus.

#### Step 4.9: Add Search Box to UI Rendering

Replace the current header (after the title `<Text bold>` block):

```typescript
{/*
 * @plan PLAN-20250219-GMERGE021.R11.P04
 * @requirement REQ-DIALOG-004
 */}
<Box
  borderStyle="round"
  borderColor={
    focusSection === 'settings' && !editingKey
      ? theme.border.focused
      : theme.border.default
  }
  paddingX={1}
  height={3}
  marginTop={1}
>
  <TextInput
    focus={focusSection === 'settings' && !editingKey}
    buffer={buffer}
    placeholder="Search to filter"
  />
</Box>
```

#### Step 4.10: Add No-Results Message

In the settings list render area, add:

```typescript
{/*
 * @plan PLAN-20250219-GMERGE021.R11.P04
 * @requirement REQ-DIALOG-005
 */}
{filteredItems.length === 0 && searchQuery.trim() && (
  <Text color={Colors.Gray}>No matching settings</Text>
)}
```

## Verification Commands

```bash
# Check plan marker added
grep -n "@plan:PLAN-20250219-GMERGE021.R11.P04" packages/cli/src/ui/components/SettingsDialog.tsx | wc -l
# Expected: 5+ occurrences

# Confirm no isSearching state was introduced
grep -n "isSearching" packages/cli/src/ui/components/SettingsDialog.tsx
# Expected: No matches

# Confirm items replaced with filteredItems
grep -n "\bitems\b" packages/cli/src/ui/components/SettingsDialog.tsx | grep -v "filteredItems\|generateSettings\|allItems\|subItems"
# Review output — ensure no bare `items` usage remains in navigation/render

# Typecheck
npm run typecheck 2>&1 | grep -i "SettingsDialog\|error" | head -30

# Lint
npm run lint packages/cli/src/ui/components/SettingsDialog.tsx 2>&1 | head -30
```

### Deferred Implementation Detection

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB|XXX|TEMPORARY|WIP|not yet|will be)" \
  packages/cli/src/ui/components/SettingsDialog.tsx | grep -v ".test.ts"
# Expected: No matches related to this phase's changes
```

## Semantic Verification Checklist

1. **Does the code DO what the requirement says?**
   - [ ] `searchQuery` state initialized to `''`
   - [ ] `buffer` created with `viewport.height: 1`
   - [ ] `filteredItems` derived from `items` and `searchQuery`
   - [ ] `useEffect` resets navigation on `searchQuery` change
   - [ ] All navigation uses `filteredItems.length` not `items.length`
   - [ ] Search `Box` with `TextInput` renders in UI
   - [ ] "No matching settings" renders when `filteredItems.length === 0`
   - [ ] Sub-settings mode entry clears `searchQuery`

2. **Keystroke routing is clean:**
   - [ ] Digit handler scoped to not conflict with search input
   - [ ] `TextInput` `isActive` controlled by `focusSection === 'settings' && !editingKey`
   - [ ] Escape behavior unchanged (closes dialog, not just clears search)

3. **Feature is reachable:**
   - [ ] User can open Settings dialog and see search box immediately
   - [ ] User can type to filter without pressing any hotkey first

## Success Criteria

- `SettingsDialog.tsx` modified with all 10 steps completed
- Typechecks without errors
- Lint passes
- Plan markers present for each major change block
- No `isSearching` state introduced

## Failure Recovery

If typecheck fails:
1. `git diff packages/cli/src/ui/components/SettingsDialog.tsx` to identify problem
2. Fix import paths (`.js` extensions) or type mismatches
3. Re-run typecheck

If behavior breaks existing tests:
1. Isolate which test fails
2. Check if `items` → `filteredItems` replacement missed a spot
3. Fix and re-verify

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P04.md`

---

# Phase P05: Update Tests and Verify Passing

## Phase ID

`PLAN-20250219-GMERGE021.R11.P05`

## Prerequisites

- Required: Phase P04 completed
- Verification: `grep -n "TextInput\|searchQuery\|filteredItems" packages/cli/src/ui/components/SettingsDialog.tsx | head -5`
- Expected: All P04 changes present in SettingsDialog.tsx

## Requirements Implemented (Expanded)

### REQ-TEST-001: TDD Passing — Failing Tests from P02 Now Pass

**Full Text**: All 5 tests written in Phase P02 MUST now pass after P04 implementation.
**Behavior**:
- GIVEN: P04 implementation is complete
- WHEN: `npm test SettingsDialog.test.tsx` is run
- THEN: All P02 tests pass; no existing tests regress
**Why This Matters**: TDD loop closes — red → green.

### REQ-TEST-002: UIStateContext in Test Renders

**Full Text**: All SettingsDialog test renders MUST wrap the component in `UIStateProvider` since `useUIState()` is now called.
**Behavior**:
- GIVEN: SettingsDialog now calls `useUIState()`
- WHEN: Tests render `<SettingsDialog>`
- THEN: `UIStateProvider` is in the wrapper chain
**Why This Matters**: Without the provider, tests throw a context error.

### REQ-TEST-003: Snapshot Updated and Reviewed

**Full Text**: The SettingsDialog snapshot MUST be updated and manually reviewed to confirm the search box renders correctly.
**Behavior**:
- GIVEN: Visual structure changed (search box added)
- WHEN: `--updateSnapshot` is run
- THEN: New snapshot includes the "Search to filter" box; reviewer confirms it looks correct
**Why This Matters**: Blind snapshot acceptance can hide rendering regressions.

## Implementation Tasks

### Files to Modify

- `packages/cli/src/ui/components/SettingsDialog.test.tsx`
  - ADD: `UIStateProvider` to test render helpers
  - VERIFY: All 5 P02 tests now pass
  - ADD: `@plan:PLAN-20250219-GMERGE021.R11.P05`

- `packages/cli/src/ui/components/__snapshots__/SettingsDialog.test.tsx.snap`
  - UPDATE: Via `--updateSnapshot` after manual review

#### Step 5.1: Add UIStateProvider to Test Wrappers

Find the current render helper(s) in `SettingsDialog.test.tsx` and add `UIStateProvider`:

```typescript
import { UIStateProvider } from '../../contexts/UIStateContext.js';

// Updated wrapper:
render(
  <UIStateProvider>
    <KeypressProvider>
      <VimModeProvider>
        <SettingsDialog ... />
      </VimModeProvider>
    </KeypressProvider>
  </UIStateProvider>
);
```

Verify `UIStateProvider` is exported from `UIStateContext.tsx`.

#### Step 5.2: Run P02 Tests — Must Now Pass

```bash
npm test packages/cli/src/ui/components/SettingsDialog.test.tsx -- --grep "search"
# Expected: All 5 search tests pass
```

#### Step 5.3: Update Snapshot with Manual Review

```bash
# First, inspect what changed:
npm test packages/cli/src/ui/components/SettingsDialog.test.tsx -- --updateSnapshot 2>&1 | head -50

# Then manually review snapshot diff:
git diff packages/cli/src/ui/components/__snapshots__/SettingsDialog.test.tsx.snap
# Confirm: "Search to filter" box is present in new snapshot
# Confirm: No unintended structural regressions
```

#### Step 5.4: Complete Test Matrix Verification

After implementation, manually verify these scenarios are covered:

**Search field rendering:**
- [ ] "Search to filter" placeholder appears in initial render
- [ ] Search box renders with focused border when `focusSection === 'settings'`
- [ ] Search box renders with default border when `focusSection === 'scope'`

**Filtering behavior:**
- [ ] Typing a query filters settings to matching items only (case-insensitive)
- [ ] Clearing query restores full settings list
- [ ] Non-matching query renders "No matching settings" message
- [ ] `activeSettingIndex` resets to 0 when query changes

**Navigation with filter:**
- [ ] Up/Down navigate within filtered results only
- [ ] Scroll offset updates correctly with filtered list length
- [ ] Entering sub-settings mode clears the search query

**Focus and keystroke routing:**
- [ ] Tab switches focus from settings (search) to scope section
- [ ] While `editingKey` is set, search field does not capture keystrokes
- [ ] After editing completes, search field resumes focus

**Escape behavior:**
- [ ] Escape with search query present closes the dialog (does not just clear search)
- [ ] Escape with `editingKey` set commits the edit, not closes the dialog

**Regression — existing tests must still pass:**
- [ ] Navigation (arrows, vim keys) — unaffected
- [ ] Scope selection via Tab and RadioButtonSelect — unaffected
- [ ] Boolean toggle via Enter/Space — unaffected
- [ ] Enum cycling — unaffected
- [ ] Restart-required settings flow — unaffected
- [ ] Sub-settings mode (coreToolSettings) — unaffected
- [ ] Inline string/number editing — unaffected

## Verification Commands

```bash
# Run all SettingsDialog tests
npm test packages/cli/src/ui/components/SettingsDialog.test.tsx

# Confirm plan markers
grep -n "@plan:PLAN-20250219-GMERGE021.R11.P05" packages/cli/src/ui/components/SettingsDialog.test.tsx

# Check snapshot contains search box
grep -n "Search to filter" packages/cli/src/ui/components/__snapshots__/SettingsDialog.test.tsx.snap
# Expected: Match found
```

### Deferred Implementation Detection

```bash
grep -rn -E "(TODO|FIXME|HACK|STUB|in a real|for now|not yet)" \
  packages/cli/src/ui/components/SettingsDialog.test.tsx
# Expected: No new matches from this phase
```

## Semantic Verification Checklist

1. **Tests actually verify behavior:**
   - [ ] P02 tests pass (not just exist)
   - [ ] Tests simulate keypresses, not just render calls
   - [ ] Snapshot reviewed (not blindly accepted)

2. **No regression:**
   - [ ] All pre-existing tests pass
   - [ ] `npm test` for SettingsDialog shows only green

3. **Snapshot is correct:**
   - [ ] "Search to filter" appears in snapshot
   - [ ] No missing content vs. pre-change snapshot
   - [ ] Border colors render correctly in snapshot

## Success Criteria

- All 5 P02 tests pass
- Zero test regressions
- Snapshot updated and manually reviewed
- `UIStateProvider` added to test wrappers

## Failure Recovery

If P02 tests still fail after P04:
1. Read test error output carefully — is it a context error or assertion error?
2. For context error: add `UIStateProvider` (step 5.1)
3. For assertion error: review P04 implementation against REQ-SEARCH-XXX requirements

If existing tests fail:
1. `git diff packages/cli/src/ui/components/SettingsDialog.tsx` to identify breaking change
2. Check if `items` → `filteredItems` replacement introduced a bug
3. Check if new `useEffect` is causing unexpected re-renders in test environment

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P05.md`

---

# Phase P06: Full Verification Suite

## Phase ID

`PLAN-20250219-GMERGE021.R11.P06`

## Prerequisites

- Required: Phase P05 completed
- Verification: All SettingsDialog tests pass (zero failures)

## Requirements Implemented (Expanded)

### REQ-VERIFY-001: Project Verification Suite Passes

**Full Text**: ALL project verification steps MUST pass before the implementation is considered complete.
**Behavior**:
- GIVEN: All code changes are complete
- WHEN: Full verification suite is run
- THEN: `npm run test`, `npm run typecheck`, `npm run lint`, `npm run format`, `npm run build`, and the haiku smoke test all pass
**Why This Matters**: Per project mandate, nothing is done until all checks are green.

## Implementation Tasks

Run and fix any failures in this order. Do not skip steps.

### Step 6.1: Run Full Test Suite

```bash
npm run test
```

Fix any failures before proceeding.

### Step 6.2: Typecheck

```bash
npm run typecheck
```

Fix any type errors before proceeding.

### Step 6.3: Lint

```bash
npm run lint
```

Fix any lint errors before proceeding.

### Step 6.4: Format

```bash
npm run format
```

Apply formatting changes if any.

### Step 6.5: Build

```bash
npm run build
```

Fix any build errors before proceeding.

### Step 6.6: Smoke Test

```bash
node scripts/start.js --profile-load synthetic "write me a haiku"
```

Verify output is a haiku (3 lines, 5-7-5 syllable structure roughly). Fix any runtime errors before proceeding.

## Verification Commands

```bash
# All-in-one verification (run each; fix before running next)
npm run test && \
npm run typecheck && \
npm run lint && \
npm run format && \
npm run build && \
node scripts/start.js --profile-load synthetic "write me a haiku"
```

### Structural Verification Checklist

- [ ] `npm run test` — 0 failures
- [ ] `npm run typecheck` — 0 errors
- [ ] `npm run lint` — 0 errors
- [ ] `npm run format` — no unformatted files
- [ ] `npm run build` — success
- [ ] Smoke test — haiku output produced

### Deferred Implementation Detection (Final Check)

```bash
# Scan all modified files for leftover stubs
grep -rn -E "(TODO|FIXME|HACK|STUB|XXX|TEMPORARY|WIP)" \
  packages/cli/src/ui/components/shared/TextInput.tsx \
  packages/cli/src/ui/components/SettingsDialog.tsx \
  packages/cli/src/ui/components/SettingsDialog.test.tsx | grep -v ".test.ts"
# Expected: No matches
```

## Semantic Verification Checklist

1. **Feature actually works end-to-end:**
   - [ ] Settings dialog opens in running app
   - [ ] Search box is immediately visible (no hotkey required)
   - [ ] Typing filters the settings list in real time
   - [ ] Escape closes the dialog (not just clears search)
   - [ ] Sub-settings mode clears search
   - [ ] All existing Settings dialog features work unchanged

2. **No regressions introduced:**
   - [ ] Full test suite passes
   - [ ] Build succeeds
   - [ ] Smoke test succeeds

3. **Code quality:**
   - [ ] No TODO/HACK/STUB markers left
   - [ ] No empty returns in implementation
   - [ ] All plan markers traceable

#### Feature Actually Works

```bash
# Manual test: open settings dialog in running app
node scripts/start.js --profile-load synthetic
# Then: press Ctrl+, (or whatever key opens Settings), type "theme", observe filtered list
# Expected: Only settings containing "theme" in their label are shown
# Actual behavior: [paste what actually happens]
```

## Success Criteria

- All 6 verification steps pass without errors
- Smoke test produces valid haiku output
- Feature manually verified to work in running app

## Failure Recovery

If build fails:
1. Read build error output
2. Fix TypeScript errors (usually import path or type mismatch)
3. Re-run `npm run build`

If smoke test fails:
1. Check if error is in SettingsDialog (unlikely in non-interactive smoke test)
2. Check if imports from new files caused a module resolution error
3. Verify `.js` extensions on all new imports

## Phase Completion Marker

Create: `project-plans/gmerge-0.21.3/.completed/P06.md`

---

## Execution Tracker

| Phase | ID | Status | Started | Completed | Verified | Semantic? | Notes |
|-------|-----|--------|---------|-----------|----------|-----------|-------|
| P01 | Preflight | [ ] | - | - | - | N/A | Verify all assumptions |
| P02 | TDD Tests | [ ] | - | - | - | [ ] | Write 5 failing tests |
| P03 | TextInput | [ ] | - | - | - | [ ] | Create shared/TextInput.tsx |
| P04 | SettingsDialog | [ ] | - | - | - | [ ] | Modify main component |
| P05 | Test Fixes | [ ] | - | - | - | [ ] | Pass P02 tests; update snapshot |
| P06 | Verification | [ ] | - | - | - | [ ] | Full suite green |

---

## Risk Assessment

### Low Risk
- `shared/TextInput.tsx` creation is isolated and new; no existing code changes
- `semantic-colors.ts` already exports `theme` with required properties
- Search is net-new — no existing behavior to remove or break
- `useTextBuffer` already supports `onChange` callback

### Medium Risk
- `useTextBuffer` lacks `singleLine` — relying on `viewport.height: 1` for single-line behavior; multi-line text pasted into the search field may wrap unexpectedly
  - **Mitigation**: Strip `\n` in the `onChange` callback before setting `searchQuery`
- Keystroke routing between search buffer and edit mode `useKeypress` handlers needs careful audit
  - **Mitigation**: Use `isActive: focus` on `TextInput`'s `useKeypress` to disable when `editingKey` is set
- `UIStateContext` dependency added to SettingsDialog may require test infrastructure updates
  - **Mitigation**: Add `UIStateProvider` to test wrappers (Step 5.1)
- Digits-in-normal-mode conflict: `/^[0-9]$/.test(key.sequence)` starts edit mode — conflicts with typing digits into search
  - **Mitigation**: Scope digit handler behind `searchQuery === ''` check, or remove it (users can press Enter to edit)

### High Risk
- None identified (feature is additive; no deletions of existing behavior)

---

## Files to Modify

1. **Create:** `/packages/cli/src/ui/components/shared/TextInput.tsx`
2. **Modify:** `/packages/cli/src/ui/components/SettingsDialog.tsx`
3. **Modify:** `/packages/cli/src/ui/components/SettingsDialog.test.tsx`
4. **Update:** `/packages/cli/src/ui/components/__snapshots__/SettingsDialog.test.tsx.snap`
5. **No changes needed to:** `text-buffer.ts`, `semantic-colors.ts`, `UIStateContext.tsx`, `ProfileCreateWizard/TextInput.tsx`

---

## Key Constraints (Do Not Violate)

- **Do NOT add `isSearching` state.** The upstream UX is persistent (always-visible) search — there is no modal searching mode.
- **Do NOT add a "/" handler to remove.** LLxprt's SettingsDialog never had one.
- **Use `theme` from `semantic-colors.ts` directly.** Do not fall back to `Colors` for the search box border.
- **`singleLine` is not supported** in LLxprt's `useTextBuffer`. Use `viewport.height: 1` and strip newlines from `onChange`.
- **Update snapshots only after manual review.** Do not blindly accept `--updateSnapshot`.
- **Do NOT modify `ProfileCreateWizard/TextInput.tsx`** — different API, different use case.
