 The render-loop is still coming from one (actually two) hooks that were not touched during the recent refactor:
   1. usePhraseCycler – drives the rotating “witticisms”
   2. useToolScheduler – polls tool-call confirmations
  Both hooks contain a useEffect(() => { …setState… }) without a dependency array.
  Because React treats an effect with no second argument as “run after every render”, the setState
  inside it triggers another render → the effect fires again → … producing the
  “Maximum update depth exceeded” avalanche you are seeing.  
  Every time a witticism is advanced or a tool call is scheduled another nested
  render is added, so the warning count grows (“multiplies”) exactly as you
  observed.
  Minimal reproducer (from usePhraseCycler.ts):
    1 export const usePhraseCycler = (phrases: string[], intervalMs = 4000) => {
    2   const [index, setIndex] = useState(0);
    3 
    4   // ⚠ runs after *every* render, then calls setIndex → infinite loop
    5   useEffect(() => {
    6     const id = setTimeout(() => setIndex(i => (i + 1) % phrases.length), intervalMs);
    7     return () => clearTimeout(id);
    8   });           //  <--  ❌  no dependency array
    9   return phrases[index];
   10 };
  useToolScheduler.ts has the same pattern.
  How to fix
   1. Give each effect a stable dependency list:
   1     useEffect(() => {
   2       const id = setTimeout(() => setIndex(i => (i + 1) % phrases.length), intervalMs);
   3       return () => clearTimeout(id);
   4     }, [phrases.length, intervalMs]); // ✅ runs only when inputs really change
      For useToolScheduler depend on the polling interval / enabled flag.
   2. Alternatively start the timers once with an empty array:
   1     useEffect(() => {
   2       const id = setInterval(tick, intervalMs);
   3       return () => clearInterval(id);
   4     }, []); // ✅ initialise once
   3. Make sure callbacks placed in dependency arrays are wrapped in
      useCallback so their identity is stable.
  After adding the correct dependency arrays (or converting to useRef +
  setInterval started once) the render count stays at 1 and the “Maximum update
  depth exceeded” error disappears even when witticisms rotate or tool calls are
  queued.

